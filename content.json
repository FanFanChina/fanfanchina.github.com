{"meta":{"title":"桃花换小鱼干の博客","subtitle":"","description":"","author":"张帆帆","url":"https://xn--ctta.icu","root":"/"},"pages":[{"title":"友情链接","text":"","path":"link/index.html","date":"09-15","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"09-15","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"09-15","excerpt":""}],"posts":[{"title":"积极心理学（二）","text":"准许为人理论人类情绪就像万有引力一样，都是客观存在的，我们无法改变！ 论据忽视万有引力造飞船大骗局（告诉他人自己很好）AA运动宣言 实践一、ABC理论：我们无条件接受自己的情绪，但是不代表我们屈服于自己的情绪，在行为上我们选择道德的做法！二、冥想：在情感上感受准许为人的含义。链接：1:04:35 人们总是按你做的做理论人们总是按你做的做，而非说的做！ 论据一、圣雄甘地吃太多糖二、将手放在脸颊上的测试三、成为你想在世界上想看到的改变！（Nice） 实践以身作则：不要告诉别人该怎么办，你应该以身作则先办到那件事再说！当你办到那件事情后，你就成为了榜样。传播快乐的最好方法是争取自己的快乐，教育孩子诚实的方法是自己先要诚实，我们需要当一个务实的理想主义者，理想和善意是远远不够的，最重要的是我们的行动！ 信念即自我完成预言理论信念激发我们本身存在的潜能，潜能被激发，我们更容易实现我们要做的事情，信念成了自我实现的预言！ 论据Roger Banister——梦想一英里——突破心理界限皮格马利翁效应 —— 期望越高，成绩越好。快速迸发者测试 —— 老师对学生的信念对老师的信念，对员工的信念！ 人们怎样便怎样待他，他便还是那样的人，一个人能够或应该怎样便怎样待他，他便会成为能够怎样或应当怎样的人 —— 歌德 实践我相信我可以完成这件事情，我相信他能完成这件事情，我的信念预言着事情最终被我实现！！！ 情境的力量理论情境的力量是巨大的！！！ 论据权力服从研究监狱实验——犯人和狱警两种角色的情境75岁以上的男人在20年前的环境中生活——心理和生理年龄减小飞行模拟器中视力变化映射实验 实践构建有意识的和潜意识的积极环境 环境的力量理论论据实践","path":"2021/09/17/J_积极心理学/2/","date":"09-17","excerpt":"","tags":[{"name":"心理学","slug":"心理学","permalink":"https://帆帆.icu/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"C++","text":"Hello World12345678#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main()&#123; cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl; //endl结束输入并回车 cout &lt;&lt; endl; //一个 &lt;&lt; 对应一个输出内容 return 0;&#125; IO(整数)123456789#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main()&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a &lt;&lt;&#x27; &#x27;&lt;&lt; b; return 0;&#125; IO(字符)123456789#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main()&#123; char a,b; cin &gt;&gt; a &gt;&gt; b; //输入时加不加空格都可以(空格不会读入) cout &lt;&lt; a &lt;&lt;&#x27; &#x27;&lt;&lt; b; return 0;&#125; IO(字符串)123456789#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main()&#123; string ch1,ch2; cin &gt;&gt; ch1 &gt;&gt; ch2; cout &lt;&lt; ch1 &lt;&lt;&#x27; &#x27;&lt;&lt; ch2; return 0;&#125; IO(混合型)12345678910#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main()&#123; string ch; double m; cin &gt;&gt; ch &gt;&gt; m; cout &lt;&lt; ch &lt;&lt; &#x27; &#x27; &lt;&lt; m &lt;&lt; endl; return 0;&#125; 精度控制12345678910#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main()&#123; double PI=3.1415926535897; cout &lt;&lt; PI &lt;&lt; endl; //cout默认输出6位(包含整数位) cout &lt;&lt; setprecision(10) &lt;&lt; PI; //设置精度为 10(输出10位) return 0;&#125; 输出当前精度12345678910111213//cout.precision()当前精度大小#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main()&#123; double PI=3.1415926535897; cout &lt;&lt; PI &lt;&lt; endl; //cout默认输出6位(包含整数位) cout &lt;&lt; cout.precision()&lt;&lt;endl; //精度为 6 cout &lt;&lt; setprecision(10) &lt;&lt; PI&lt;&lt;endl; //设置精度为 10(输出10位) cout &lt;&lt; cout.precision(); //精度为 10 return 0;&#125; 设置小数点后精度(定点输出)1234567891011121314//cout.precision()当前精度大小#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main()&#123; double PI = 3.1415926535897; cout &lt;&lt; fixed; //定点输出(即小数点前固定不变) cout &lt;&lt; PI &lt;&lt; endl; //cout默认输出6位 cout &lt;&lt; cout.precision() &lt;&lt; endl; //精度为 6 cout &lt;&lt; setprecision(10) &lt;&lt; PI &lt;&lt; endl; //设置精度为 10 cout &lt;&lt; cout.precision(); //精度为 10 return 0;&#125; 设置域宽123456789101112131415//cout.width()当前域宽的大小//setfill()设置填充值，作用效果=1//setw()设置域宽(默认为0、右对齐,作用效果=1)#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main()&#123; double PI=3.14; cout &lt;&lt; cout.width()&lt;&lt;endl; //输出当前域宽 cout &lt;&lt; PI&lt;&lt;endl; //输出PI cout &lt;&lt; setw(6)&lt;&lt;PI &lt;&lt; endl; //设置域宽为6并输出 cout &lt;&lt; setfill(&#x27;*&#x27;) &lt;&lt; setw(6)&lt;&lt; PI &lt;&lt; endl; //设置填充值和域宽并输出 return 0;&#125; 左对齐123456789101112131415//cout &lt;&lt; left//对其以后的cout统一左对齐输出#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main()&#123; double PI = 3.14; cout &lt;&lt; cout.width() &lt;&lt; endl; //输出当前域宽 cout &lt;&lt; PI &lt;&lt; endl; //输出PI cout &lt;&lt; left; //设置左对齐 cout &lt;&lt; setw(6) &lt;&lt; PI &lt;&lt; endl; //设置域宽为6并输出 cout &lt;&lt; setfill(&#x27;*&#x27;) &lt;&lt; setw(6) &lt;&lt; PI &lt;&lt; endl; //设置填充值和域宽并输出 return 0;&#125; 大佬的博客 CSDN 优先队列一、头文件：queue 二、写法：priority_queue &lt;数据类型，容器类型，排序方式&gt; 例子（1）123C++#include&lt;queue&gt;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;Q; priority_queue: 优先队列数据类型:int 型容器类型:vector比较方式:greater (更大、升序排列、从 top 到 basic 越来越大)vector 容器基本内涵vector 数据结构和数组非常相似，也称为单端数组vector 与普通数组区别 在于数组是静态空间，而 vector 可以动态扩展且动态扩展并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间！后两个 &gt;&gt; 之间一定要有空格，因为 “&gt;&gt;” 是位移运算！！！ 相关链接：[bitMap - 位运算](https://xn--ctta.icu/2021/07/27/1.算法与数据结构/01.算法/05.图论算法/Bit Map/) 例子（2）12345678910111213141516171819202122232425262728C++#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;Q;int ans;int main()&#123; int n, x; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; x; Q.push(x); &#125; while (Q.size()!= 1) &#123; int a, b; a = Q.top(); Q.pop(); b = Q.top(); Q.pop(); Q.push(a + b); ans += a + b; &#125; cout &lt;&lt; ans; return 0;&#125; sort函数头文件：algorithm写法如下： 123C++#include&lt;algorithm&gt;sort(起始地址,结束地址,排序方式); 例一1234567891011121314C++#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]=&#123;9,6,3,8,5,2,7,4,1,0&#125;; for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+10);//无第三个参数时默认从小到大排序 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; 例二12345678910111213141516171819C++#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;bool complare(int a,int b)//排序规则&#123; return a&gt;b;&#125;int main()&#123; int a[10]=&#123;9,6,3,8,5,2,7,4,1,0&#125;; for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; //从大到小排序 sort(a,a+10,complare);//在这里就不需要对complare函数传入参数了，这是规则 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; vector简介vector：向量一个低维空间的向量可以在无数个高维空间上进行表示，所以一个 vector 的大小是可拓展的vector 可以看成一个单端数组，左闭右开。 vector 与普通数组区别 在于数组是静态空间，而 vector 可以动态扩展，且动态扩展并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间！ CSDN_Voctorvoctor","path":"2021/09/16/B_编程语言/C++/","date":"09-16","excerpt":"","tags":[{"name":"C++","slug":"C","permalink":"https://帆帆.icu/tags/C/"}]},{"title":"C语言","text":"引言本文主要记录一些 C 语言的细节问题 EOF对于 scanf(&quot;%d%d&quot;, &amp;a, &amp;b); 而言如果 a 和 b 都被成功读入，那么 scanf 的返回值就是 2如果只有a 被成功读入，返回值为 1如果 a 和 b 都未被成功读入，返回值为 0如果遇到错误或遇到 end of file，返回值为 EOF，且返回值为 int 型当读文件操作时，遇到文件结束位置或读数据出错均会返回 EOFC 语言中所有的输入输出操作均是按读文件的思想来设计的，或者说是文件操作的一种特例，如 getchar（）就是 fgetc (stdin) 的一个宏 文件操作大佬的博客 - CSDN 内存分配123456Cint* f()&#123; int *p=malloc(100); return p;&#125; malloc 为动态分配，p 为静态分配（用变量名）f（）函数运行结束后，malloc 分配的 100字节的空间依旧存在，而变量p 则不存在了（编译器可能会保存一次） 字符串在 C语言中这样会报错，但在 Java 中可以这么用C语言的正确写法 12345678910C#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char ch[20] = &quot;China&quot;; strcpy(ch, &quot;Lisi&quot;); printf(&quot;%s&quot;, ch); return 0;&#125; 结构体与指针1234567891011Cstruct note&#123; int date; char name[20];&#125;;struct note Std;printf(&quot;%d&quot;,std.date);struct note *p=&amp;Std;printf(&quot;%d&quot;,p-&gt;date);//p-&gt;date == (*p).date == Std.date 无名结构体一、编译器对无名结构体的处理是随机生成一个不重复的变量名 二、无类型名的结构体变量在声明结构体时就得定义（后续去用的话不知道名字） 三、因为名字是随机的，所以不可以相互赋值，例子如下： 12345678Cstruct&#123; int x;&#125;a;struct&#123; int x;&#125;b;b = a; //报 incompatible type error 四、结构体的指针也无法使用，例子如下： 1234567891011C#include&lt;stdio.h&gt;struct&#123; int x;&#125;a, * pa;void main()&#123; pa-&gt;x = 1; //报 pa 是 NULL printf(&quot;%d&quot;, pa-&gt;x);&#125; 五、用 typedef 处理后可以正常使用，例子如下： 1234567891011121314C#include&lt;stdio.h&gt;typedef struct&#123; int x;&#125;a, * pa;void main()&#123; a b; pa l; l = &amp;b; b.x = 1; printf(&quot;%d&quot;, l-&gt;x);&#125; 六、对于多个内部相同属性的结构体可以用无名结构体方式处理，更方便。 scanf和getsscanf 遇到空格停止读取，gets 遇到回车停止读取 字符串截取函数1234567891011121314151617181920212223242526C#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define MAX 100//p：待截取的字符串头指针//s：截取的起始位点//n：截取长度char* Intercept_String(char *p, int s, int n)&#123; char* h; int j = 0; h = (char*)malloc((n + 1) * sizeof(char)); for (int i = s; i &lt; n + s; i++) &#123; *(h+j)= *(p+i); j++; &#125; *(h + j) = &#x27;\\0&#x27;; return h;&#125;int main()&#123; char ch[MAX]; gets_s(ch); printf(&quot;%s&quot;, Intercept_String(ch, 2, 3)); return 0;&#125; 0x3f3f3f3f0x3f3f3f3f 的十进制是 1061109567，是 109 级别的，而一般场合下的数据都是小于 109 的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形","path":"2021/09/16/B_编程语言/C语言/","date":"09-16","excerpt":"","tags":[{"name":"C语言","slug":"C语言","permalink":"https://帆帆.icu/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Python","text":"环境搭建Python 提取码：ed8m 基础语法注释123456PYTHON# 单行注释&#x27;&#x27;&#x27; 多行注释&#x27;&#x27;&#x27; Hello World12PYTHONprint(&quot;Hello World&quot;) 输出123456789101112131415161718192021222324PYTHON#1a=10print(&quot;a=&quot;,a)#print()自动换行#2age=18print(&quot;我的年龄是%d岁&quot;%age)#3s=&quot;China&quot;print(&quot;我的年龄是%d岁、我的国籍是%s&quot;%(age,s))#4print(&quot;我的名字是%s、我来自%s&quot;%(&quot;非洲小白孩&quot;,&quot;非洲&quot;))&#x27;&#x27;&#x27; %(替换对象1,替换对象2...)&#x27;&#x27;&#x27;#5print(&quot;你好！%s，我来自%s，我叫%s，今年%d岁&quot;%(&quot;HAQI&quot;,&quot;China&quot;,&quot;FanFan&quot;,18))#6print(&quot;www&quot;,&quot;baidu&quot;,&quot;com&quot;,sep=&quot;.&quot;)#Separate隔开、用 . 隔开#7print(&quot;hello &quot;,end=&quot;&quot;)#为&quot;&quot;时不换行print(&quot;world&quot;)#8print(&quot;-&quot;*30) 输入123456789PYTHON#1password = int(input(&quot;please input password：&quot;))#&quot; &quot;内为提示语print(&quot;The password is&quot;,password)print(type(password))#输入的内容默认的类别是字符串or数字#2a = int(&#x27;10231&#x27;)print(type(a)) 随机数1234PYTHONimport randoma = random.randint(1,10)print(a) if判断语句1234567891011121314151617PYTHON#1a = 100b = 101if a&gt;b: print(&#x27;a &gt; b&#x27;)#必须要有缩进，且同一范围内必须对齐else : print(&quot;a &lt; b&quot;)#2score = 90if score &gt;= 90: print(&quot;优秀&quot;)elif score&gt;70 and score&lt;90: print(&quot;一般&quot;)else: print(&quot;不及格&quot;) for循环语句1234567891011121314151617181920212223242526272829303132333435363738394041424344PYTHON#1for i in range(5): print(i,end=&quot; &quot;)print(&quot;&quot;)for i in range(1,5): print(i,end=&quot; &quot;)print(&quot;&quot;)for i in range(1,6,2): print(i,end=&quot; &quot;)print(&quot;&quot;)#1for c in &quot;China&quot;: print(c,end=&quot;&quot;)print(&quot;&quot;)for d in [&quot;adas&quot;,&quot;dsadad&quot;,&quot;sdawd&quot;]: print(d,end=&quot; &quot;)print(&quot;&quot;)a = [&quot;dada&quot;,&quot;dawd&quot;,&quot;dwad&quot;]for i in a: print(i,end=&quot; &quot;)print(&quot;&quot;)a = [&quot;dada&quot;,&quot;dawd&quot;,&quot;dwad&quot;]for i in range(1,len(a)): print(&quot;下标:&quot;,i,a[i])print(&quot;&quot;)#3i=0while i&lt;5: print(i) i+=2sum = 0m = 100while m: sum+=m m-=1else: print(&quot;求和完毕1-100的和为：&quot;,sum)#4for i in &quot;Room&quot;: if i==&quot;o&quot;: pass else: print(i) 九九乘法表12345678910111213141516PYTHONfor i in range(1,10): for j in range(1,10): if j&lt;=i: print(i,&quot;*&quot;,j,&quot;=&quot;,i*j,end=&quot;\\t&quot;) print(&quot;&quot;)i = j = 1while i&lt;=9: j=1 while j&lt;=9: if j&lt;=i: print(i,&quot;*&quot;,j,&quot;=&quot;,i*j,end=&quot;\\t&quot;) j+=1 i+=1 print(&quot;&quot;) 字符串12345678910111213141516171819202122232425262728293031323334353637383940414243PYTHON#1word = &#x27;Hello&#x27;sentence = &quot;这是一个句子&quot;paragraph = &#x27;&#x27;&#x27; 嘿嘿 这是一个段落 哈哈哈&#x27;&#x27;&#x27;print(word)print(sentence)print(paragraph)#2str1 = &quot;I&#x27;m a student&quot;#双引号内单引号失去作用print(str1)#str2 = &#x27;I&#x27;m a student&#x27;会报错str2 = &#x27;I\\&#x27;m a student&#x27;#标识该 &#x27; 无索引字符串地作用print(str2)#str3 = &quot;Jack said &quot;I like you&quot;&quot;#会报错str3 = &quot;Jack said \\&quot;I like you\\&quot;&quot;print(str3)str4 =&#x27;Jack said &quot;I like you&quot;&#x27;#单引号内双引号失去作用print(str4)#3string = &quot;China&quot;print(string[0])print(string[0:3])#默认跨度为1print(string[0:3:1])print(string[0:4:2])#跨度为2print(string[:3])#第三单元之前的(不包含3)print(string[3:])#第三单元后的（包含3）#区间访问时左闭右开！！！#4s = &quot;你好&quot;print(s+&quot;，成都！&quot;)#“+”表示字符串相连接print(s*3)#5print(&quot;hello\\nworld&quot;)print(r&quot;hello\\nworld&quot;)#r使转义字符失效 列表定义列表123456789101112PYTHON#定义一个空的列表nameList = []#定义非空列表nameList = [&quot;小张&quot;,&quot;小王&quot;,&quot;小李&quot;]print(nameList[0])#混合类型nameList = [1,&quot;China&quot;,89.2]print(type(nameList[0]))print(type(nameList[1]))print(type(nameList[2]))print(&quot;&quot;) 遍历列表1234567891011PYTHON#遍历print(&quot;开始For循环遍历nameList&quot;)nameList = [&quot;小张&quot;,&quot;小王&quot;,&quot;小李&quot;]for name in nameList: print(name)print(&quot;开始While循环遍历nameList&quot;)i = 0 while i&lt;len(nameList): print(nameList[i]) i+=1 增加元素123456789101112131415161718192021222324252627282930PYTHON#增加单个元素nameList = [&quot;小张&quot;,&quot;小王&quot;,&quot;小李&quot;]print(&quot;------增加前------&quot;)for name in nameList: print(name,end = &quot; &quot;)print(&quot;&quot;)nameTemp = input(&quot;请输入add的元素：&quot;)nameList.append(nameTemp)print(&quot;------增加后------&quot;)for name in nameList: print(name,end = &quot; &quot;)print(&quot;&quot;)PYTHON#增加一个是列表的元素a = [1,2]b = [3,4]a.append(b)print(a)PYTHON#拓展列表（合并列表）a = [1,2]b = [3,4]a.extend(b)print(a)PYTHON#插入元素（原有元素被挤到下一位）a = [1,2]a.insert(1,&quot;China&quot;)#1位置插入 Chinaprint(a) 删除元素123456789101112131415161718192021222324252627PYTHON#删除指定位置元素a = [1,&quot;China&quot;,3,4]del a[2]print(a)PYTHON#弹出尾部元素a = [1,&quot;China&quot;,3,4]a.pop()print(a)PYTHON#删除指定内容的元素a = [1,&quot;China&quot;,3,4]a.remove(1)print(a)PYTHON#clear:清空列表nameList = [&quot;小张&quot;,&quot;小王&quot;,&quot;小李&quot;]print(&quot;-----删除前------&quot;)for name in nameList: print(name,end = &quot; &quot;)print(&quot;&quot;)nameList.extend(2)print(&quot;------删除后------&quot;)for name in nameList: print(name,end = &quot; &quot;)print(&quot;&quot;) 修改元素12345PYTHON#指定下标赋值即可a = [1,&quot;China&quot;,3,4]a[1] = 2print(a) 查询元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849PYTHON#注意数据类型有数字和字符串a = [1,&quot;China&quot;,3,4]temp = input(&quot;请输入您要查找的数据:&quot;)if temp in a: print(temp,&quot;存在&quot;)elif int(temp) in a: print(temp,&quot;存在&quot;)else: print(temp,&quot;不存在&quot;)PYTHON#输出列表中某一元素的下标myList = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]print(myList.index(&#x27;a&#x27;))#我们也可以精确范围myList = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]print(myList.index(&#x27;a&#x27;,0,2))#如果找不到元素就会报错myList = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]print(myList.index(&#x27;a&#x27;,1,2))#ValueError: &#x27;a&#x27; is not in listPYTHON#统计元素个数myList = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;a&#x27;]print(myList.count(&#x27;a&#x27;))PYTHON#反转和排序myList = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;a&#x27;]myList.reverse()print(myList)myList.sort()print(myList)myList.sort(reverse=True)#排序后反转（降序）print(myList)PYTHON#办公室分配import randomoffices = [[],[],[]]names = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;]for name in names: index = random.randint(0,2) offices[index].append(name)i = 0while i&lt;3: print(&quot;%d号办公室有%d人，分别为 &quot;%(i+1,len(offices[i])),end=&quot;&quot;) for name in offices[i]: print(name,end=&quot; &quot;) print(&quot;&quot;) i+=1 元组定义元组1234567PYTHONtup = ()print(type(tup))tup = (50)#等价于tup = 50print(type(tup))#&lt;class &#x27;int&#x27;&gt;tup = (50,)print(type(tup))#&lt;class &#x27;tuple&#x27;&gt; 元组的相关操作1234567891011121314151617PYTHON#可遍历，查找，整体删除tup = (1,2,3,4,5)for i in tup: print(i)print(tup[3])print(tup[-1])if 4 in tup: print(&quot;Yes&quot;)tupx =tup+tupprint(tupx)tupx.sort()#AttributeError: &#x27;tuple&#x27; object has no attribute &#x27;sort&#x27;print(tupx)tup = (1,2,3,4,5)del tupprint(tup)#NameError: name &#x27;tup&#x27; is not defined 字典定义12PYTHONd = &#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;#键+值 访问和查找123456789PYTHON#访问d = &#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;print(d[&quot;name&quot;])print(d[&quot;age&quot;])print(d[&quot;geand&quot;])#键不存在时直接访问会 KeyError: &#x27;geand&#x27;#判断某个key是否存在print(d.get(&quot;grand&quot;))#显示：Noneprint(d.get(&quot;grand&quot;,0))#显示：0（初始化为0） 增加键值对12345PYTHONkey = input(&quot;请输入新的键：&quot;)p = input(&quot;请输入新键的值：&quot;)d[key] = pprint(d[key]) 删除键值对123456789PYTHON#deld = &#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;del d[&quot;name&quot;]print(d[&quot;name&quot;])#KeyError: &#x27;name&#x27;#cleard = &#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;d.clear()print(d)#打印结果为 &#123;&#125; 修改键值对1234PYTHONd = &#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;d[&quot;name&quot;]=&quot;哈哈&quot;print(d) 查找与遍历键值对12345678910111213PYTHON d = &#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;print(d.keys())#[&#x27;name&#x27;, &#x27;age&#x27;]print(d.values())#[&#x27;吴彦祖&#x27;, 18]print(d.items())#[(&#x27;name&#x27;, &#x27;吴彦祖&#x27;), (&#x27;age&#x27;, 18)]、每一项是一个元组#遍历d = &#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;for key in d.keys(): print(key)for value in d.values(): print(value)for key,value in d.items(): print(&quot;key=%s value=%s&quot;%(key,value)) 在列表中也有类似的表达： 123456789101112PYTHONnames = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;]for i,x in enumerate(names):#对names枚举 print(i,x)# 1 B# 2 C# 3 D# 4 E# 5 F# 6 G# 7 H# 8 I 集合12345PYTHON#去重myList = [1,2,2,3,4]s = set(myList)print(s)","path":"2021/09/16/B_编程语言/Python/","date":"09-16","excerpt":"","tags":[{"name":"Python","slug":"Python","permalink":"https://帆帆.icu/tags/Python/"}]},{"title":"积极心理学（一）","text":"积极心理学引言《积极心理学》是一门以健康模型为核心的课程，相对于传统的疾病模型，积极心理学更注重于对个人积极性的培养，而并不是直接面对心理疾病。你生病了，只是因为你的生活还不够健康，你不去追求那些使你健康的东西，积极心理学可以帮助我们达到那种充满激情，紧张的生活状态。 一切的前提学习本课程最重要的不是理论，而是学习完理论之后的实践环节，你只需要做出一种努力，即应用的努力 安静理论安静是我们文化所缺失的一部分，我们会忍不住打破沉默。安静是一种最深层次的学习媒介，记忆再现的过程，使我们区分出什么是最重要的，什么是不那重要的安静给了我们经历过后反省自己所闻的机会 论据《教学的勇气》有酒和没酒的小鼠走迷宫崇尚安静的印第安人文化 实践内省：一、找一个安静的环境，仔细回顾之前的经历（学习经历，交流经历等等）二、仔细想想什么是最重要的，哪些是很重要的，哪些是不那么重要的注：一步骤和二步骤交替进行，直到自己认为达到了内省的效果！ Transform理论大多数教育只是在传递信息，这是远远不够的，关键在于接收信息的容器的形状，信息是客观存在的，形状决定了我们的自尊水平和快乐水平！ 论据比赛目标是前三名，结果是第八名的两种解读 —— 解读模型的重要性 实践一、构建解读模型：当我们教别人一些东西时，我们不光要传递信息，还要想办法为信息的理解构建一种解读模型二、失败变成机遇：失败后自省 (见安静的理念)，让我们看看我们能学到什么！ 关于多余的石头引言《大卫》—— 米开朗基罗 真相对失败的恐惧，对成功的畏惧，完美主义等等不是与生俱来的，在世经历让我们被限制，使我们无法窥视自己的内心，社会的教条，长辈的训诫，有时候会是那多余的石头，将自我封闭掉。凿掉多余的石头像极了人生的第三境界 —— 看山是山，看水是水！ 问题的力量理论教育的目的在于让一个人不断地发问！问题制造现实，制造可能性，一个问题引起一场探索一个问题能够将我们的专注力聚焦到某个现实中，是聚焦神器 论据由致病模型到建康模型的转变使积极心理学有了长足的进展几何图形的数量 实践问和答：作为教育者的身份时，不仅要让你的教育对象多问，及时提出问题！并且多对教育者抛出问题！自问：当你要学习专注一件事时，试着对其不断提出问题，能够让我们迅速专注于所做的事情！扩大与兼顾：当问题所关注的事情只是一件或者所关注的事情具有正反面时，尝试扩大范围 or 兼顾正反面！ 没人会来的理论没有人会来到你的生活中帮你解决你所遇到的问题，一切的成败都靠你自己，教育者的存在是为了我们个人的前进创造条件，一切都要靠我们自身做出努力！ 实践常常问自己，自己改变了什么？、思考自己需要在哪些方面做出努力时刻认识自己才是自己生活的缔造者，做出行动，天高任鸟飞！","path":"2021/09/16/J_积极心理学/1/","date":"09-16","excerpt":"","tags":[{"name":"心理学","slug":"心理学","permalink":"https://帆帆.icu/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"机器编码","text":"引言本片文章关于计算机是如何二进制存储数字的 为什么选择二进制？大多数人类文明选择了十进制 (因为手指头有 10 根，最开始人们计数是靠手去数的) 但也有例外，玛雅人采用 20 进制服务于天文历法的计数，楔形文字采用 60 进制 计算机在发明以后，需要选用一种进制来储存数据 当时选有 10 进制的，3 进制的，8 进制的，但事实证明 2 进制才是最不容易出错的 其实电路中电压的高低，是电容上电荷的多少，是磁盘上的磁化程度，光盘上的蚀刻程度，光纤中发光二极管或者 “小灯泡” 的亮度 —— 而这些全都是（几乎）连续的物理量，并没有什么天然的 “只能取两个值” 的属性。 计算机选择 2 进制只是因为相对而言 2 进制更不容易出错 机器编码原码例如我们要存储一个十进制整数3 3——00000011（我们可以用 1byte（字节）去存储） 在 C语言中给一个整数分配 4个byte，所以 3 在 C 语言分配的内存中表示如下 3——00000000 00000000 00000000 00000011 一个字节占 8 位，我们所说的 32 位 / 64 位系统指的是系统能够一次性处理多少位32 位即 4 个 byte，4 个 byte 可以表示 2 的 32 次方 = 4294967296（bit）个地址，约 4G64 位即 8 个 byte，8 个 byte 可以表示 2 的 64 次方 = 4294967296 的 32 次方（bit）大于 1 亿 GB 接下来我们考虑一个 8位的系统 数值有正负之分，计算机就用一个数的最高位存放符号 (0为正,1为负) 3 表示为 00000011，最高位为 0 表示其为正数 -3 表示为 10000011，最高位为 1 表示其为负数 那么 1byte 能表示数值的范围为 (1~127 到 -127~-1, )（最高位 0 到 1）共 256 个 表示完了后，我们用该编码加减运算的时候出现了问题，如下：假设字长为 8bits 1-1=1+(-1)=0 00000001b + 10000001b = 10000010b (结尾用字母 b 或者 B 表示二进制数) 但 10000010b=-2 显然是不正确 我们称这种编码为原码，原码是人脑最容易理解和计算的表示方式. 但原码的加减法运算不能够顺利进行，由此发明了补码 补码在上述描述中用源码做减法结果是不对的，我们抛开原码这一概念 假如 1+x=0 00000001b+x=00000000b 解得x=11111111b，其实 11111111b就是 -1，但是我们并不能很好的识别出来我们需要一个过程把 -1 的原码，转换成 11111111b 即可，对于 - 1 而言，原码为 10000001b，现在我们要做的就是，把 10000001b 转换成 11111111b，我们仔细发现最高位是不变的，其余位置反置，然后再加一就得到了 11111111b 了 我们在仔细看这个过程 第一步：最高位不变，其余反置 (取反)第二步：加上 00000001b 总结：负数原码和补码之间转换（除符号位外）取反加一 我们通过观察得出取反加一这个规律，下面我们通过推导得到这个结论0 减去一个数的补码 = 该数相反数的补码，以至于这两个数的补码进行运算时和为 0补码补全了原码无法减法的不足，也补全了负数运算的空缺，并且其表示的负数和正数是一一互补的，为什么叫补码呢，就像数学中的补角一样，30 度的补角是 150 度二者的和是 180 度，180 度是一个在角度上的一个常见数，是一个凑整的状态。我们再回想一下刚刚那个公式，00000000 其实也是一个凑整的状态，只是进位的 1 丢失了 (原本是 100000000)，你可以理解为补码去表示的一对正负数，表示正数的补码和负数的补码是互补的，二者之和是一个凑整的状态！ 观察以下式子： 00000000b=11111111b+00000001b 00000000b-x=11111111b-x+00000001b (代换)=(11111111b-x)+00000001b其实括号内就是那个取反操作括号右侧加00000001 其实就是加1 反码其实是将原码转化为补码的一个桥梁，取反是一个操作 特殊的一对补码：10000000+10000000=0000000000000000+00000000=00000000上述两个补码与自身互补，转成原码后，又因为 1 表示负我们用 1000000 表示 - 128，没有 + 128，用 00000000 表示 0 不分正负 8bit 可以表示带符号的数的范围: 1～127，-1～-127，0 和 -128 机器编码总结正数：原码 = 反码 = 补码负数：反码 = 最高位不变其余反置、补码 = 源码的反码 + 1反码其实和源码的关系不大，只是一种得到补码的手段对于有符号的数而言，假如是 n位的，则可以表示 -2的n-1次方，无 +2 的 n-1 次方 (有负无正) END","path":"2021/09/16/J_计算机组成原理/J_机器编码/","date":"09-16","excerpt":"","tags":[{"name":"二进制","slug":"二进制","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"机器编码","slug":"机器编码","permalink":"https://帆帆.icu/tags/%E6%9C%BA%E5%99%A8%E7%BC%96%E7%A0%81/"}]},{"title":"Blog客户端（APP）","text":"下载地址Blog 客户端 (点击下载)","path":"2021/09/16/S_实践项目/Blog客户端/","date":"09-16","excerpt":"","tags":[{"name":"APP","slug":"APP","permalink":"https://帆帆.icu/tags/APP/"}]},{"title":"爬虫之旅","text":"开始前的准备：包库引入平台：VS Code 在终端中输入下列代码 123POWERSHELLpip install bs4pip install xlwt 引入模块12345from bs4 import BeautifulSoup #网页解析、获取数据import re #文字匹配import urllib.request,urllib.error #指定url，获取网页import xlwt #Excel操作import sqlite3 #进行sql数据库操作 建立框架123456789101112131415PYTHON#主函数def main(): baseurl = &quot;https://movie.douban.com/top250?start=&quot; dateList = getDate(baseurl) savePath = &quot;.\\\\豆瓣电影TOP250.xls&quot; saveDate(savePath)#爬取网页def getDate(baseurl): dateList = [] return dateList#保存数据def saveDate(savePath): 编写函数补充Urllib库的使用1","path":"2021/09/16/S_实践项目/P_爬虫之旅/","date":"09-16","excerpt":"","tags":[{"name":"Python","slug":"Python","permalink":"https://帆帆.icu/tags/Python/"}]},{"title":"学生学籍管理系统","text":"引言借用基础链表知识和一些文件操作写的学籍管理系统 完整代码（VC++6.0）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486C#include&lt;conio.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;windows.h&gt;#define BUFSIZE 20typedef struct Student&#123; char Name[10]; //姓名 int Number; //学号 int Grade; //年级 int Class; //班级 struct Student* next;&#125;student,*link;link h, t, p;void Clear(); //清屏void Head(); //头指针void Menu(); //主菜单void Return(); //返回菜单void Findmenu(); //查找菜单void Keycontrol(); //键盘交互void Add(); //添加信息void Addexample(); //添加信息输入示例void Find(); //查找信息void Findname(); //按姓名查找void Findnumber(); //按学号查找void Delete(link p); //删除信息void View(link p); //显示信息void Modify(link p); //修改信息void Shift(); //切换为中文void Input(); //导入信息void Output(); //导出信息void Autooutput(); //自动导出void Inputduce();void ppp();int main()&#123; Head(); Shift(); Menu(); return 0;&#125;void Clear()&#123; system(&quot;cls&quot;);&#125;void Head()&#123; h = t = (link)malloc(sizeof(student)); t-&gt;next = NULL;&#125;void Menu()&#123; Clear(); printf(&quot;\\n&quot;); printf(&quot;****************************\\n&quot;); printf(&quot;* 学生学籍信息管理系统 *\\n&quot;); printf(&quot;* (1)添加信息 *\\n&quot;); printf(&quot;* (2)查找信息 *\\n&quot;); printf(&quot;* (3)导入信息 *\\n&quot;); printf(&quot;* (4)导出信息 *\\n&quot;); printf(&quot;* (5)退出系统 *\\n&quot;); printf(&quot;****************************\\n&quot;); printf(&quot;\\n&quot;); Keycontrol(); getchar();&#125;void Returnmenu()&#123; printf(&quot;\\n&quot;); printf(&quot;即将为你返回主菜单&quot;); printf(&quot;.&quot;); Sleep(500); printf(&quot;.&quot;); Sleep(500); printf(&quot;.&quot;); Sleep(500); printf(&quot;.&quot;); Sleep(500); printf(&quot;.&quot;); Sleep(500); while (_kbhit()) getchar(); Menu();&#125;void Keycontrol()&#123; printf(&quot;请输入：&quot;); int n; scanf(&quot;%d&quot;, &amp;n); switch (n) &#123; case 1: getchar(); Add(); break; case 2: getchar(); Find(); break; case 3: getchar(); Input(); break; case 4: getchar(); Output(); break; case 5: getchar(); Autooutput(); ppp(); break; default: getchar(); printf(&quot;\\n&quot;); printf(&quot;选项不存在,请重新输入\\n&quot;); printf(&quot;\\n&quot;); Keycontrol(); break; &#125;&#125;void Addexample()&#123; printf(&quot;\\n&quot;); printf(&quot;输入示例：\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;姓名：张三\\n&quot;); printf(&quot;学号：200912047\\n&quot;); printf(&quot;年级：20级\\n&quot;); printf(&quot;班级：1班\\n&quot;); printf(&quot;\\n&quot;);&#125;void Add()&#123; Clear(); Addexample(); link p = (link)malloc(sizeof(student)); printf(&quot;请输入姓名：&quot;);gets(p-&gt;Name); if (p-&gt;Name[0]==&#x27;\\0&#x27;)//直接回车就重新输入 Add(); else &#123; printf(&quot;\\n&quot;); printf(&quot;请输入学号：&quot;); scanf(&quot;%d&quot;, &amp;p-&gt;Number); printf(&quot;\\n&quot;); printf(&quot;请输入年级：&quot;); scanf(&quot;%d级&quot;, &amp;p-&gt;Grade); printf(&quot;\\n&quot;); printf(&quot;请输入班级：&quot;); scanf(&quot;%d班&quot;, &amp;p-&gt;Class); getchar(); &#125; printf(&quot;\\n&quot;); printf(&quot;(1)确认添加 (2)重新输入\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;请输入：&quot;); int n; scanf(&quot;%d&quot;, &amp;n); if(n==2) Add(); else &#123; t-&gt;next = p; t = p; t-&gt;next = NULL; printf(&quot;\\n&quot;); getchar(); printf(&quot;添加成功!&quot;); printf(&quot;\\n&quot;); Returnmenu(); &#125;&#125;void Findmenu()&#123; Clear(); printf(&quot;\\n&quot;); printf(&quot;(1)按姓名查找\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;(2)按学号查找\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;请输入：&quot;);&#125;void Find()&#123; Findmenu(); int n; scanf(&quot;%d&quot;, &amp;n); switch (n) &#123; case 1: getchar(); Findname(); break; case 2: getchar(); Findnumber(); break; default: getchar(); Find(); break; &#125;&#125;void Findname()&#123; Clear(); printf(&quot;\\n&quot;); printf(&quot;请输入姓名：&quot;); char ch[10]; gets(ch); if (ch[0] == &#x27;\\0&#x27;) Findname(); p = h; int flag = 0; while (p-&gt;next!=NULL) &#123; p = p-&gt;next; if (!strcmp(p-&gt;Name, ch))//相同为0 &#123; flag = 1; break; &#125; &#125; if (flag==0) &#123; printf(&quot;\\n&quot;); printf(&quot;该学生信息不存在!\\n&quot;); Returnmenu(); &#125; else View(p);&#125;void Findnumber()&#123; Clear(); printf(&quot;\\n&quot;); printf(&quot;请输入学号：&quot;); int m; scanf(&quot;%d&quot;, &amp;m); p = h; int flag = 0; while (p-&gt;next != NULL) &#123; p = p-&gt;next; if (p-&gt;Number == m) &#123; flag = 1; break; &#125; &#125; if (flag==0) &#123; printf(&quot;\\n&quot;); printf(&quot;该学生信息不存在!\\n&quot;); Returnmenu(); &#125; else View(p);&#125;void View(link p)&#123; Clear(); printf(&quot;\\n&quot;); printf(&quot;信息如下：\\n&quot;); printf(&quot;姓名：%s\\n&quot;, p-&gt;Name); printf(&quot;学号：%d\\n&quot;, p-&gt;Number); printf(&quot;年级：%d级\\n&quot;, p-&gt;Grade); printf(&quot;班级：%d班\\n&quot;, p-&gt;Class); printf(&quot;\\n&quot;); printf(&quot;(1)再次查询\\n&quot;); printf(&quot;(2)修改信息\\n&quot;); printf(&quot;(3)删除信息\\n&quot;); printf(&quot;(4)返回主菜单\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;请输入：&quot;); int n; scanf(&quot;%d&quot;, &amp;n); switch (n) &#123; case 1: getchar(); Find(); break; case 2: getchar(); Modify(p); break; case 3: getchar(); Delete(p); break; case 4: getchar(); Returnmenu(); break; default: getchar(); View(p); break; &#125;&#125;void Modify(link p)&#123; Clear(); printf(&quot;\\n&quot;); printf(&quot;修改后的姓名：&quot;); gets(p-&gt;Name); if (p-&gt;Name[0] == &#x27;\\0&#x27;)//直接回车就重新输入 Modify(p); else &#123; printf(&quot;\\n&quot;); printf(&quot;修改后的学号：&quot;); scanf(&quot;%d&quot;, &amp;p-&gt;Number); printf(&quot;\\n&quot;); printf(&quot;修改后的年级：&quot;); scanf(&quot;%d级&quot;, &amp;p-&gt;Grade); printf(&quot;\\n&quot;); printf(&quot;修改后的班级：&quot;); scanf(&quot;%d班&quot;, &amp;p-&gt;Class); getchar(); &#125; printf(&quot;\\n&quot;); printf(&quot;(1)确认修改 (2)重新修改\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;请输入：&quot;); if (getchar() == &#x27;2&#x27;) Modify(p); else &#123; printf(&quot;\\n&quot;); getchar(); printf(&quot;修改成功!&quot;); Returnmenu(); &#125;&#125;void Delete(link p)&#123; link o = h; while (o-&gt;next != p) o = o-&gt;next; o-&gt;next = p-&gt;next; printf(&quot;\\n&quot;); printf(&quot;删除成功！&quot;); Returnmenu();&#125;void Shift()&#123; keybd_event(0x10, 0, 0, 0); keybd_event(0x10, 0, KEYEVENTF_KEYUP, 0);&#125;void Input()&#123; Clear(); printf(&quot;\\n&quot;); printf(&quot;目前仅支持UTF-8编码的文本！\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;请把txt文档放在D盘根目录下\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;请输入txt文件名：&quot;); char ch[20]; gets(ch); char buf[BUFSIZE]; char h[] = &#123; &quot;D://&quot; &#125;; char tt[] = &#123; &quot;.txt&quot; &#125;; strcat(h, ch); strcat(h, tt); h[2] = h[3] = 92; FILE* fp; fp = fopen(h, &quot;r&quot;); if(fp==NULL) &#123; printf(&quot;\\n&quot;); printf(&quot;文件打开失败或文件不存在！&quot;); printf(&quot;\\n&quot;); &#125; fgets(buf, BUFSIZE, fp); link p=(link)malloc(sizeof(student)); int i,j=0; for (i = 9; i &lt; strlen(buf); i++) &#123; p-&gt;Name[j] = buf[i]; j++; &#125; fgets(buf, BUFSIZE, fp); int s=0,d=1; for (i = 9; i &lt; strlen(buf); i++) &#123; s+=(buf[i]-&#x27;0&#x27;)*d; d*=10; &#125; p-&gt;Number = s; fgets(buf, BUFSIZE, fp); s=0;d=1; for (i = 9; i &lt; strlen(buf)-3; i++) &#123; s+=(buf[i]-&#x27;0&#x27;)*d; d*=10; &#125; p-&gt;Grade = s; fgets(buf, BUFSIZE, fp); s=0;d=1; for (i = 9; i &lt; strlen(buf)-3; i++) &#123; s+=(buf[i]-&#x27;0&#x27;)*d; d*=10; &#125; p-&gt;Class=s; t-&gt;next = p; t = p; t-&gt;next = NULL; printf(&quot;\\n&quot;); printf(&quot;添加完毕!&quot;); printf(&quot;\\n&quot;); Returnmenu();&#125;void Output()&#123; p = h-&gt;next; while (p != NULL) &#123; char h[] = &#123; &quot;D://&quot; &#125;; char t[] = &#123; &quot;.txt&quot; &#125;; strcat(h,p-&gt;Name); strcat(h,t); h[2] = h[3] = 92; FILE* fp = NULL; fp=fopen(h, &quot;w+&quot;); fprintf(fp, &quot;姓名：%s\\n&quot;,p-&gt;Name,10); fprintf(fp, &quot;学号：%d\\n&quot;,p-&gt;Number); fprintf(fp, &quot;年级：%d级\\n&quot;, p-&gt;Grade); fprintf(fp, &quot;班级：%d班&quot;, p-&gt;Class); fclose(fp); p = p-&gt;next; &#125; Clear(); char ch = 92; printf(&quot;\\n&quot;); printf(&quot;导出成功！\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;命名方式：姓名\\n&quot;); printf(&quot;导出格式：txt文档\\n&quot;); printf(&quot;导出目录：D:%c&quot;,ch); printf(&quot;\\n&quot;); Returnmenu();&#125;void Autooutput()&#123; p = h-&gt;next; while (p != NULL) &#123; char h[] = &#123; &quot;D://&quot; &#125;; char t[] = &#123; &quot;.txt&quot; &#125;; strcat(h,p-&gt;Name); strcat(h,t); h[2] = h[3] = 92; FILE* fp = NULL; fp=fopen(h, &quot;w+&quot;); fprintf(fp, &quot;姓名：%s\\n&quot;, p-&gt;Name, 10); fprintf(fp, &quot;学号：%d\\n&quot;, p-&gt;Number); fprintf(fp, &quot;年级：%d级\\n&quot;, p-&gt;Grade); fprintf(fp, &quot;班级：%d班&quot;, p-&gt;Class); fclose(fp); p = p-&gt;next; &#125; ppp();&#125;void ppp()&#123; printf(&quot;\\n&quot;); printf(&quot;已为你自动导出！\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;正在退出,请稍后&quot;); printf(&quot;.&quot;); Sleep(500); printf(&quot;.&quot;); Sleep(500); printf(&quot;.&quot;); Sleep(500); printf(&quot;.&quot;); Sleep(500); printf(&quot;.&quot;); Sleep(500); printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); exit(1);&#125;","path":"2021/09/16/S_实践项目/X_学生学籍管理系统/","date":"09-16","excerpt":"","tags":[{"name":"链表","slug":"链表","permalink":"https://帆帆.icu/tags/%E9%93%BE%E8%A1%A8/"},{"name":"文件","slug":"文件","permalink":"https://帆帆.icu/tags/%E6%96%87%E4%BB%B6/"}]},{"title":"导数的本质","text":"导数“导数”名称的来源导数通常来讲指的是变化率，导数的 “导” 字是指导的意思。 对于一个二维平面上的曲线而言，其曲线的弯曲变化率决定了该曲线的最终形态 换而言之，变化率（导数）指导了如何去画出这个图像，如何去得到这个图像，这就是导数名称的来源。 由变化到变化率我们暂且忘记我们学过的求导公式，既然导数表示的是变化率 那么我们就可以通过观察事物变化特点，得到其变化率，也就是其导数。 而对于事物的变化，我们需要关注的只有变化前和变化后这两种状态即可 举个例子：对于 y=2x 而言 x 是自变量（自己在其取值范围内可任意变化大小） y 是因变量（因为 x 的变化而引起相应的变化） 我们不在关注实际的函数图像形式，上文已经提到，我们需要关注的只有变化前和变化后这两种状态即可 在这里我们借用一下数轴 变化前也就 x 本身，想象一下，x 本是一个数轴上的一个点， 因为 x 本身拥有一个取值范围，所以如果遍历 x 的所有可能性，那么在数轴上 x 会形成线段的状态（可能有很多段）。 当我们对 x 进行乘以 2 时，这些线段会被拉伸为原来的 2 倍，拉伸之后我们将这条数轴上的线段称为 y。 仔细想想看上述的 x 经历了什么，其变化过程就在于那个拉伸的过程。 拉伸的过程中，点的位置发生偏移，x 实质上就是一个点，x 的位置偏移就是 x 的实际变化过程，x=1 的点会偏移 2 位置，-1 的点会偏移到 -2 的位置，而有一个点始不发生偏移，那就是数轴的原点。 既然 x 的变化我们已知晓，也就是 x 表示的点的偏移，但这是远远不够的，就像知道空间中一个点偏移到另外一个点，我们只知道其变化，而并不知道变化率，变化率无从求出。 还记得上文我们提到的吗？ 我们需要关注的只有变化前和变化后这两种状态即可 我们回到变化前的状态，也就是数轴上的某些点均匀分布构成的线段 对于 x=1 这个点而言，我们去描述其状态其实就是下面这段话 该点位于原点右侧一个单位长度处 这段话包含了相对位置信息，而并非只是说 x=1 是一个点 而变化后呢？ 该点位于原点右侧两个单位长度处 所以求得变化率时其实就是 —— 距离原点的距离之比 也就是 2 前后状态之比也就是变化率也就是导数，如果在 x-y 坐标系里面表示 也就是 x 是变化前的状态，y 是变化后的状态 对其 x 和 y 轴作垂线，其交点组成的线段就是 y=2x 的图像，图像的斜率恰好为变化率。 对于原点的个人猜测（可不看）原点的特点在于始终会回到原来的位置，即不会发生偏移。 至于原因在于其值为 0 的特殊性，任何数乘对其作用无效。 数乘其实就是放缩，这一点在线性代数和上文中显而易见） 我们在对一个事物去观察时，往往需要一个基准点，就像我们看一个东西时我们往往会找准一个角度去看，再换下一个角度一样。在实分析里面，我们学数学是为了是为了数学分析事物的实用性，所以在数学建模时我们选用的坐标系都会有一个原点（无论是直角坐标系还是极坐标系），可能在名称上略有不同，但终究是为了在数学上确定一个基准点，这个点与数建模对象无关，只和建模结果有关。还是上面那个例子，我们看一样事物时，选取不同的角度也就是不同的基准点，但事物始终时同一个事物，选取的角度不同，看到的结果也会不同，也就是建模结果不同。 结语虽然这一切在学过高中数学的人而言十分简单！ 但对于背后的思维过程的推理仔细去想也是十分美妙的！ END","path":"2021/09/16/Z_杂七杂八/D_导数的本质/","date":"09-16","excerpt":"","tags":[{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"},{"name":"导数","slug":"导数","permalink":"https://帆帆.icu/tags/%E5%AF%BC%E6%95%B0/"}]},{"title":"MarkDown","text":"文字样式1234MARKDOWN&lt;font&gt;该处为文字&lt;/font&gt;&lt;font size=6&gt;该处为文字(大小：6)&lt;/font&gt;&lt;font size=5 color=#D1DAF2&gt;**该处为文字(大小：6，颜色：#D1DAF2，已加粗)**&lt;/font&gt;` 相关链接MarkDown 语法在线 MarkDown 编辑工具表情图表情图（备用）删除线任务列表 END","path":"2021/09/16/Z_杂七杂八/MarkDown/","date":"09-16","excerpt":"","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://帆帆.icu/tags/MarkDown/"}]},{"title":"无节制消费的元凶","text":"无节制消费的元凶1、计划报废，将产品做成易损品； 2、不断推陈出新，使人对现状不满，不停购买； 3、出售安全属性等，利用人类本能； 4、广告制作中以消费者焦虑为目标，贩卖焦虑，恐惧式营销，唤醒焦虑再提供一个解决之道； 5、将儿童超级消费者的计划，故事性与授权制的销售，如漫威；同时利用小孩意见对家长购物决策的影响力，针对孩子做广告； 6、将成年人变成孩子一样，成为模范消费者，怂恿成年人释放童心，漫展、周边，成年人与儿童消费市场的界限消失，游戏，成年人更爱暴力行动游戏； 7、新的销售方式：创造 “粘性行为”，如尼奥宠物游戏，玩家反复登陆查看状态，不断回到游戏，商家在这种网站上投放广告，甚至植入游戏内容（植入式广告）； 8、rewards、levels、achievement，挑战与激励并存，用成就激励玩家不停地玩，利用人类天生追求奖励的本能；将这种游戏策略用到市场营销中，游戏化，如集卡，将消费本身变成游戏； 9、成年人消费会更谨慎和犹豫，信贷制改变了这一切，信用卡，即时消费主义，消费欲望被释放并且更容易接受高价，暂时忘记购物欲付款间的紧密联系，现金的拿出会让人感到痛苦；信用卡利用人们对未来的积极预期，促使成年人像小孩子一样消费，我想要并且现在就要； 10、互联网与支付软件，让购物更轻松，省去会让消费者迟疑的中间环节。","path":"2021/09/16/Z_杂七杂八/W_无节制消费的元凶/","date":"09-16","excerpt":"","tags":[{"name":"消费主义","slug":"消费主义","permalink":"https://帆帆.icu/tags/%E6%B6%88%E8%B4%B9%E4%B8%BB%E4%B9%89/"}]},{"title":"睡眠革命","text":"设定固定起床点比上班 / 学时间提前 90分钟，保证睡醒有充分时间缓冲状态，不耽误任何事情 倒推理想入眠期一、刚开始用 5 个周期倒推，之后根据起床状态不停尝试，多退少补，慢慢找到专属自己的作息表。二、注意，入睡时间不要太晚，不要熬夜！根据昼夜节律，身体在 21 点分泌褪黑素，2-3 点达到睡眠最深的状态，千万别错过这个黄金睡眠阶段 重中之重的睡前睡后程序睡前一、入睡前 90 分钟淋浴（降温）操作方法：如果 23:30 点睡觉，则在 22 点前结束沐浴，22 点 15 分钟左右上床，通过 15 分钟的睡前准备，还有 1 小时左右的睡前阅读、睡前瑜伽等不带刺激大脑的日常安排，到了快 11 点时，保证你能快速入眠，睡得香香的～二、足浴（&lt;=15min）泡脚时下载你的一天，进行复盘，把今日收获或压力，记录下来，让成果可视化；顺便制作明日计划，让第二天有方向感地度过。三、调节室内温度科学研究表示，房间温度在 20-25 度时，身体感觉最舒服，最适合入睡。四、睡前缓和运动瑜伽类的舒展运动、整理房间等。五、单调法则冥想 + 看书六、调节光线睡觉前从白灯变成暖灯，杜绝蓝光！ 让手机单独一个屋睡，手机已经到了和大人分开睡的年龄了，不要再宠幸它了，会惯坏的。 注：超过 10 点后不再吃东西；正常作息的人，睡前 90 分钟不再进食 睡后 其他问题一、睡不着时，就重复入睡程序，下床去泡脚、看书、放轻音乐，别在床上做无用功！","path":"2021/09/16/Z_杂七杂八/S_睡眠革命/","date":"09-16","excerpt":"","tags":[{"name":"睡眠","slug":"睡眠","permalink":"https://帆帆.icu/tags/%E7%9D%A1%E7%9C%A0/"}]},{"title":"句子集","text":"一1、你是我疲惫生活中唯一的英雄梦想 2、山海的浩瀚，宇宙的浪漫。都在我内心翻腾，在推着我前进。—— 陈粒《绝对占有相对自由》 3、夏天有梅子味的晚霞和两三颗啤酒味的星 4、城南花开，城北花落。城东日升，城西日落 5、来日方长何惧车遥马慢 6、所谓英雄，就是能打破逆境的人啊 7、要问世间什么最难的，明确的爱，直接的厌恶，真诚的喜欢，站在太阳的坦荡和大声无愧的称赞自己 8、如果你看向我，我会温柔的消融，像火山中的雪。—— 米亚科托《耶路撒冷》 9、想被秋天卷起，卷进温柔的风里，柔软的云里，还有橘子味的拥抱里 10、你承诺过的月亮，还是没有出现，而我无眠，或者，我只是衣单天寒地，替你多爱了一夜人间","path":"2021/09/16/X_写作/J_句子集/","date":"09-16","excerpt":"","tags":[{"name":"句","slug":"句","permalink":"https://帆帆.icu/tags/%E5%8F%A5/"}]},{"title":"世界的律动","text":"​ 夕阳渐落，西天的云被染成了鲜艳的橙，万物林立在流彩的霞光之中，像极了严正以待的士兵。一阵暖风在红日光轮下成型，吹向高耸的云白山脉。满山的黄叶微微颤动，光影交错相叠。云白山头，坐着一位十几岁的少年郎，一袭白衣在夕阳的映衬下，显露出暗金色。其手间是一本《诗歌 300 首》，少年一手撑着脑袋，张口朗朗诵读道：余忆童稚时，能张目对日，明察秋毫。见藐小微物，必细察其纹理。 读完该段后便将书丢放到一旁，径直躺下，双手顺势垫住头部，悠然地望着蔚蓝的天空，笑道：沈爷爷小的时候竟能这么有趣，张目对日，那所见一切都会溢满金色，而且一切也会充满了温暖。说到此处，像是想起了什么，猛然翻身坐起，眺望着西天那抹淡淡红晕，会心地笑了起来，太阳公公要去地球另一侧送温暖了，在此之前，西天的云是它最后的温暖对象。 那么地球另一侧的人是否知道张目对日这个秘密呢？少年遐想道，“若我长大了，一定要去地球的那一侧，告诉他们这个秘密，算了，我现在就要告知天下这个大秘密”。 在夕阳最后的余晖中，少年双手成拳，对着西天呐喊：太阳公公！多谢你给我的世界带来金色和温暖！遥远的西天传来阵阵回声，像是这个世界对少年的回应。 随着最后一个 “暖” 字结束，夕阳消失了。 星球的这一侧变成了略带温热的蓝调星球。 这是黑夜来临前的独一无二的蓝调世界，远处的世界渐渐被黑色覆盖，深蓝色慢慢变成黑色。当夜幕袭来，整个天空都会被星河取代。但在此之前，我们会短暂地停留在这个深蓝色世界里面。 “该回家了”，少年将书拿起来，目光四处环绕着这个深蓝世界，向家的方向走去，一步步带着悠闲和惬意，黑夜和冷风被他远远甩在身后，月光微微，轻轻打在他的身上。","path":"2021/09/16/X_写作/S_世界的律动/","date":"09-16","excerpt":"","tags":[{"name":"小说","slug":"小说","permalink":"https://帆帆.icu/tags/%E5%B0%8F%E8%AF%B4/"}]},{"title":"哈夫曼树","text":"介绍哈夫曼树 (Huffman Tree) 背景：著名的 哈夫曼编码 发明人 戴维・霍夫曼于 1999 年 10 月 17 日因癌症去世，享年 74 岁，他发明了著名的的 霍夫曼编码，除了霍夫曼编码以外，他还涉及出二叉最优搜索树的算法，因为其效率最高，所以被命名为霍夫曼算法，是动态规划的一个范例 通过哈夫曼树，我们往往可以得到问题的最优解所以哈夫曼树也叫做最优二叉树最优二叉树是在叶子结点和权重确定的情况下，带权路径长度（WPL）最小的二叉树 什么是带权路径长度（WPL）我们要做的就是找到 WPL 最小的二叉树 构建最优二叉树 不难发现要使得 WPL 最小，那么深度越大的叶子结点权值就越小，深度小的叶子结点权值就越大，我们从下往上，深度减小的方向构建二叉树。 具体步骤： 一、从小到大进行排序，将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 二、取出根节点权值最小的两颗二叉树 三、组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 四、再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 代码实现1 适用情况一、根节点的值等于叶子节点二、出现最小，最优的字眼时三、与求最小 WPL 等价时","path":"2021/09/16/S_算法与数据结构/S_数据结构/S_树、图/H_哈夫曼树/","date":"09-16","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://帆帆.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"https://帆帆.icu/tags/%E6%A0%91/"},{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"}]},{"title":"链表","text":"链表结点12345678typedef struct note&#123; int date; //数据区域 struct note* next; //指向结点的指针&#125;Note,*link;//typedef相当于再命名//struct note——Note//结点//struct note*——link//指向结点的指针 构建链表尾插法（尾指针移动）123456789101112131415link link_t()&#123; int i; link h, t, p;//头指针，尾指针，中间指针 h = t = (link)malloc(sizeof(Note)); //malloc第一个结点 for (i = 1; i &lt;= n; i++) &#123; p = (link)malloc(sizeof(Note)); //malloc新结点 p-&gt;date = i; //结点数据区域赋值 t-&gt;next = p; //将新结点和上一结点连接 t = p; //新结点成为尾部，t指向新结点 &#125; t-&gt;next = NULL; //最后一个结点的指针域为空 return h; //返回头指针&#125; 尾插法蕴含手动实现队列的思想尾插法就是先构建头部节点，然后构建身体结点，不断延长身体节点的过程。 头插法（头指针移动）123456789101112131415link link_h()&#123; int i; link h,p; h = (link)malloc(sizeof(Note)); //malloc第一个结点 h-&gt;next = NULL; //将第一个节点指针域初始化为空 for (i = 1; i &lt;= n; i++) &#123; p = (link)malloc(sizeof(Note)); //malloc新结点 p-&gt;date = i; //结点数据区域赋值 p-&gt;next = h-&gt;next; //使该层新节点指向上层结点 h-&gt;next = p; //h-&gt;next始终指向每一层的新结点 &#125; return h; //返回头指针&#125; 头插法只需要两个指针变量，因为不需要记录头指针，头指针本身就用来拓展链表 头插法和尾插法的对比①头插法构建的链表遍历时正序，而尾插法逆序②尾插法比头插法节约一个指针变量 单链表逆置理论根据头插法和尾插法一个正序一个逆序的特点，用头插法重构尾插法构建好的链表 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct note&#123; int date; //数据区域 struct note* next; //指向结点的指针&#125;Note,*link;int n = 10; //节点个数link link_t(); //尾插法生成一个单链表link link_h(); //头插法void print(link x); //单链表输出函数int Find(link x, int m); //根据头指针返回第m个结点的数据int main()&#123; print(link_t()); //生成一个单链表，并输出 printf(&quot;\\n&quot;); print(link_h()); //逆置单链表，并输出 getchar(); getchar(); return 0;&#125;link link_t()&#123; int i; link h, t, p; h = t = (link)malloc(sizeof(Note)); for (i = 1; i &lt;= n; i++) &#123; p = (link)malloc(sizeof(Note)); p-&gt;date = i; t-&gt;next = p; t = p; &#125; t-&gt;next = NULL; return h;&#125;link link_h()&#123; int i; link h,p; h = (link)malloc(sizeof(Note)); h-&gt;next = NULL; for (i = 1; i &lt;= n; i++) &#123; p = (link)malloc(sizeof(Note)); p-&gt;date = Find(link_t(), i); p-&gt;next = h-&gt;next; h-&gt;next = p; &#125; return h;&#125;void print(link x)&#123; link p = x-&gt;next; while (p != NULL) &#123; printf(&quot;%d &quot;, p-&gt;date); p = p-&gt;next; &#125;&#125;int Find(link x, int m)&#123; int i; link p = x-&gt;next; for (i = 1; i &lt; m; i++) p = p-&gt;next; return p-&gt;date;&#125; 要点单链表输出时若用 p-&gt;next 作为循环条件会导致遗漏最后一个结点","path":"2021/09/16/S_算法与数据结构/S_数据结构/L_链表/L_链表/","date":"09-16","excerpt":"","tags":[{"name":"链表","slug":"链表","permalink":"https://帆帆.icu/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"https://帆帆.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"冒泡排序","text":"冒泡排序冒泡排序也称为沉底排序，是一种简单易用的排序算法。 基础代码1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); int a[100]; int i, j, t; for (i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (i = 1; i &lt; n;i++)//控制巡回次数(n-1)（两个为一对） &#123; for (j = 1; j &lt; n; j++)//每次巡回都从1开始直到末尾 &#123; if (a[j] &gt; a[j+1]) &#123; t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125; &#125; for (i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); return 0;&#125; 上述代码每一次巡回都从 1 到 n-1，末尾的数会在一次又一次循环中逐渐排好，我们无需再巡回到末尾。 于是便有了下面的这段代码 更优代码1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main()&#123; int n; scanf_s(&quot;%d&quot;, &amp;n); int a[100]; int i, j, t; for (i = 1; i &lt;= n; i++) scanf_s(&quot;%d&quot;, &amp;a[i]); for(i = n-1; i &gt;= 1; i--)//控制巡回长度 &#123; for (j = 1; j &lt;= i; j++)//每次巡回都从1开始 &#123; if (a[j] &gt; a[j+1]) &#123; t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125; &#125; for (i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); return 0;&#125; 最优解1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;int main()&#123; int n; scanf_s(&quot;%d&quot;, &amp;n); int a[100]; int i, j, t; for (i = 1; i &lt;= n; i++) scanf_s(&quot;%d&quot;, &amp;a[i]); for(i = n-1; i &gt;= 1; i--)//控制巡回长度 &#123; for (j = 1; j &lt;= i; j++)//每次巡回都从1开始 &#123; if (a[j] &gt; a[j+1]) &#123; t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125; if (t == a[j - 1]) i--; //当最后一对没交换时，下一次巡回长度-1 &#125; for (i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_算法/P_排序/M_冒泡排序/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://帆帆.icu/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡","slug":"冒泡","permalink":"https://帆帆.icu/tags/%E5%86%92%E6%B3%A1/"}]},{"title":"树","text":"二叉树的存储方式数组存储完全二叉树一、由根节点从 1 开始编号（从上到下、从左到右）二、完全二叉树因为在编号时是连续的，所以可以用数组来表示一般二叉树一、将一般二叉树补全为完全二叉树，不存在的结点可以用标记数组进行标记！二、会导致空间浪费 ! 链表存储123456typedef struct note&#123; int date; struct note* lchild; struct note* rchild;&#125;Note; 构建二叉树前序构建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586```### `中序构建`### `后序构建`------## `二叉树的遍历````C#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct BTNote&#123; char date; struct BTNote* lchild; struct BTNote* rchild;&#125;Note,* link; link CreateBT()//创建树&#123; link PA = (link)malloc(sizeof(Note)); link PB = (link)malloc(sizeof(Note)); link PC = (link)malloc(sizeof(Note)); link PD = (link)malloc(sizeof(Note)); link PE = (link)malloc(sizeof(Note)); link PF = (link)malloc(sizeof(Note)); PA-&gt;date = &#x27;A&#x27;; PB-&gt;date = &#x27;B&#x27;; PC-&gt;date = &#x27;C&#x27;; PD-&gt;date = &#x27;D&#x27;; PE-&gt;date = &#x27;E&#x27;; PF-&gt;date = &#x27;F&#x27;; PA-&gt;lchild = PB; PA-&gt;rchild = PC; PB-&gt;lchild = PD; PB-&gt;rchild = NULL; PD-&gt;lchild = PD-&gt;rchild = NULL; PC-&gt;lchild = PE; PC-&gt;rchild = PF; PE-&gt;lchild = PE-&gt;rchild = NULL; PF-&gt;lchild = PF-&gt;rchild = NULL; return PA;&#125; void Pre_ergodic(link p) &#123; if (NULL != p) printf(&quot;%c &quot;, p-&gt;date); else return; Pre_ergodic(p-&gt;lchild); Pre_ergodic(p-&gt;rchild); return; &#125; void In_ergodic(link p) &#123; if (NULL != p) &#123; In_ergodic(p-&gt;lchild); printf(&quot;%c &quot;, p-&gt;date); In_ergodic(p-&gt;rchild); &#125; &#125; void Post_ergodic(link p) &#123; if (NULL != p) &#123; Post_ergodic(p-&gt;lchild); Post_ergodic(p-&gt;rchild); printf(&quot;%c &quot;, p-&gt;date); &#125; &#125;int main()&#123; link p = CreateBT(); printf(&quot;先序遍历：&quot;); Pre_ergodic(p); printf(&quot;\\n&quot;); printf(&quot;中序遍历：&quot;); In_ergodic(p); printf(&quot;\\n&quot;); printf(&quot;后序遍历：&quot;); Post_ergodic(p); printf(&quot;\\n&quot;); return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_数据结构/S_树、图/S_树/","date":"09-16","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://帆帆.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"https://帆帆.icu/tags/%E6%A0%91/"}]},{"title":"01 迷宫","text":"题目来源01 迷宫 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#define MAX 1005int m, n, ans;int map[MAX][MAX];int book[MAX][MAX];void dfs(int x, int y)&#123; book[x][y] = 1; int next[4][2] = &#123; &#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125; &#125;; for (int k = 0; k &lt;= 3; k++) &#123; int dx = x + next[k][0]; int dy = y + next[k][1]; if (((map[dx][dy] == 0 &amp;&amp; map[x][y] == 1) || (map[dx][dy] == 1 &amp;&amp; map[x][y] == 0)) &amp;&amp; dx &gt;= 1 &amp;&amp; dx &lt;= n &amp;&amp; dy &gt;= 1 &amp;&amp; dy &lt;= n &amp;&amp; book[dx][dy] == 0) &#123; ans++; dfs(dx, dy); &#125; &#125; return;&#125;void clear()&#123; ans = 1; int i, j; for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) book[i][j] = 0;&#125;int main()&#123; int x, y; int i, j; char ch[MAX]; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) scanf(&quot;%1d&quot;, &amp;map[i][j]); for (i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); clear(); dfs(x, y); printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; 以上代码虽然是正确的，但是因为效率过低，在洛谷平台的样例测试中会出现时间超限的情况如下图： 剪枝优化1//未更 END","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/01 迷宫/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"}]},{"title":"AT46 リモコン","text":"题目来源AT46 リモコン 代码详解1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;int min(int a, int b);int A, B, step, m = 999999999;void dfs(int x, int y,int step)&#123; if (step &gt; m) return; if (x == y) &#123; m = min(step, m); return; &#125; if (x &gt; y)//大于就往下搜 &#123; dfs(x - 1, y,step+1); dfs(x - 5, y,step+1); dfs(x - 10, y,step+1); &#125; if (x &lt; y)//小于就往上搜 &#123; dfs(x + 1, y, step + 1); dfs(x + 5, y, step + 1); dfs(x + 10, y, step + 1); &#125; return;&#125;int main()&#123; scanf(&quot;%d %d&quot;, &amp;A, &amp;B); dfs(A, B,0); printf(&quot;%d\\n&quot;, m); return 0;&#125;int min(int a, int b)&#123; return a &gt; b ? b : a;&#125; 关键点剪枝必须剪枝，大于最小次数就退出，不然会递归不会结束，因为不看最小次数则有无数种可能也就是下面这段代码 12if (step &gt; m) return; 回车符AT 开头的日本题目输出时必须要回车，否则必错！！！","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/AT46 リモコン/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"}]},{"title":"八皇后 Checker Challenge","text":"","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/B_八皇后 Checker Challenge/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"}]},{"title":"DFS算法的本质","text":"DFS算法的本质引言DFS 俗称深搜，是一种常见的算法模型 我们通过借助函数递归和递归停止条件的运用实现对数据的高级枚举 对于 DFS 算法而言，最重要的是如何去枚举数据，即如何去搜索？ 这是在运用 DFS 之前我们就应该思考的问题，只有对其思考清楚，才不妨碍我们下一步去运用代码实现 DFS！ OK! 让我们开始吧！ 何为搜索？让我们先忘记你学过 DFS 算法这件事，抛开脑子中具体的 代码结构，单纯地以一个自然人地角度去思考，什么是搜索？ 单独思考一个词汇可能我们不会获得很多，下面我们借助具体例子来说明： 假如我说 —— 我们去搜索一间房子，你会想到什么？ 寻找？探索？还是在房子里面转悠？ 可能这么说会引起歧义，这里我们再具体一点 换成 —— 我们去搜索这间房子，看看有没有宝藏藏在里面！ 上面两句话地区别在于，一个无目的，一个有目的 一个只是再房间里面转悠，一个在转悠地同时还要看看房间里面有没有宝藏 其实上面这两句话对应了 DFS 算法的两种基本类型 无目的的深度搜索 —— 裸的 DFS有目的的深度搜索 —— 一般的 DFS (1) 无目的 DFS 就像你去亲戚家做客，主人带你在他家闲逛了解他家的布局 (2) 有目的 DFS 就像土匪掠夺财产时在你家到处探寻，直到找到你的私人小金库！ 但作为 算法 而言我们不能到处瞎转悠，有经验的主人和土匪往往也不会那么做！ 我们需要一种高效的搜索方案，它能让我们在最短时间内完成搜索任务！ 如何搜索？DFS 的关键要领在于 —— 当下这一步干什么，然后下一步干什么。 这是所有 DFS 搜索🔍算法的核心，我们只要知道当下和下一步的动作，就能通过递归连贯出整个搜索动作。 让我们来举个例子题目：DFS - 选数题目大意：求从 N 个数里面选出 K 个数出来并且使选出的数的和为素数的的可能性有几种？ 假如：N=5，K=3 5 个数为：1 2 3 4 5 我们要做的是挑出 3 个数出来然后计算求和并判断和是否为素数。 你可能已经想到怎么去选了，一般的选法如下： 1 2 31 2 41 2 51 3 41 3 51 4 52 3 4略 我们要做的就是每一次选出一个数，首先仔细观察上述选数过程当我们去选 1 2 3 时我们发现这是依次递增的，我们不免想到用 For循环去实现这个选数过程，For 循环每进行一次就选入一个数可能你会这么写： 12345678dfs(int i,int k,int n)//选入的数为i，选了k个数，要选n个数&#123; if(k==n) //略 for(int i=1;i&lt;=n;i++) dfs(i+1,k+1，n) //略&#125; 但问题来了我们在 1 2 3 选完之后是如何蹦到 1 2 4 呢？ 难不成我们需要再从头选一遍，标记3 已经被选过了，直接越过它去选 4 仔细思考你会发现这是一个无比繁琐的工作，你需要灵活的标记策略来应对不同的选数情况 我们想要的是不再从头去选，而是在选完 1 2 的基础上再去直接选 4 所以我们需要一种方法来保留选完 1 2 时的状态 可能 DFS 算法尚在研究时人们就发现了，他们需要保留一些状态，再去确定下一步的状态 巧妙的是函数递归在设计时就拥有保留中断线程的能力，在选数时我们可以完全用函数递归来写 这样写的好处在于，每一层函数选择一个数，选着完后就像线路一样被保存下来 最简单的我们选完 1，1的状态就被保存下来了，我们要在 1后面选数时，只需要 return 返回到选完 1 时的状态即可，这样我们可以顺利地选出 1 21 31 4 当前两个数选完后，也就保存了选完两个数的状态 其实我们可以用结点去理解这个过程 最开始我们选择了 1 这个结点，然后我们就可以连接 2/3/4 这三个结点 假如我们连接了 1和2结点就形成了 1-2 的线路，当我么们再往下 DFS 选数时，1-2 这条线路会被保存下来，通过选数和不断 return 返回到 1-2 这条线路的末尾，我们选出了： 1 2 31 2 41 2 5 核心代码如下： 12345678910111213141516//从x单元开始的选数（每往下递一层，For循环中i开始的位置需要改变）//已选m个数//m个数的和为sum//需要得到k个数,一共n个数void dfs(int x,int m,int sum,int k,int n)&#123; if (m == k) &#123; if (isPrime(sum)) ans++; return; &#125; for (int i = x; i &lt; n; i++) dfs(i+1,m + 1, sum + *(p + i), k, n);//i+1而非x+1（因为是靠i来选数） return;&#125; 部分过程如下：1 // 选 1 结点1-2 // 保留 1 结点选 2 结点1-2-3 // 保留 1-2 线路选 3 结点1-2 // 返回到 1-2 线路的末尾1-2-4 // 在已保留 1-2 线路后选 4 结点1-2 // 返回到 1-2 线路的末尾1-2-5 // 以此类推！！！1-211-31-3-41-31-3-51-31 这也是为什么你所见到的 DFS算法都拥有递归调用的原因 DFS 算法本就是依托于函数递归而设计的一种高级枚举算法 至于为什么叫做深度搜索，相信在刚刚梳理的过程中你也可以感受出来，函数一层一层往下递，层层递进，不断深入去探索，直到碰到终止条件 当下这一步干什么，然后下一步干什么，这两步其实干的是同一类型的事情，在选数 这个例子中就是选数二字，DFS 函数的功能就是选数，每一次参数的传入就是一次选数的过程！ 构建DFS的框架我们在上述讲到了 DFS 算法的内部过程，这可以让我们更好的去理解 DFS 算法是如何执行的，但是在写题时，光有这些是远远不够的，我们还需要一些宏观的框架思维，这可以帮助我们在面对新的问题时，更快速地想出解决办法。 我们从以下三个方面去思考一道 DFS 题目 递归の最大深度定义：DFS 函数递归套娃时达到最底部（最深处）的过程中所经历的套娃次数结论：递归の最大深度取决于输入的数据的大小和规模 例子01. 选数：递归的最大深度其实就是输入的 k02. 全排列：递归的最大深度其实就是输入的 n+1 的大小，函数一层一层往下递直到 step=n+103. 单词接龙：递归的最大深度不定，取决于数据规模，即：有多少个单词04. 迷宫问题：递归的最大深度不定，取决于数据规模，即：地图的大小和特征05. 八皇后问题：递归的最大深度就是输入的 n，即：图的边长不胜枚举！！！ 对于裸的DFS，我们要遍历所有可能性，递归的最大深度不定对于非裸的DFS，我们要加上 DFS 的 if条件，适时进行归的操作 该层函数与返回到该层函数该层函数：递之前完成的动作返回到该层函数：归之后需要完成的动作 代码示例12345678910111213141516171819void dfs(int step)&#123; if (step == n + 1)//最大深度为n &#123; 略 return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if(book[i]==0) &#123; book[i]=1; p[step]= i;//往结点上放数 dfs(step + 1); book[i]=0; &#125; &#125; return;&#125; 一、递之前完成的动作有 2个1、For 循环选数、标记数并放数 12345678for (int i = 1; i &lt;= n; i++)//选出一个数&#123; if(book[i]==0) &#123; book[i]=1;//标记数 p[step]= i;//往结点上放数 &#125;&#125; 2、将 step+1 并传入下一层函数中 (Very Important) 1dfs(step+1); 二、归之后需要完成的动作也有 2个1、取消标记 1book[i]=0;//取消标记 2、若 for 循环没完则继续选数、标记数并放数 , 完了则跳出For循环 总结: 我们可发现这两个过程是可以首尾部巧妙连接的，也正由此连贯出整个递归过程 通过框架，确认DFS函数的参数！例题：数的分割 题目大意：把正整数 n 分解为 k 个正整数，排在后面的数必须大于或等于前面的数，输出所有方案。 1、确认递归深度 分出 k 个数即可，递归深度为 k（可以用 cnt 来计数） 123456if (cnt == k) &#123; if (n == sum) ans++; return; &#125; 2、该层函数 功能：分割出一个数且确保当下分割的数比之前的大（所以要保留分割出来的数进行比较) 123for (int i=cut; i &lt;= n-sum; i++) dfs(cnt + 1, i, sum + i);//cut为上次分割的数，从cut开始保证大于等于这个条件 3、返回到该层函数 功能：无 完整代码如下： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int n, k, ans;void dfs(int cnt,int cut,int sum)&#123; if (cnt == k) &#123; if (n == sum) ans++; return; &#125; if (cut == 0)//第一次分割数最小为1 cut++; for (int i=cut; i &lt;= n-sum; i++)//n-sum用来减少次数，剪枝优化 dfs(cnt + 1, i, sum + i); return;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); dfs(0,0,0); printf(&quot;%d&quot;, ans); return 0;&#125; END","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/DFS算法的本质/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"}]},{"title":"Healthy Holsteins","text":"题目来源Healthy Holsteins 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;stdio.h&gt;#define MAX 30int n;int p, step;int v[MAX], sum[MAX];int s[MAX][MAX], book[MAX], FangAn[999999][MAX];void record()&#123; step++; for (int i = 1; i &lt;= p+1; i++) &#123; if (book[i] == 1) &#123; FangAn[step][i] = 1; FangAn[step][p + 1]+=i; FangAn[step][p + 2]++; &#125; &#125;&#125;void solve()&#123; int min = 9999999, f; for (int i = 1; i &lt;= step; i++) &#123; if (min &gt; FangAn[i][p + 2]) &#123; min = FangAn[i][p + 2]; f = i; &#125; &#125; printf(&quot;%d &quot;, FangAn[f][p + 2]); for (int j = 1; j &lt;= p; j++) &#123; if (FangAn[f][j] == 1) printf(&quot;%d &quot;, j); &#125;&#125;void dfs(int i)&#123; if (i == p+1) &#123; int flag = 1; for (int j = 1; j &lt;= n; j++) &#123; if (sum[j] &lt; v[j]) flag = 0; &#125; if (flag == 1) record(); return; &#125; //选 book[i]=1; for (int j = 1; j &lt;= n; j++) sum[j] += s[i][j]; dfs(i + 1); book[i] = 0; //不选 for (int j = 1; j &lt;= n; j++) sum[j] -= s[i][j]; dfs(i + 1); return;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;v[i]); scanf(&quot;%d&quot;, &amp;p); for (int i = 1; i &lt;= p; i++) &#123; for (int j = 1; j &lt;= n; j++) scanf(&quot;%d&quot;, &amp;s[i][j]); &#125; dfs(1); solve(); return 0;&#125; 关键点我们从第一种饲料开始往下选，直到i=p+1123456789101112if (i == p+1) &#123; int flag = 1; for (int j = 1; j &lt;= n; j++) &#123; if (sum[j] &lt; v[j]) flag = 0; &#125; if (flag == 1) record(); return; &#125; 每种饲料有两种状态、即选或者不选1234567891011//选book[i]=1;for (int j = 1; j &lt;= n; j++) sum[j] += s[i][j];dfs(i + 1);C//不选book[i] = 0;for (int j = 1; j &lt;= n; j++) sum[j] -= s[i][j];dfs(i + 1);","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/Healthy Holsteins/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"}]},{"title":"单词接龙","text":"题目描述单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的 “龙”（每个单词都最多在 “龙” 中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish，如果接成一条龙则变为 beastonish，另外相邻的两部分不能存在包含关系，例如 at 和 atide 间不能相连。 输入输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词，输入的最后一行为一个单个字符，表示 “龙” 开头的字母。你可以假定以此字母开头的 “龙” 一定存在。 输出只需输出以此字母开头的最长的 “龙” 的长度，输出占一行。 样例输入5AtTouchCheatChooseTactA 样例输出23 提示条件：n≤20样例解释：连成的 “龙” 为 atoucheatactactouchoose。 题目来源[P1019 NOIP2000 提高组] 单词接龙 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int n, ans, vis[22];string a[22];//第一个参数是上一个字符串//第二个参数是拼接后的长度 void dfs(string x, int s)&#123; //求最长长度 ans = max(ans, s); //枚举每一个字符串 for (int i = 1; i &lt;= n; i++) &#123; int p = 1;//重叠部分长度 int la = x.length(); int lb = a[i].length(); while (p &lt; min(la, lb)) &#123; if (x.substr(la - p) == a[i].substr(0, p) &amp;&amp; vis[i] &lt; 2) &#123; vis[i]++; dfs(a[i], s + lb - p); vis[i]--; break; &#125; p++; &#125; &#125; return;&#125;int main()&#123; //读入 cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; char t; cin &gt;&gt; t; //枚举找到首字母为t的字符串 for (int i = 1; i &lt;= n; i++) &#123; if (a[i][0] == t) &#123; vis[i]++;//vis数组解决搜两次的问题 dfs(a[i], a[i].length()); vis[i]--; &#125; &#125; cout &lt;&lt; ans; return 0;&#125; 思路详解（1）这是什么类型的题？ 1）因为要判断 String 能否连接所以必然为一道字符串题 2）我们要将字符串连接起来，其中最小的子问题是两个字符串的连接问题，即最开始的情况下若有 n 个字符串，我们连接其中两个字符串，在确认第一个单词之后，剩下的一个单词的选择有 n 或 n-1 种情况（每个单词只能用两次）然后继续往下连接时还可能有 n 或 n-1 种情况，每一层连接都需要 for 循环所有的字符串，而且是不断往下进行的，所以也是一道深度搜索问题 DFS问题 （2）代码实现第一步：读入 123456cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; char t; cin &gt;&gt; t; 第二步：找到第一个单词开始DFS 12345678for (int i = 1; i &lt;= n; i++) &#123; if (a[i][0] == t) &#123; vis[i]++;//vis数组解决搜两次的问题 //第一个字母使用过一次 dfs(a[i], a[i].length()); vis[i]--; &#125; &#125; 问题一：为何只传入字符串和其长度可以？答：因为如果我们知道两个字符串可以拼接，且知道重合部分的大小，我们就知道拼接后的长度，然后我们拿当前搜索的字符串（末尾的字符串）继续和下一个字符串去判断能否合并即可，也就是意味着我们并不需要把他们连起来就可以知道最终长度是多少 问题二：为何要 vis [i]–;因为起始位点可能有多个，当我们从一个可行的起始位点往下搜索完毕后，还要可能存在另外一个可行的起始位点，当用另外一个位点时，之前的位点作为起始位点的 1 次 使用次数要消掉 第三步：DFS部分 1234567891011121314151617181920void dfs(string x, int s)&#123; //求最长长度 ans = max(ans, s); //枚举每一个字符串 for (int i = 1; i &lt;= n; i++) &#123; int p = 1;//重叠部分长度 int la = x.length(); int lb = a[i].length(); while (p &lt; min(la, lb)) &#123; if (x.substr(la - p) == a[i].substr(0, p) &amp;&amp; vis[i] &lt; 2) &#123; vis[i]++; dfs(a[i], s + lb - p); vis[i]--; &#125; p++; &#125; &#125;&#125;ans = max(ans, s); 在搜索🔍过程中 s 是不断变化的，我们用取大函数将 s 的最大值赋给一个全局变量 ans，ans 也是本题的最终答案 1int p = 1;//重叠部分长度 我们想让字符串最长，所以最理想的情况下是重叠部分长度为 1，且每次字符串连接的尝试都要使 p 为 1 所以 p 定义在 for 循环内 1while (p &lt; min(la, lb)) 确保两个字符串没有包含关系 1234567if (x.substr(la - p) == a[i].substr(0, p) &amp;&amp; vis[i] &lt; 2) &#123; vis[i]++; dfs(a[i], s + lb - p); vis[i]--; break; &#125; p++; 判断若重合长度为 p 时是否可以连接若能连接则马上连接（确保 p 最小）然后更新使用次数再去连接下一个 用当前被连接的字符串 作为下一步要连接字符串的新的起始位点 并且更新长度 所以 dfs(a[i], s + lb - p);若不能连接则加大 p 的长度再次判断，直到跳出 while 循环 关于该DFS的回溯详解（important）若没有return编译器自动补全当我们拼完了若干个字符串后不能够再继续拼接时while 循环跳出，for 循环跳出，跑到了 return 的部分return 回到上一层函数的内部的 dfs 函数结尾紧接着执行 vis [i]–; 收回末端拼接的字符串然后跳出 while 不再 p++（若不加 break，会又进行一次连接（eg：pcc 和 ccq），虽然也可以连接但是并不是最长的，最终会被舍去，所以不如提前规避掉，提高程序运行效率）然后继续 for 循环看看能不能放入一个新的字符串到已经拼接过的字符串中去，若可以则生成新的字符串，若不行则结束 for 循环 return 到再上一层函数中去，然后重复相同的过程 其实和全排列问题差不多，一个是放数字，一个是放字符串只是再放字符串的同时判断了前后两个字符串的连接性,都遍历了所有可能性，函数递归的步骤完全相同 问题：为什么没有 if 递归终止条件？ 因为往下递到头后for循环结束后会遇到return进行归的过程 全排列问题里为了输出所以放置了 if 递归终止条件，然后再在if内return，但是该题不能用if，直接fou循环后加return即可，因为if的条件语句，我们无法找到 我们是遍历所有的可能性（if没必要） 不像全排列一样，在搜索到最底部时需要输出 问题： if 递归终止条件的作用 void的dfs函数无论有没有if,dfs函数终会回溯（void本不需要return） if 只是为了达到题目要求的功能而已 eg:输出数组","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/D_单词接龙/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"}]},{"title":"迷宫最短路径问题","text":"迷宫最短路径问题完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;struct note&#123; int x;//横坐标 int y;//纵坐标 int s;//步数&#125;;int main()&#123; struct note que[2501]; int a[51][51] = &#123; 0 &#125;, book[51][51] = &#123; 0 &#125;; int next[4][2] = &#123; &#123;0,1&#125; ,&#123;1,0&#125; ,&#123;0,-1&#125;, &#123;-1,0&#125; &#125;; int head, tail;//引入队列 int i, j, k, m, n, startx, starty, p, q, tx, ty, flag; //读入目标迷宫大小 scanf(&quot;%d %d&quot;, &amp;n, &amp;m); //读入迷宫 for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;a[i][j]); //读入起点和终点 scanf(&quot;%d %d %d %d&quot;, &amp;startx, &amp;starty, &amp;p, &amp;q); //队列初始化 head = 0; tail = 1; //起点入队 que[1].x = startx; que[1].y = starty; que[1].s = 0; //标记起点 book[startx][starty] = 1; flag = 0;//标识符 while (head &lt; tail) &#123; head++; for (k = 0; k &lt;= 3; k++) &#123; //父单元按规律向4个方向拓展 tx = que[head].x + next[k][0]; ty = que[head].y + next[k][1]; if (tx&lt;1 || tx&gt;n || ty&lt;1 || ty&gt;m) continue;//越界则重新试探 if (a[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0) &#123; //拓展成功则标记拓展的点并将其入队，累加步数。 tail++; book[tx][ty] = 1; que[tail].x = tx; que[tail].y = ty; que[tail].s = que[head].s + 1; &#125; //拓展到目标点时结束拓展调用标识符结束拓展 if (tx == p &amp;&amp; ty == q) &#123; flag = 1; break; &#125; &#125; //若成功标记则结束while循环 if (flag == 1) break; &#125; printf(&quot;%d&quot;, que[tail].s); getchar(); getchar(); return 0;&#125; 思路详解1第一步：定义note结构体 我们要记录最路径，路径大小和经过的点数有关顾名思义我们需要在点上做文章一个点拥有（x，y）坐标我们定义一个含距离的关于点的结构体如下： 123456struct note&#123; int x;//横坐标 int y;//纵坐标 int s;//步数&#125;; 点的个数和迷宫大小有关这里我们取最大值如下： 1struct note que[2501]; 1第二步：引入队列的思维 BFS 搜索🔍是由父层向下遍历探索所有可能的子结构探索成功后之前的子层成为了新的父层继续上述操作不由可以联想到父到子 &gt;&gt; head 向下试探，成功则 tail++子成父 &gt;&gt; head++如下： 123456789101112131415161718192021222324252627282930while (head &lt; tail) &#123; head++；//将1单元成为父单元 for (k = 0; k &lt;= 3; k++) &#123; //父单元按规律向4个方向拓展 tx = que[head].x + next[k][0]; ty = que[head].y + next[k][1]; if (tx&lt;1 || tx&gt;n || ty&lt;1 || ty&gt;m) continue;//越界则重新试探 if (a[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0) &#123; //拓展成功则标记拓展的点并将其入队，累加步数。 tail++;//扩充队列,将新的点入队 book[tx][ty] = 1; que[tail].x = tx; que[tail].y = ty; que[tail].s = que[head].s + 1; &#125; //拓展到目标点时结束拓展调用标识符结束拓展 if (tx == p &amp;&amp; ty == q) &#123; flag = 1; break; &#125; &#125; //若成功标记则结束while循环 if (flag == 1) break; &#125; 1第三步：最小路径 问题 1：为什么拓展到终点时必为最短路径？解答：因为每一层拓展均为步数加 1，所以拓展的过程中步数是一样累加的并没有多走的情况，同步出发，并且只要到终点后 while 循环便会停止，所得 &gt; 一定为最短路径 问题 2：输出最短路径时为什么要用 que[tail].s ?解答：我们刚开始定义 tail 为 1，tail 表示队尾位置，成功拓展至终点后 ， 终点即为队尾位置即 que [tail].s; summary：（1）本题和 BFS - 马的遍历异同之处？ 本题：将距离 s 定义在结构体之内，使得每一个节点均含有到此的最小步数other：马的遍历是将距离放在一个二维数组里面，二维数组的下标为位置坐标，我们需要关注的是起点位置为队列的首位，符合以下对应关系：坐标：(sx,sy)&gt;&gt;(qun [1].x,qun [1].y) 即队列第一单元步数：a [sx][sy]=0&gt;&gt;a [qun [1].x][qun [1].y]=0 即队列第一单元对应 0 步","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/M_迷宫最短路径问题/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"BFS","slug":"BFS","permalink":"https://帆帆.icu/tags/BFS/"}]},{"title":"马的遍历","text":"马的遍历题目描述有一个 n*m 的棋盘 (1&lt;n,m&lt;=400)，在某个点上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步 输入格式一行四个数据，棋盘的大小和马的坐标 输出格式一个 n*m 的矩阵，代表马到达某个点最少要走几步（左对齐，宽 5 格，不能到达则输出 - 1） 输入样例3 3 1 1 输出样例0 3 23 -1 12 1 4 题目来源P1443 马的遍历 完整代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#define MAX 170000struct queue&#123; int x;//行坐标 int y;//列坐标&#125;;struct queue que[MAX];//最多160000个点这里令MAX=170000int head = 0, tail = 1;//队列引入int a[401][401];int n, m, sx, sy;//定义8组方向，这里的t是try的缩写，表示去试探的方向int tx[16] = &#123; 2,-2,2,-2,-1,1,-1,1 &#125;;int ty[16] = &#123; 1,1,-1,-1,2,2,-2,-2 &#125;;void init()&#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = -1; a[sx][sy] = 0;&#125;int main()&#123; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;sx, &amp;sy); init();//初始化 //队列初始化 que[1].x = sx; que[1].y = sy; while (head &lt; tail) &#123; head++; for (int i = 0; i&lt;8; i++) &#123; int nx = que[head].x + tx[i]; int ny = que[head].y + ty[i]; if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; a[nx][ny] == -1) &#123; tail++; que[tail].x = nx; que[tail].y = ny; a[nx][ny] = a[que[head].x][que[head].y] + 1; &#125; &#125; &#125; //输出 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) printf(&quot;%-5d&quot;, a[i][j]); printf(&quot;\\n&quot;); &#125; return 0;&#125; 思路详解这是什么类型的题？ 我们要得到的是马到达每一个点的最小步数，而 BFS恰好是按照最小步数一层层往下拓展的在其拓展的同时我们可以自然地得到到达每一个点的最小步数，所以我们可以用 BFS 来解决这道题 代码实现第一步：读入并初始化 12scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;sx, &amp;sy);//start-x,start-y起点的行坐标和列坐标init();//初始化 initialize - 初始化函数如下： 1234567void init()&#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = -1; a[sx][sy] = 0;&#125; 问题：为什么要先全令成 - 1 而不是 0？答：因为为 0 时表示起点到起点需要 0 步，而不能到达的点需要用 -1 来表示我们在-1的蓝图上再进行a[sx][sy] = 0 和 BFS 拓展操作 这样再输出时没有被再次赋值的点就是不能到达的点,既符合题目要求，又方便 第二步：引入队列 1int head = 0, tail = 1;//队列引入 123//队列初始化que[1].x = sx;que[1].y = sy; 第三步：BFS的拓展部分（核心代码） 1while (head &lt; tail) 头和尾之间差的是一层的拓展，一个 head 可以拓展出多个 tail。只有不能再拓展了（tail不再++），head 到达 tail 的位置时结束循环 1head++; 头指针 head 去赶尾指针 tail 向前走（往下拓展） 123456789101112for (int i = 0; i&lt;8; i++) &#123; int nx = que[head].x + tx[i]; int ny = que[head].y + ty[i]; if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; a[nx][ny] == -1) &#123; tail++; que[tail].x = nx; que[tail].y = ny; a[nx][ny] = a[que[head].x][que[head].y] + 1; &#125; &#125; 向八个方向试探，当不越界且未走过时（保证距离最短避免重复走）向下拓展tail++ 拓宽队列，将新的点入队，记录步数。 问题：为什么是 a[nx][ny] = a[que[head].x][que[head].y] + 1;？答：因为 BFS 每一次向下试探拓展，其跨度的大小均为 1（步数）每一次拓展成功意味着 head 位置的点向 tail 位置的点跨出一步我们只需要将原来走的步数即（a [que [head].x][que [head].y]）加1即可第一次进入 while 循环时，我们先 head++，此时 head 为 1，头指针指向起始位置 head位置的点是起始点，起始点的步数为 0 已经初始化过了其向下走一步恰好为0+1=1， 第四步：输出 123456for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) printf(&quot;%-5d&quot;, a[i][j]); printf(&quot;\\n&quot;); &#125; 相似题目BFS - 迷宫最短路径问题 summary 其实本题也蕴含 DP 问题的思想我们用刚开始走 1 步的点的步数去更新 2 步的点的步数用前面的数据去更新后面的数据，本身步数的累加便是一个 + 1+1 的更新过程，也蕴含累加的思想 end","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/M_马的遍历/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"BFS","slug":"BFS","permalink":"https://帆帆.icu/tags/BFS/"}]},{"title":"选数","text":"题目：选数 问题来源：[P1036 NOIP2002 普及组] 选数 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int* p, ans = 0;int isPrime(int m)&#123; int isPrime = 1; int k = sqrt(m); for (int i = 2; i &lt;= k; i++) &#123; if (m % i == 0) &#123; isPrime = 0; break; &#125; &#125; if (isPrime == 0) return 0; else return 1;&#125;//从x单元开始的选数//已选m个数//m个数的和为sum//需要得到k个数,一共n个数void dfs(int x,int m,int sum,int k,int n)&#123; if (m == k) &#123; if (isPrime(sum)) ans++; return; &#125; for (int i = x; i &lt; n; i++) dfs(i+1,m + 1, sum + *(p + i), k, n);//i+1而非x+1 return;&#125;int main()&#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n,&amp;k); p = (int*)malloc(sizeof(int) * n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, p + i); dfs(0,0,0,k,n); printf(&quot;%d&quot;,ans);&#125; 代码解析：用 DFS 进行高级的枚举操作时，显然当枚举了 K 个数时，我们需要判断 K 个数的和是否为素数，其代码如下: 123456if (m == k) &#123; if (isPrime(sum)) ans++; return; &#125; 枚举时我们用一个 for 循环来选选取当下 DFS 函数需要选入的数代码如下： 12for (int i = x; i &lt; n; i++) dfs(i+1,m + 1, sum + *(p + i), k, n);//i+1而非x+1 问：为何需要一个选数的起始位点这个参数，即 x？ 答：每一层 DFS 函数选取一个数，选取哪一个数是由 for 循环里面的 i 决定的假如是 5 个数里面选 3 个数，我们希望的是选第一个数然后再选两个，完成之后，判断其和是否为素数，再把最后一个数换成其下一位的数。eg： 1 2 3 4 5第一次选：1 2 3然后：1 2 4再然后：1 2 5我们选数的基准点是第一个数，每次扩选实际上都是选的 i+1 的那个数，起始位点不变，一直变的是相对位点，所以是 i+1 这个相对位点，而非 x+1，如下： 12for (int i = x; i &lt; n; i++) dfs(i+1,m + 1, sum + *(p + i), k, n);//i+1而非x+1 END","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/X_选数/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"}]},{"title":"全排列","text":"全排列问题完整代码： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int n;int a[100], book[100];void dfs(int step) &#123; if (step == n + 1) &#123; for (int i = 1; i &lt;= n; i++) printf(&quot;%d&quot;, a[i]); printf(&quot;\\n&quot;); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (book[i] == 0) &#123; a[step] = i; book[i] = 1; dfs(step + 1); book[i] = 0; &#125; &#125; return;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); dfs(1); return 0;&#125; 核心代码（DFS 部分）： 1234567891011121314151617void dfs(int step)&#123; if(step==n+1)&#123; for(int i=1;i&lt;=n;i++) printf(&quot;%d&quot;,a[i]); printf(&quot;\\n&quot;); return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(book[i]==0)&#123; a[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125; return; &#125; 让我们来深究 DFS 内的具体过程 函数层数和每层函数保留的 i 相等 每一层函数往数组中放入的数即为 i i 的大小也决定了是否能够继续for循环继续放数 return 的过程中必然将上层函数中放入的数收回","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/Q_全排列/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"}]},{"title":"并查集","text":"并查集基础写法策略：一个联通分度内全部节点的值统一、方法：结点序号 —— 数组下标，结点的母结点 —— 数组值 inti函数刚开始时，所有节点彼此独立的 12345 void init()&#123; for (int i = 1; i &lt;= n; i++) id[i] = i;&#125; Find函数 1234bool Find(int x, int y)&#123; return id[x] == id[y];&#125; Union函数 12345678910void Union(int p, int q)&#123; int pid = id[p]; int qid = id[q]; for (int i = 1; i &lt; MAX; i++) &#123; if (id[i] == pid)//p所在连通分度内所有节点全部连接到q结点所在联通分度 id[i] = qid; &#125;&#125; 可以发现的是，该写法最终使每一个联通分量的每一个结点的值统一，每一个联通分度拥有唯一的值，若对于一个很大的联通分量连接到一个小的连通分量上时，要改变该连通分量上有节点的值，是十分耗费时间的！以下是优化写法 优化写法（1）策略：使用算法中的懒策略 , 我们尽量避免计算，直到不得不进行计算方法：数组的每一项只包含它的父节点的下标值，两个结点 Union 时我们连接他们的根结点即可 inti函数刚开始时，所有节点彼此独立的 12345 void init()&#123; for (int i = 1; i &lt;= n; i++) id[i] = i;&#125; 寻找根节点root函数 123456int root(int i)&#123; while (i != id[i]) i = id[i]; return i;&#125; Find函数 1234bool Find(int x, int y)&#123; return root[x]==root[y];&#125; Union函数 123456void Union(int p, int q)&#123; int rp = root(p); int rq = root(q); id[rp]=rq;//连接根结点即可&#125; 总结：虽然没有了 For 循环会比基础写法要快一点，但是在某些情况下还是非常慢，例如若我们在 Find 时要回溯一颗非常瘦长的数，我们也需要耗费大量时间 以下是更优写法 优化写法（2）策略：在写法（1）的基础上，我们在 Union 时考虑带权算法方法：在 Union 时我们将权重小的作为子叶连接到权重大的上面 inti函数刚开始时，所有节点彼此独立的 12345678 void init()&#123; for (int i = 1; i &lt;= n; i++) &#123; id[i] = i; size[i]=1;//size[]数组全部初始化为1 &#125;&#125; 寻找根节点root函数 123456int root(int i)&#123; while (i != id[i]) i = id[i]; return i;&#125; Find函数 1234bool Find(int x, int y)&#123; return root[x]==root[y];&#125; Union函数 12345678910111213141516void Union(int p, int q)&#123; int rp = root(p); int rq = root(q); if(rp==rq)return;//本连接就直接退出 if (size[rp] &lt; size(rq)) &#123; size[rq] += size[rp];//权更新 id[rp] = rq;//小的连大的 &#125; else &#123; size[rp] += size[rq]; id[rq] = rp; &#125;&#125; 总结：上述算法已经十分高效了，接下来我们考虑一种更厉害的优化方案 优化写法（3）策略：路径压缩方案：将一颗树压平，除了 root 结点外的其它结点全部连接到 root 节点上 inti函数刚开始时，所有节点彼此独立的 12345678 void init()&#123; for (int i = 1; i &lt;= n; i++) &#123; id[i] = i; size[i]=1;//size[]数组全部初始化为1 &#125;&#125; 寻找根节点root函数 123456789int root(int i)&#123; while (i != id[i]) &#123; id[i]=id[id[id]];//压缩路径 i = id[i]; &#125; return i;&#125; Find函数 1234bool Find(int x, int y)&#123; return root[x]==root[y];&#125; Union函数 12345678910111213141516void Union(int p, int q)&#123; int rp = root(p); int rq = root(q); if(rp==rq)return;//本连接就直接退出 if (size[rp] &lt; size(rq)) &#123; size[rq] += size[rp];//权更新 id[rp] = rq;//小的连大的 &#125; else &#123; size[rp] += size[rq]; id[rq] = rp; &#125;&#125; 实际运用——渗滤题目对一个渗滤图判断是否能进行渗滤 —— 从上到下是否连通 例图由右图可知，显然上下并不连通！！！ 代码实现(VS2019)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n;int* id, * open;void Egscanf()&#123; printf(&quot;样例:\\n&quot;); printf(&quot;5\\n&quot;); printf(&quot;11010\\n&quot;); printf(&quot;00010\\n&quot;); printf(&quot;01011\\n&quot;); printf(&quot;10100\\n&quot;); printf(&quot;11011\\n&quot;); printf(&quot;******\\n&quot;); printf(&quot;1为open、0为close\\n&quot;);&#125;void init()//结点初始化&#123; for (int i = 1; i &lt;= n * n; i++) &#123; *(id + i) = i; *(open + i) = 0; &#125;&#125;int root(int x)&#123; while (x != id[x]) &#123; id[x] = id[id[x]];//压缩树 x = id[x]; &#125; return x;&#125;bool Find(int x, int y)&#123; return root(x) == root(y);&#125;void Union(int x)&#123; int sx = x - n; int xx = x + n; int zx = x - 1; int yx = x + 1; if (x&gt;n&amp;&amp; *(open + sx) == 1) &#123; int rx = root(x); int rsx = root(sx); if(!Find(x,sx)) id[rx] = sx;//连接根节点即可 &#125; if (x&lt;=(n*n-n)&amp;&amp; *(open + xx) == 1) &#123; int rx = root(x); int rxx = root(xx); if (!Find(x, xx)) id[rx] = xx;//连接根节点即可 &#125; if (((x-1)%n!=0)&amp;&amp; *(open + zx) == 1) &#123; int rx = root(x); int rzx = root(zx); if (!Find(x, zx)) id[rx] = zx;//连接根节点即可 &#125; if ((x%n!=0)&amp;&amp; *(open + yx) == 1) &#123; int rx = root(x); int ryx = root(yx); if (!Find(x, yx)) id[rx] = yx;//连接根节点即可 &#125;&#125;void Duru()//读入&#123; printf(&quot;请输入渗滤装置图的边长:&quot;); scanf_s(&quot;%d&quot;, &amp;n); id = (int*)malloc((n*n+1)*sizeof(int)); open = (int*)malloc((n * n + 1) * sizeof(int)); init(); int* p = (int*)malloc((n + 1) * sizeof(int)); printf(&quot;请输入渗滤装置图\\n&quot;); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; scanf_s(&quot;%1d&quot;, p + j); if (*(p + j) == 1) &#123; *(open + (j + (i - 1) * n)) = 1; Union(j + (i - 1) * n); &#125; &#125; &#125; printf(&quot;已成功读入并处理该图！！！\\n&quot;); printf(&quot;命令样式:1 (一号命令、打印渗滤图)\\n&quot;); printf(&quot;命令样式:2 8(二号命令、将8号结点位置渗滤功能open)\\n&quot;); printf(&quot;命令样式:3 4 7(三号命令、查询4号结点和7号结点是否连通)\\n&quot;); printf(&quot;命令样式:4(四号命令、查询该渗滤装置是否能工作)\\n&quot;); printf(&quot;请输入控制命令\\n&quot;);&#125;void SX()&#123; id[0] = 0; id[n * n + 2] = n * n + 2; int roots = id[0]; for (int i = 1; i &lt;= n; i++) &#123; int ri = root(i); id[ri] = roots; &#125; int rootx = id[n*n+2]; for (int i = n*n-n+1; i &lt;= n*n; i++) &#123; int ri = root(i); id[ri] = rootx; &#125;&#125;void print()&#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; printf(&quot;%5d&quot;, root(j + n * (i - 1))); &#125; printf(&quot;\\n&quot;); &#125;&#125;int main()&#123; Egscanf(); Duru(); int o=4, p, q; while (o != -1) &#123; scanf_s(&quot;%d&quot;, &amp;o); if (o == 1) print(); if (o == 2) &#123; scanf_s(&quot;%d&quot;, &amp;p); open[p] = 1; Union(p); printf(&quot;%d号结点位置渗滤功能已 open\\n&quot;,p); &#125; if (o == 3) &#123; scanf_s(&quot;%d%d&quot;, &amp;p, &amp;q); if (Find(p, q)) printf(&quot;%d结点和%d结点连通\\n&quot;, p, q); else printf(&quot;%d结点和%d结点不连通\\n&quot;, p, q); &#125; if (o == 4) &#123; SX(); if(Find(0,n*n+2)) printf(&quot;该渗滤装置能工作!!!\\n&quot;); else printf(&quot;该渗滤装置不能工作!!!\\n&quot;); break; &#125; &#125; return 0;&#125; End","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/B_并查集/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"并查集","slug":"并查集","permalink":"https://帆帆.icu/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"Balanced Lineup","text":"Balanced Lineup题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152C#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define MAX 50010int h[MAX];int Fmax[MAX][20];int Fmin[MAX][20];int N, Q;int max(int x, int y)&#123; return x &gt; y ? x : y;&#125;int min(int x, int y)&#123; return x &gt; y ? y : x;&#125;void ST_create()&#123; //初始化0列 for (int i = 1; i &lt;= N; i++) Fmax[i][0] = Fmin[i][0] = h[i]; int k = log2(N);//log(N)/log(2.0) for(int j=1;j&lt;=k;j++)//1到k列 for (int i = 1; i &lt;= N - (1 &lt;&lt; j) + 1; i++) &#123; Fmax[i][j] = max(Fmax[i][j - 1], Fmax[i + (1 &lt;&lt; (j - 1))][j - 1]); Fmin[i][j] = min(Fmin[i][j - 1], Fmin[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125;&#125;int RMQ(int l,int r)&#123; int k = log2(r - l + 1); int m1 = max(Fmax[l][k], Fmax[r - (1 &lt;&lt; k) + 1][k]); int m2 = min(Fmin[l][k], Fmin[r - (1 &lt;&lt; k) + 1][k]); return m1 - m2;&#125;int main()&#123; int a, b; while (scanf(&quot;%d %d&quot;, &amp;N, &amp;Q)!=EOF) &#123; for (int i = 1; i &lt;= N; i++) scanf(&quot;%d&quot;, &amp;h[i]); ST_create(); while (Q--) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\\n&quot;, RMQ(a, b)); &#125; &#125; return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Balanced Lineup/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"RMQ","slug":"RMQ","permalink":"https://帆帆.icu/tags/RMQ/"},{"name":"二分","slug":"二分","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"Bit Map","text":"引言一、类似于桶排序的思想，但我们从一个 int 缩小到一个 bit，占用缩小 32 倍 ` 二、对于一个 32位系统而言，我们用 bitmap 可以存储 42亿左右的巨额数据量 三、我们能够精确迅速地判断某个数据是否存在某个集合中！ 位运算一、大小关系1 int 等于 4 byte1 byte 等于 8 二进制位二、运算符&lt;&lt; 左移 —— 乘 2****&gt;&gt; 右移 —— 除 2举个例子： 123int n = 1; //00000000 00000000 00000000 00000001printf(&quot;%d&quot;,n &lt;&lt; 1); //00000000 00000000 00000000 00000010//&gt;&gt;同理 ~ ——0 和 1 互换（含符号位）（取反）举个例子： 123456int n = 1; printf(&quot;%d&quot;,~n);//00000000 00000000 00000000 00000001(1的原码)//00000000 00000000 00000000 00000001(1的补码)//11111111 11111111 11111111 11111110(~取反运算得到B补码)//10000000 00000000 00000000 00000010(B补码的原码，取反加1，即-2) 对任意一个二进制数取反的含义是什么？1010 取反是 01010100 取反是 1011，容易看出取反的本质就是找一个数和原来的相加得到每一位均为 1 的数 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int num = 10; //00000000 00000000 00000000 00001010 num = num | (1 &lt;&lt; 5); //00000000 00000000 00000000 00101010 printf(&quot;%d\\n&quot;, num); system(&quot;pause&quot;); return 0;&#125; 示例1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 99999999int bitmap[MAX];//(32x99999999=3,199,999,968约32亿个bit)int main()&#123; long long p; printf(&quot;请输入非负整数\\n&quot;); while (scanf_s(&quot;%lld&quot;, &amp;p) != EOF) bitmap[p &gt;&gt; 5] = bitmap[p &gt;&gt; 5] | (1 &lt;&lt; p &amp; (32 - 1)); //删除某个数 //bitmap[p &gt;&gt; 5] = bitmap[p &gt;&gt; 5] &amp; ~ (1 &lt;&lt; p &amp; (32 - 1));a return 0;&#125; 参考文献位数组 (bit 数组) END","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Bit Map/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"位图","slug":"位图","permalink":"https://帆帆.icu/tags/%E4%BD%8D%E5%9B%BE/"},{"name":"位运算","slug":"位运算","permalink":"https://帆帆.icu/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"D To E","text":"题目来源From D to E and Back 题目解析 问题一：如何存图？ 因为要频繁地判断两节点间是否有边，所以这里采用邻接矩阵最为方便 问题二：什么情况下 E 不可能存在？ 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445C++#include&lt;iostream&gt;#define MAX 500#define REP(i,b,e) for(int i=(b);i&lt;(e);i++)using namespace std;int map[MAX][MAX];bool solve(int n)&#123; REP(i, 0, n) REP(j, 0, n) &#123; bool flag1 = false, flag2 = false; REP(k, 0, n) &#123; if (map[i][k] &amp;&amp; map[j][k]) flag1 = true; if (map[i][k] ^ map[j][k]) flag2 = true; &#125; if (flag1 &amp;&amp; flag2) return false; &#125; return true;&#125;int main()&#123; int x, n, m; cin &gt;&gt; x; while (x--) &#123; memset(map, 0, sizeof(map)); cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; map[a][b] = 1; &#125; if (solve(n)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/D To E/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"二叉树重建","text":"题目来源二叉树重建 题目解析本题是通过前序遍历和中序遍历得到的顺序推出后序遍历，也就是有两个字符串推出另外一个字符串 样例输入：DBACEGF ABCDEFG 一、由前序得到 root 结点 D（pre [0]），再中序中寻找到对应位置，代码如下： 1234int len = 0;while (pre[0] != in[len])&#123; len++;&#125; 二、截取 D 的左右子树 D 的左子树的前序遍历为 BAC、中序遍历为 ABCD 的右子树的前序遍历为 EGF、中序遍历为 EFG重复上述步骤 三、输出当前根节点 因为是后序遍历最后要输出根结点 用 C 语言手动实现字符串截取函数，代码如下： 12345678910111213char* Intercept_string(char *p, int s, int n)&#123; char* h; int j = 0; h = (char*)malloc((n + 1) * sizeof(char)); for (int i = s; i &lt; n + s; i++) &#123; *(h+j)= *(p+i); j++; &#125; *(h + j) = &#x27;\\0&#x27;; //注意加上字符串截止符 return h;&#125;//p：待截取字符串首地址、s：起始位置、n：截取长度 完整代码C语言代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define MAX 100char* Intercept_string(char* p, int s, int n)&#123; char* h; int j = 0; h = (char*)malloc((n + 1) * sizeof(char)); for (int i = s; i &lt; n + s; i++) &#123; *(h + j) = *(p + i); j++; &#125; *(h + j) = &#x27;\\0&#x27;; return h;&#125;void pose_ergodic(char pre[], char in[])&#123; if (strlen(pre) &lt;= 0) return; int len = 0; while (pre[0] != in[len]) &#123; len++; &#125; pose_ergodic(Intercept_string(pre, 1, len), Intercept_string(in, 0, len)); pose_ergodic(Intercept_string(pre, len + 1, strlen(pre) - 1), Intercept_string(in, len + 1, strlen(in) - 1)); printf(&quot;%c&quot;, pre[0]);&#125;int main()&#123; char ch1[MAX], ch2[MAX]; while(~scanf(&quot;%s%s&quot;, &amp;ch1,&amp;ch2)) &#123; getchar(); pose_ergodic(ch1, ch2); printf(&quot;\\n&quot;); &#125; return 0;&#125; C++代码1234567891011121314151617181920212223242526#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;void postErgodic(string pre, string in)&#123; if (pre.size() != 0) &#123; int len = 0; len = in.find(pre[0]); postErgodic(pre.substr(1,len),in.substr(0,len)); postErgodic(pre.substr(len + 1), in.substr(len + 1)); cout &lt;&lt; pre[0]; &#125;&#125;int main()&#123; string pre, in; while (cin&gt;&gt;pre&gt;&gt;in) &#123; postErgodic(pre, in); cout &lt;&lt; endl; &#125; return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/E_二叉树重建/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"BT","slug":"BT","permalink":"https://帆帆.icu/tags/BT/"},{"name":"String","slug":"String","permalink":"https://帆帆.icu/tags/String/"}]},{"title":"Entropy","text":"题目来源Entropy 题目解析 问题一：本题什么意思？ 用熵编码简化 ASCII 码，熵编码器是一种数据编码方法，通过将消息编码为删除 “浪费” 或 “额外” 信息，实现无损数据压缩。换句话说，熵编码会删除最初不需要的信息来准确编码消息。高度熵意味着信息会浪费大量信息：在 ASCII 中编码的英语文本是具有非常高熵的消息类型示例。已经压缩的消息，如 JPEG 图形或 ZIP 档案，几乎没有熵，并没有从熵编码的进一步尝试中获益。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142C++#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;iostream&gt;#define MAX 30using namespace std;int statistics[MAX];//字母个数int main()&#123; while (1) &#123; string s; cin &gt;&gt; s; if (s == &quot;END&quot;) break; memset(statistics, 0, sizeof(statistics)); int n = s.size(); for (int i = 0; i &lt; n; i++) &#123; if (s[i] == &#x27;_&#x27;) statistics[26]++; else statistics[s[i] - &#x27;A&#x27;]++; &#125; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for (int i = 0; i &lt;=26; i++) if (statistics[i]) q.push(statistics[i]); int ans = n; while (q.size() &gt;2) &#123; int t, t1, t2; t1 = q.top();q.pop(); t2 = q.top();q.pop(); t = t1 + t2; q.push(t); ans += t; &#125; printf(&quot;%d %d %.1lf\\n&quot;, n * 8, ans, (double)(n * 8) / ans); &#125; return 0;&#125; Note 将 ans 初始化为 n 意义何在？ 答：最后一次合并的结果的大小一定是 n（哈夫曼树的树根 = 叶子权值之和），这样可以省掉最后一次合并的运算 为什么是 q.size ()&gt;2 因为最后一次合并不用进行，所以还剩下两个节点时就跳出循环了，对于刚好两个结点的情况也适用！ 当 ans 初始化为 0 时怎么写？ 1234567891011C++int ans = 0; while (q.size() !=1) &#123; int t, t1, t2; t1 = q.top(); q.pop(); t2 = q.top(); q.pop(); t = t1 + t2; q.push(t); ans += t; &#125;","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Entropy/","date":"09-16","excerpt":"","tags":[{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Fence Repair","text":"题目来源Fence Repair 题目解析 问题一：该题的类型是什么？ 每切开一块木板就得到两块木板，两块木板的长度之和等于之前的那一块木板，类似于二叉树本题又是一道求解最优值的问题，不难想到最优二叉树，即哈夫曼树。 完整代码1234567891011121314151617181920212223242526272829303132C++#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;Q;int main()&#123; int n, m; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; m; Q.push(m); &#125; if (Q.size() == 1) cout &lt;&lt; m; else &#123; long long sum = 0; while (Q.size() != 1) &#123; int a = Q.top(); Q.pop(); int b = Q.top(); Q.pop(); sum += a + b; Q.push(a+b); &#125; cout &lt;&lt; sum; &#125; return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Fence Repair/","date":"09-16","excerpt":"","tags":[{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Huffman 编码树","text":"题目来源Huffman 编码树 题目解析 问题一：什么是 Huffman 树？ 点击转到 - 哈夫曼树 问题二：需要把整个 huffman 树构造出来吗？ 答：不需要，题目要求我们求 WPL 的大小，所以我们在优先队列里实现这个计算过程就可以了。 问题三：什么是优先队列？ 点击转到 - C++ 完整代码12345678910111213141516171819202122232425262728C++#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;Q;int ans;int main()&#123; int n, x; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; x; Q.push(x); &#125; while (Q.size()!= 1) &#123; int a, b; a = Q.top(); Q.pop(); b = Q.top(); Q.pop(); Q.push(a + b); ans += a + b; &#125; cout &lt;&lt; ans; return 0;&#125; 要点 1：生成哈夫曼树可以使得带权外部路径长度 WPL 总和最小要点 2：新生成的结点值之和即为最终答案，所以无需等到哈夫曼树完全生成后再计算","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Huffman 编码树/","date":"09-16","excerpt":"","tags":[{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Inverting Huffman","text":"题目来源Inverting HuffmanCSDN - 反转树 题目解析 问题一：本题有最大值吗？ 本题不存在最大值，因为通过等比放大，我们可以得到无数种可能，二叉树的形态不变，节点值的大小可以无限大。 问题二：刚开始时基准数（temp）为什么为 1？ 因为我们要求最小值，最后一层结点值初始化为 1 时可得到最小值 且 temp 不仅是用来初始化最后一层节点的值，也用来更新每一层的最大值 最后一层的最大值恰好等于初始值 问题三：本题要点是什么？ vector 数组记录每一层 + temp 更新 + 哈夫曼树 完整代码123456789101112131415161718192021222324252627282930313233343536C++#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAX 55using namespace std;vector&lt;long long&gt;deep[MAX];//向量数组int main()&#123; int n, x; while (cin &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) deep[i].clear();//清空每一个vector int maxd = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; deep[x].push_back(0);//几个0就代表几个元素 maxd= max(maxd, x);//求最大深度 &#125; long long temp = 1;//基准数，初始化为1 for (int i = maxd; i &gt; 0; i--) &#123; for (int j = 0; j &lt; deep[i].size(); j++) if (!deep[i][j]) deep[i][j] = temp; sort(deep[i].begin(),deep[i].end()); for (int j = 0; j &lt; deep[i].size(); j += 2) deep[i - 1].push_back(deep[i][j] + deep[i][j + 1]); temp = *(deep[i].end() - 1);//第i层的最大值 &#125; cout &lt;&lt; *deep[0].begin() &lt;&lt; endl; &#125; return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Inverting Huffman/","date":"09-16","excerpt":"","tags":[{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Jungle Roads","text":"题目来源Jungle Roads 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677C++#include&lt;cstring&gt;#include&lt;iostream&gt;#define MAX 30using namespace std;int map[MAX][MAX];int n, book[MAX], dis[MAX];void init()&#123; memset(map, 0x3f, sizeof(map)); for (int i = 0; i &lt; MAX; i++ ) &#123; book[i] = 0; dis[i] = 0x3f3f3f3f; &#125;&#125;int prim(int s)&#123; int sum = 0; book[s] = 1; for (int i = 1; i &lt;= n; i++)//记录相邻点的距离 dis[i] = map[s][i]; int m = n-1; while (m--) &#123; int min = 0x3f3f3f3f, t; for (int i = 1; i &lt;= n; i++) &#123; if (book[i] == 0 &amp;&amp; dis[i] &lt; min) &#123; min = dis[i]; t = i; &#125; &#125; sum += dis[t]; book[t] = 1; for (int i = 1; i &lt;= n; i++) &#123; if (book[i] ==0 &amp;&amp; dis[i] &gt; map[t][i]) dis[i] = map[t][i]; &#125; &#125; return sum;&#125;int main()&#123; while (cin &gt;&gt; n &amp;&amp; n) &#123; init();//初始化 int m = n - 1; while (m--)//读入 &#123; char ch; cin &gt;&gt; ch; int a = ch - &#x27;A&#x27; + 1; int b; cin &gt;&gt; b; if (b != 0) &#123; while (b--) &#123; int c; cin &gt;&gt; ch&gt;&gt;c; map[a][ch - &#x27;A&#x27; + 1] = c; map[ch - &#x27;A&#x27; + 1][a] = c; &#125; &#125; &#125; cout&lt;&lt;prim(1)&lt;&lt;endl;//prim算法 &#125; return 0;&#125;/* 一、初始化 二、数据读入 三、prim算法*/ 题目解析 END","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Jungle Roads/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"MST","slug":"MST","permalink":"https://帆帆.icu/tags/MST/"},{"name":"Prim","slug":"Prim","permalink":"https://帆帆.icu/tags/Prim/"}]},{"title":"LCA","text":"LCA简介LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点 u 和 v 最近的公共祖先。 ——— 来自百度百科 暴力穷举一、建图（father 数组）二、标记法1、u 结点的前辈全部标记后，v 结点再向上一层一层 find 直到寻找到被标记的结点，该节点即为 LCA2、DFS 找出结点深度，u v 跳到同一层，再同步向上跳，当跳到同一个节点时，该结点即为 LCA 例题： Nearest Common Ancestors(待修正)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950C++#include&lt;iostream&gt;#define MAX 10010using namespace std;int father[MAX], book[MAX];void init(int n)&#123; for(int i=1;i&lt;=n;i++) father[i] = i;&#125;int LCA(int u, int v)&#123; if (u == v) //同一结点的情况 return u; book[u] = 1; //防止漏掉u恰好是v父亲的情况 while (u != father[u]) &#123; u = father[u]; book[u] = 1; &#125; while (v != father[v]) &#123; v = father[v]; if (book[v] == 1) return v; &#125; return v;&#125;int main()&#123; int t; cin &gt;&gt; t; while (t--) &#123; int m; cin &gt;&gt; m; init(m); m--; while(m--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; father[b] = a; &#125; int p, q; cin &gt;&gt; p &gt;&gt; q; cout &lt;&lt; LCA(p, q)&lt;&lt;endl; &#125; return 0;&#125; 例题：How far away ？12345678910111213141516171819202122232425262728293031323334353637C++#include&lt;iostream&gt;using namespace std;const int MAX = 40005;int n, m, k, F[MAX][20];int head[MAX], dist[MAX], d[MAX], cnt;struct Edge&#123; int t, c, next;&#125;e[MAX&lt;&lt;2];int LCA(int u, int v)&#123; &#125;int main()&#123; int t, n, f; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; f; n--; while (n--) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; &#125; while (f--) &#123; int p, q; cin &gt;&gt; p &gt;&gt; q; cout &lt;&lt; LCA(p, q) &lt;&lt; endl; &#125; &#125; return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/LCA/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"LCA","slug":"LCA","permalink":"https://帆帆.icu/tags/LCA/"}]},{"title":"图的遍历","text":"题目来源图的遍历 题目解析 问题一：选择什么建图方式？ 优先考虑链式前向星或邻接表，因为我们要遍历整个图，所以通常情况下从 a 节点出发遍历能到达的节点，而上述两种建图方法恰好保留某点所有邻接点的值。 问题二：单纯的 DFS 可以吗？ 这个当然可以，但是比较费时，可能会时间超限。 问题三：有什么巧妙地做法？ 倒叙构建该有向图，然后从编号最大点开始 DFS，其所能到达的点能到达的最大点就是该编号，用一个 maxn 数组记录该值。 完整代码1234567891011121314151617181920212223242526272829303132333435363738C++#include&lt;iostream&gt;#define MAX 100005using namespace std;struct Edge&#123; int to, next;&#125;edge[MAX];int n, m, cnt, head[MAX], maxn[MAX];void add(int u, int v)&#123; edge[++cnt].to = v;//从1开始时就不用初始化为-1了 edge[cnt].next = head[u]; head[u] = cnt; &#125;void dfs(int v,int u)&#123; if (maxn[u]) return; maxn[u] = v; for (int i = head[u]; i; i = edge[i].next) dfs(v, edge[i].to);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; add(v, u); &#125; for (int i = n; i &gt; 0; i--) dfs(i, i); for (int i = 1; i &lt;=n; i++) cout &lt;&lt; maxn[i]&lt;&lt;&#x27; &#x27;; return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/T_图的遍历/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"新二叉树","text":"题目来源P1305 新二叉树 题目解析 问题一：数组存储 or 链式存储 ？ 如果采用链式存储的话每次读数据的时都要寻找当前读入的数据的根节点的位置，并不高效！所以我们采用数组存储 问题二：如何用数组存储？ 题目给出的数据是父亲和两个孩子所以我们可以记录根结点、然后用 L 数组记录左孩子、R 数组记录右孩子 问题三：数据输入时出现断层会有影响吗？ 不会，因为给出的数据一定会构成二叉树，某一次数据的断层并不影响最终的整体连接效果。 完整代码1234567891011121314151617181920212223242526272829C#include&lt;stdio.h&gt;#define MAX 100int l[MAX], r[MAX], root;void pre_ergodic(int t)&#123; if (t != &#x27;*&#x27; - &#x27;a&#x27;) &#123; printf(&quot;%c&quot;, t + &#x27;a&#x27;); pre_ergodic(l[t]); pre_ergodic(r[t]); &#125;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); getchar(); for (int i = 0; i &lt; n; i++) &#123; char ch[4]; scanf(&quot;%s&quot;,&amp;ch); if (i==0) root = ch[0] - &#x27;a&#x27;; l[ch[0] - &#x27;a&#x27;] = ch[1] - &#x27;a&#x27;; r[ch[0] - &#x27;a&#x27;] = ch[2] - &#x27;a&#x27;; &#125; pre_ergodic(root); return 0;&#125;","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/X_新二叉树/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"BT","slug":"BT","permalink":"https://帆帆.icu/tags/BT/"}]},{"title":"最小生成树","text":"题目来源最小生成树 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273C++#define MAX 5010#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int n, m;int map[MAX][MAX];int book[MAX], dis[MAX];void init()&#123; memset(map, 0x3f, sizeof(map)); for (int i = 1; i&lt;=n; i++) &#123; book[i] = 0; dis[i] = 0x3f3f3f3f; &#125;&#125;int prim(int s)&#123; int sum = 0; book[s] = 1; for (int i = 1; i &lt;= n; i++) dis[i] = map[s][i]; int m = n - 1; while (m--) &#123; int min = 0x3f3f3f3f, t; for (int i = 1; i &lt;= n; i++) &#123; if (min &gt; dis[i] &amp;&amp; book[i] == 0) &#123; min = dis[i]; t = i; &#125; &#125; sum += dis[t]; book[t] = 1; for (int i = 1; i &lt;= n; i++) &#123; if (dis[i] &gt; map[t][i] &amp;&amp; book[i] == 0) dis[i] = map[t][i]; &#125; &#125; return sum;&#125;int main()&#123; init();//初始化 cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (map[a][b]&gt;c) &#123; map[a][b] = c; map[b][a] = c; &#125; &#125; int p=prim(1); int flag = 0; for (int i = 1; i &lt;= n; i++) &#123; if (book[i] == 0) flag = 1; &#125; if (flag) cout &lt;&lt; &quot;orz&quot;; else cout &lt;&lt; p; return 0;&#125; 题目解析一、初始化二、读入数据三、Prim 算法 END","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Z_最小生成树/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"MST","slug":"MST","permalink":"https://帆帆.icu/tags/MST/"},{"name":"Prim","slug":"Prim","permalink":"https://帆帆.icu/tags/Prim/"}]},{"title":"SnakeEating","text":"贪吃蛇运行条件需要安装 EasyX方式一：EasyX方式二：见运行附件 VC++6.0 运行需要设置多线程方法：Project-&gt;Settings-&gt;C/C+±&gt;Code Generation-&gt;Use run-time libray-&gt;Debug Multithread，或 Multithread，或 Debug Multithread DLL， 或 Multithread DLL 都可以 VS 2019 运行需要使用多字节字符集方法：项目 -&gt; 属性 -&gt; 高级 -&gt; 字符集 -&gt; 使用多字节字符集 Music 和 Picture 文件需要放在对应目录下运行附件（百度云） 提取码：lsd7运行附件（阿里云） 提取码：7lpl 更新说明引入多线程加入感谢名单BGM—GET 微调吃 food 时增加分数显示开始时自动切换为英文输入法问题修复 game over 后需要按两次 enter 键引导画面文字播报与 BGM 踩点，缩短时间修复进入游戏后连敲三下 Enter 的闪退问题 完整代码 (VC++6.0)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557C#include&lt;math.h&gt;#include&lt;time.h&gt;#include&lt;conio.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;process.h&gt;#include&lt;windows.h&gt;#include&lt;graphics.h&gt;#include &lt;mmsystem.h&gt;#pragma comment(lib, &quot;winmm.lib&quot;)#define lx 640#define ly 480#define Sup 7//换肤模式突变点#define MAX 500int key,thread,flag, mark, p, ans, i = 1, threadend = 1;; char s[1000]; double speed = 80;enum DIR//4个方向,enum为枚举类型&#123; PAUS, UP, DOWN, LEFT, RIGHT,&#125;;struct Food&#123; int x; int y; int r;//半径 bool flag; DWORD color;&#125;food;struct Snake&#123; int size; int speed; int dir; DWORD color1; DWORD color2; POINT coor[MAX];&#125;snake;void BGM_ALL(); //全局BGM unsigned __stdcall BGM_GET(void* pArguments); //吃食物BGM void BGM_FAIL(); //失败BGM void Duce(); //引导菜单 void Startmenu(); //开始菜单 void Overmenu(); //结束菜单 void Snakeinit(); //蛇初始化 void Foodinit(); //食物初始化 void Init(); //初始化 void Drawframe(); //画边框 void Skinsystem(int i); //皮肤系统 void Drawsnake(); //普通切换皮肤模式 void SupDrawsnake(); //快速切换皮肤模式 void Drawfood(); //画食物 void Draw(); //绘图 void Firstcontrol(); //按键交互 void Keycontrol(); //首次控制 void Snakemove(); //蛇移动 void Eatfood(); //吃食物void Generatefood(); //生成食物int Snakebump(); //蛇撞墙 int Eatself(); //咬自己 void Print(); //结束输出 void Reset(); //重置 void Thank(); //内测感谢名录 void Shift(); //按下Shift键void main()&#123; //多线程开始 HANDLE hThread; unsigned threadID; hThread = (HANDLE)_beginthreadex(NULL, 0, &amp;BGM_GET, NULL, 0, &amp;threadID); BGM_ALL(); Init(); Startmenu(); if (!key)//第一次开始按下shift键 &#123; Shift(); key = 1; &#125; while (1) &#123; Sleep(long(speed)); Draw(); if (flag == 0) &#123; Firstcontrol(); flag = 1; &#125; Snakemove(); if (Eatself() || Snakebump()) &#123; mciSendString(&quot;close BGM1&quot;, 0, 0, 0); BGM_FAIL(); break; &#125; Eatfood(); &#125; Overmenu(); switch (_getch()) &#123; case 13: &#123; i = 1; speed = 80; flag = mark = ans = 0; Reset(); threadend = 0; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); threadend = 1; main(); &#125; break; case 27: Thank(); closegraph(); Print(); break; &#125; //多线程结束 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread);&#125;void BGM_ALL()&#123; mciSendString(&quot;open ./Music/Scheming_Weasel.mp3 alias BGM1&quot;, 0, 0, 0); mciSendString(&quot;play BGM1 repeat&quot;, 0, 0, 0);&#125;unsigned __stdcall BGM_GET(void* pArguments)&#123; while (1) &#123; if (thread) &#123; mciSendString(&quot;open ./Music/Get.wav alias BGM2&quot;, 0, 0, 0); mciSendString(&quot;play BGM2 wait&quot;, 0, 0, 0); mciSendString(&quot;close BGM2 &quot;, 0, 0, 0); thread = 0; &#125; if (!threadend) break; &#125; return 0;&#125;void BGM_FAIL()&#123; mciSendString(&quot;open ./Music/Gameover.wav alias BGM3&quot;, 0, 0, 0); mciSendString(&quot;play BGM3 wait&quot;, 0, 0, 0); mciSendString(&quot;close BGM3 &quot;, 0, 0, 0);&#125;void Duce()&#123; if (p == 0) &#123; p = 1; Sleep(300); IMAGE one;//定义一个图片名. loadimage(&amp;one, &quot;Picture\\\\01.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;one);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE two;//定义一个图片名. loadimage(&amp;two, &quot;Picture\\\\02.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;two);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE three; loadimage(&amp;three, &quot;Picture\\\\03.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;three);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1400); IMAGE four; loadimage(&amp;four, &quot;Picture\\\\04.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;four);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE five; loadimage(&amp;five, &quot;Picture\\\\05.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;five);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1400); cleardevice(); &#125;&#125;void Startmenu()&#123; Duce(); while (_kbhit()) getchar(); IMAGE welcome; loadimage(&amp;welcome, &quot;Picture\\\\00.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;welcome);//绘制图像到屏幕，图片左上角坐标为(0,0) while (1) &#123; if (_getch() == 13) break; &#125;&#125;void Snakeinit()&#123; srand(GetTickCount()); snake.color1 = RGB(0, 235, 229); snake.size = 4; snake.speed = 10; snake.dir = PAUS; int randomx = rand() % (lx - 100) + 50; int randomy = rand() % (ly - 100) + 50; for (int i = 0; i &lt;= snake.size - 1; i++) &#123; snake.coor[i].x = (randomx / 10) * 10 - 10 * i; //（除10乘10类方格化处理） snake.coor[i].y = (randomy / 10) * 10; &#125;&#125;void Foodinit()&#123; int j; food.flag = 0; while (!food.flag) &#123; Generatefood(); for (j = 0; j &lt; snake.size; j++) if (fabs(snake.coor[j].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[j].y - food.y) &lt;= food.r) Generatefood(); food.flag = true; &#125;&#125;void Init()&#123; initgraph(lx, ly);//初始化窗口，大小640*480,/*SHOWCONSOLE*/ Snakeinit();//蛇初始化 Foodinit();//食物初始化&#125;void Drawframe()&#123; setlinestyle(PS_SOLID, 20); setlinecolor(RGB(93, 107, 153)); rectangle(0, 0, 640, 480);&#125;void Skinsystem(int q)&#123; int i; switch (q) &#123; case 1://YES //蛇头 setfillcolor(RGB(93, 107, 153)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(150, 157, 177)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 2://YES //蛇头 setfillcolor(RGB(186, 63, 110)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(248, 237, 203)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 3://YES setfillcolor(RGB(127, 205, 238)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 4://YES //蛇头 setfillcolor(RGB(221, 192, 179)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 5://YES setfillcolor(RGB(113, 111, 114)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; //蛇头 case 6://YES setfillcolor(RGB(206, 124, 128)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(170, 175, 231)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 7://YES setfillcolor(RGB(223, 165, 161)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(123, 130, 184)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; &#125;&#125;void SupDrawsnake()&#123; if (i &lt;= 7) &#123; Skinsystem(i); i++; &#125; else &#123; Skinsystem(1); i = 1; &#125;&#125;void Drawsnake()&#123; if (i &lt;= 7) Skinsystem(i); else &#123; Skinsystem(1); i = 1; &#125;&#125;void Drawfood()&#123; srand(GetTickCount()); if (food.flag) &#123; setfillcolor(RGB(rand() % 256, rand() % 256, rand() % 256)); solidcircle(food.x, food.y, food.r); &#125;&#125;void Draw()&#123; cleardevice(); BeginBatchDraw();//双缓冲绘图 setbkcolor(RGB(204, 213, 240));//背景色 cleardevice();//清空绘图设备 Drawframe();//画边框 //画蛇(两种模式) if (ans % Sup == 0 &amp;&amp; ans &gt;= 1) SupDrawsnake(); else Drawsnake(); Drawfood();//画食物 EndBatchDraw();//双缓冲绘图结束&#125;void Firstcontrol()&#123; switch (_getch()) &#123; case &#x27;W&#x27;: case&#x27;w&#x27;: case 72: if (snake.dir != DOWN) snake.dir = UP; break; case &#x27;S&#x27;: case &#x27;s&#x27;: case 80: if (snake.dir != UP) snake.dir = DOWN; break; case &#x27;A&#x27;: case &#x27;a&#x27;: case 75: if (snake.dir != RIGHT) snake.dir = LEFT; break; case &#x27;D&#x27;: case &#x27;d&#x27;: case 77: if (snake.dir != LEFT) snake.dir = RIGHT; break; case 13: Firstcontrol(); break; &#125;&#125;void Keycontrol()//按键控制&#123; if (_kbhit()) &#123; char key = _getch(); //72,80,75,77 switch (key) &#123; case &#x27;W&#x27;://上 case&#x27;w&#x27;: case 72: if (snake.dir != DOWN) snake.dir = UP; break; case &#x27;S&#x27;://下 case &#x27;s&#x27;: case 80: if (snake.dir != UP) snake.dir = DOWN; break; case &#x27;A&#x27;://左 case &#x27;a&#x27;: case 75: if (snake.dir != RIGHT) snake.dir = LEFT; break; case &#x27;D&#x27;://右 case &#x27;d&#x27;: case 77: if (snake.dir != LEFT) snake.dir = RIGHT; break; case 13: getchar(); break; &#125; &#125;&#125;void Snakemove()&#123; int i; for (i = snake.size - 1; i &gt; 0; i--) snake.coor[i] = snake.coor[i - 1]; Keycontrol(); switch (snake.dir) &#123; case UP: snake.coor[0].y -= snake.speed; break; case DOWN: snake.coor[0].y += snake.speed; break; case LEFT: snake.coor[0].x -= snake.speed; break; case RIGHT: snake.coor[0].x += snake.speed; break; case PAUS: getchar(); break; &#125;&#125;void Eatfood()&#123; if (food.flag &amp;&amp; fabs(snake.coor[0].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[0].y - food.y) &lt;= food.r) &#123; thread = 1;//多线程开始执行 i++; ans++; snake.color1 = food.color; if (speed &gt; 60) speed -= 0.05; food.flag = false; mark += food.r; snake.size += food.r*2/3; //显示分数 settextstyle(26, 0, &quot;微软雅黑&quot;); settextcolor(COLORREF RGB(0, 0, 0)); sprintf(s, &quot;%d&quot;, mark); outtextxy(food.x, food.y, s); &#125; int j; while (!food.flag) &#123; Generatefood(); for (j = 0; j &lt; snake.size; j++) if (fabs(snake.coor[j].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[j].y - food.y) &lt;= food.r) Generatefood(); food.flag = true; &#125;&#125;void Generatefood()&#123; srand(GetTickCount()); food.x = 10 + (rand() % 60 + 1) * 10; food.y = 10 + (rand() % 44 + 1) * 10; food.color = RGB(rand() % 256, rand() % 256, rand() % 256); food.r = rand() % 6 + 5; return;&#125;int Eatself()&#123; int j; for (j = 1; j &lt; snake.size; j++) if (snake.coor[j].x == snake.coor[0].x &amp;&amp; snake.coor[j].y == snake.coor[0].y) return 1; return 0;&#125;int Snakebump()&#123; int k = 10; if (snake.coor[0].x &lt;= k || snake.coor[0].x &gt;= lx - k || snake.coor[0].y &lt;= k || snake.coor[0].y &gt;= ly - k) return 1; return 0;&#125;void Overmenu()&#123; cleardevice(); IMAGE Game_over;//定义一个图片名. loadimage(&amp;Game_over, &quot;Picture\\\\game_over.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;Game_over);//绘制图像到屏幕，图片左上角坐标为(0,0) while (1) &#123; if (_getch() == &#x27;\\x0d&#x27;)//回车 break; &#125; cleardevice(); //统计信息 settextstyle(30, 0, &quot;楷体&quot;); settextcolor(COLORREF RGB(0, 0, 0)); outtextxy(220, 100, &quot;GAME OVER&quot;); sprintf(s, &quot;%d&quot;, mark); outtextxy(220, 150, &quot;你的分数为&quot;); outtextxy(380, 150, s); outtextxy(220, 200, &quot;按Enter重新游戏 &quot;); outtextxy(220, 250, &quot;按Esc退出游戏 &quot;);&#125;void Thank()&#123; IMAGE thank;//定义一个图片名. loadimage(&amp;thank, &quot;Picture\\\\06.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;thank);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(4000);&#125;void Print()&#123; printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;感谢您的陪伴！\\n&quot;); printf(&quot;您的分数是: %d 分\\n&quot;, mark); printf(&quot;\\n&quot;); printf(&quot;游戏开发者:\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;桃花涣小鱼干\\n&quot;); printf(&quot;\\n&quot;); getchar(); getchar();&#125;void Reset()&#123; int i; for (i = 0; i &lt;= snake.size; i++) snake.coor[i].x = snake.coor[i].y = 0;&#125;void Shift()&#123; keybd_event(0x10, 0, 0, 0); keybd_event(0x10, 0, KEYEVENTF_KEYUP, 0);&#125; 完整代码 (VS 2019)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557C#include&lt;math.h&gt;#include&lt;time.h&gt;#include&lt;conio.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;process.h&gt;#include&lt;windows.h&gt;#include&lt;graphics.h&gt;#include &lt;mmsystem.h&gt;#pragma comment(lib, &quot;winmm.lib&quot;)#define lx 640#define ly 480#define Sup 7//换肤模式突变点#define MAX 500int key,thread,flag, mark, p, ans, i = 1, threadend = 1;; char s[1000]; double speed = 80;enum DIR//4个方向,enum为枚举类型&#123; PAUS, UP, DOWN, LEFT, RIGHT,&#125;;struct Food&#123; int x; int y; int r;//半径 bool flag; DWORD color;&#125;food;struct Snake&#123; int size; int speed; int dir; DWORD color1; DWORD color2; POINT coor[MAX];&#125;snake;void BGM_ALL(); //全局BGM unsigned __stdcall BGM_GET(void* pArguments); //吃食物BGM void BGM_FAIL(); //失败BGM void Duce(); //引导菜单 void Startmenu(); //开始菜单 void Overmenu(); //结束菜单 void Snakeinit(); //蛇初始化 void Foodinit(); //食物初始化 void Init(); //初始化 void Drawframe(); //画边框 void Skinsystem(int i); //皮肤系统 void Drawsnake(); //普通切换皮肤模式 void SupDrawsnake(); //快速切换皮肤模式 void Drawfood(); //画食物 void Draw(); //绘图 void Firstcontrol(); //按键交互 void Keycontrol(); //首次控制 void Snakemove(); //蛇移动 void Eatfood(); //吃食物void Generatefood(); //生成食物int Snakebump(); //蛇撞墙 int Eatself(); //咬自己 void Print(); //结束输出 void Reset(); //重置 void Thank(); //内测感谢名录 void Shift(); //按下Shift键void main()&#123; //多线程开始 HANDLE hThread; unsigned threadID; hThread = (HANDLE)_beginthreadex(NULL, 0, &amp;BGM_GET, NULL, 0, &amp;threadID); BGM_ALL(); Init(); Startmenu(); if (!key)//第一次开始按下shift键 &#123; Shift(); key = 1; &#125; while (1) &#123; Sleep(speed); Draw(); if (flag == 0) &#123; Firstcontrol(); flag = 1; &#125; Snakemove(); if (Eatself() || Snakebump()) &#123; mciSendString(&quot;close BGM1&quot;, 0, 0, 0); BGM_FAIL(); break; &#125; Eatfood(); &#125; Overmenu(); switch (_getch()) &#123; case 13: &#123; i = 1; speed = 80; flag = mark = ans = 0; Reset(); threadend = 0; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); threadend = 1; main(); &#125; break; case 27: Thank(); closegraph(); Print(); break; &#125; //多线程结束 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread);&#125;void BGM_ALL()&#123; mciSendString(&quot;open ./Music/Scheming_Weasel.mp3 alias BGM1&quot;, 0, 0, 0); mciSendString(&quot;play BGM1 repeat&quot;, 0, 0, 0);&#125;unsigned __stdcall BGM_GET(void* pArguments)&#123; while (1) &#123; if (thread) &#123; mciSendString(&quot;open ./Music/Get.wav alias BGM2&quot;, 0, 0, 0); mciSendString(&quot;play BGM2 wait&quot;, 0, 0, 0); mciSendString(&quot;close BGM2 &quot;, 0, 0, 0); thread = 0; &#125; if (!threadend) break; &#125; return 0;&#125;void BGM_FAIL()&#123; mciSendString(&quot;open ./Music/Gameover.wav alias BGM3&quot;, 0, 0, 0); mciSendString(&quot;play BGM3 wait&quot;, 0, 0, 0); mciSendString(&quot;close BGM3 &quot;, 0, 0, 0);&#125;void Duce()&#123; if (p == 0) &#123; p = 1; Sleep(300); IMAGE one;//定义一个图片名. loadimage(&amp;one, &quot;Picture\\\\01.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;one);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE two;//定义一个图片名. loadimage(&amp;two, &quot;Picture\\\\02.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;two);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE three; loadimage(&amp;three, &quot;Picture\\\\03.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;three);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1400); IMAGE four; loadimage(&amp;four, &quot;Picture\\\\04.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;four);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE five; loadimage(&amp;five, &quot;Picture\\\\05.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;five);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1400); cleardevice(); &#125;&#125;void Startmenu()&#123; //Duce(); while (_kbhit()) getchar(); IMAGE welcome; loadimage(&amp;welcome, &quot;Picture\\\\00.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;welcome);//绘制图像到屏幕，图片左上角坐标为(0,0) while (1) &#123; if (_getch() == 13) break; &#125;&#125;void Snakeinit()&#123; srand(GetTickCount()); snake.color1 = RGB(0, 235, 229); snake.size = 4; snake.speed = 10; snake.dir = PAUS; int randomx = rand() % (lx - 100) + 50; int randomy = rand() % (ly - 100) + 50; for (int i = 0; i &lt;= snake.size - 1; i++) &#123; snake.coor[i].x = (randomx / 10) * 10 - 10 * i; //（除10乘10类方格化处理） snake.coor[i].y = (randomy / 10) * 10; &#125;&#125;void Foodinit()&#123; int j; food.flag = 0; while (!food.flag) &#123; Generatefood(); for (j = 0; j &lt; snake.size; j++) if (fabs(snake.coor[j].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[j].y - food.y) &lt;= food.r) Generatefood(); food.flag = true; &#125;&#125;void Init()&#123; initgraph(lx, ly);//初始化窗口，大小640*480,/*SHOWCONSOLE*/ Snakeinit();//蛇初始化 Foodinit();//食物初始化&#125;void Drawframe()&#123; setlinestyle(PS_SOLID, 20); setlinecolor(RGB(93, 107, 153)); rectangle(0, 0, 640, 480);&#125;void Skinsystem(int q)&#123; int i; switch (q) &#123; case 1://YES //蛇头 setfillcolor(RGB(93, 107, 153)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(150, 157, 177)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 2://YES //蛇头 setfillcolor(RGB(186, 63, 110)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(248, 237, 203)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 3://YES setfillcolor(RGB(127, 205, 238)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 4://YES //蛇头 setfillcolor(RGB(221, 192, 179)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 5://YES setfillcolor(RGB(113, 111, 114)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; //蛇头 case 6://YES setfillcolor(RGB(206, 124, 128)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(170, 175, 231)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 7://YES setfillcolor(RGB(223, 165, 161)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(123, 130, 184)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; &#125;&#125;void SupDrawsnake()&#123; if (i &lt;= 7) &#123; Skinsystem(i); i++; &#125; else &#123; Skinsystem(1); i = 1; &#125;&#125;void Drawsnake()&#123; if (i &lt;= 7) Skinsystem(i); else &#123; Skinsystem(1); i = 1; &#125;&#125;void Drawfood()&#123; srand(GetTickCount()); if (food.flag) &#123; setfillcolor(RGB(rand() % 256, rand() % 256, rand() % 256)); solidcircle(food.x, food.y, food.r); &#125;&#125;void Draw()&#123; cleardevice(); BeginBatchDraw();//双缓冲绘图 setbkcolor(RGB(204, 213, 240));//背景色 cleardevice();//清空绘图设备 Drawframe();//画边框 //画蛇(两种模式) if (ans % Sup == 0 &amp;&amp; ans &gt;= 1) SupDrawsnake(); else Drawsnake(); Drawfood();//画食物 EndBatchDraw();//双缓冲绘图结束&#125;void Firstcontrol()&#123; switch (_getch()) &#123; case &#x27;W&#x27;: case&#x27;w&#x27;: case 72: if (snake.dir != DOWN) snake.dir = UP; break; case &#x27;S&#x27;: case &#x27;s&#x27;: case 80: if (snake.dir != UP) snake.dir = DOWN; break; case &#x27;A&#x27;: case &#x27;a&#x27;: case 75: if (snake.dir != RIGHT) snake.dir = LEFT; break; case &#x27;D&#x27;: case &#x27;d&#x27;: case 77: if (snake.dir != LEFT) snake.dir = RIGHT; break; case 13: Firstcontrol(); break; &#125;&#125;void Keycontrol()//按键控制&#123; if (_kbhit()) &#123; char key = _getch(); //72,80,75,77 switch (key) &#123; case &#x27;W&#x27;://上 case&#x27;w&#x27;: case 72: if (snake.dir != DOWN) snake.dir = UP; break; case &#x27;S&#x27;://下 case &#x27;s&#x27;: case 80: if (snake.dir != UP) snake.dir = DOWN; break; case &#x27;A&#x27;://左 case &#x27;a&#x27;: case 75: if (snake.dir != RIGHT) snake.dir = LEFT; break; case &#x27;D&#x27;://右 case &#x27;d&#x27;: case 77: if (snake.dir != LEFT) snake.dir = RIGHT; break; case 13: getchar(); break; &#125; &#125;&#125;void Snakemove()&#123; int i; for (i = snake.size - 1; i &gt; 0; i--) snake.coor[i] = snake.coor[i - 1]; Keycontrol(); switch (snake.dir) &#123; case UP: snake.coor[0].y -= snake.speed; break; case DOWN: snake.coor[0].y += snake.speed; break; case LEFT: snake.coor[0].x -= snake.speed; break; case RIGHT: snake.coor[0].x += snake.speed; break; case PAUS: getchar(); break; &#125;&#125;void Eatfood()&#123; if (food.flag &amp;&amp; fabs(snake.coor[0].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[0].y - food.y) &lt;= food.r) &#123; thread = 1;//多线程开始执行 i++; ans++; snake.color1 = food.color; if (speed &gt; 60) speed -= 0.05; food.flag = false; mark += food.r*2/3; snake.size += food.r*2/3; //显示分数 settextstyle(25, 0, &quot;微软雅黑&quot;); settextcolor(COLORREF RGB(0, 0, 0)); sprintf_s(s, &quot;%d&quot;, mark); outtextxy(food.x, food.y, s); &#125; int j; while (!food.flag) &#123; Generatefood(); for (j = 0; j &lt; snake.size; j++) if (fabs(snake.coor[j].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[j].y - food.y) &lt;= food.r) Generatefood(); food.flag = true; &#125;&#125;void Generatefood()&#123; srand(GetTickCount()); food.x = 10 + (rand() % 60 + 1) * 10; food.y = 10 + (rand() % 44 + 1) * 10; food.color = RGB(rand() % 256, rand() % 256, rand() % 256); food.r = rand() % 6 + 5; return;&#125;int Eatself()&#123; int j; for (j = 1; j &lt; snake.size; j++) if (snake.coor[j].x == snake.coor[0].x &amp;&amp; snake.coor[j].y == snake.coor[0].y) return 1; return 0;&#125;int Snakebump()&#123; int k = 10; if (snake.coor[0].x &lt;= k || snake.coor[0].x &gt;= lx - k || snake.coor[0].y &lt;= k || snake.coor[0].y &gt;= ly - k) return 1; return 0;&#125;void Overmenu()&#123; cleardevice(); IMAGE Game_over;//定义一个图片名. loadimage(&amp;Game_over, &quot;Picture\\\\game_over.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;Game_over);//绘制图像到屏幕，图片左上角坐标为(0,0) while (1) &#123; if (_getch() == &#x27;\\x0d&#x27;)//回车 break; &#125; cleardevice(); //统计信息 settextstyle(30, 0, &quot;楷体&quot;); settextcolor(COLORREF RGB(0, 0, 0)); outtextxy(220, 100, &quot;GAME OVER&quot;); sprintf_s(s, &quot;%d&quot;, mark); outtextxy(220, 150, &quot;你的分数为&quot;); outtextxy(380, 150, s); outtextxy(220, 200, &quot;按Enter重新游戏 &quot;); outtextxy(220, 250, &quot;按Esc退出游戏 &quot;);&#125;void Thank()&#123; IMAGE thank;//定义一个图片名. loadimage(&amp;thank, &quot;Picture\\\\06.png&quot;, lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;thank);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(4000);&#125;void Print()&#123; printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;感谢您的陪伴！\\n&quot;); printf(&quot;您的分数是: %d 分\\n&quot;, mark); printf(&quot;\\n&quot;); printf(&quot;游戏开发者:\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;桃花涣小鱼干\\n&quot;); printf(&quot;\\n&quot;); getchar(); getchar();&#125;void Reset()&#123; int i; for (i = 0; i &lt;= snake.size; i++) snake.coor[i].x = snake.coor[i].y = 0;&#125;void Shift()&#123; keybd_event(0x10, 0, 0, 0); keybd_event(0x10, 0, KEYEVENTF_KEYUP, 0);&#125; 感谢名录Do_rJakeMineParaboyTremor.Yeyu沫殇心 感谢陪伴！END","path":"2021/09/16/S_实践项目/SnakeEating/","date":"09-16","excerpt":"","tags":[{"name":"C语言","slug":"C语言","permalink":"https://帆帆.icu/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Easyx","slug":"Easyx","permalink":"https://帆帆.icu/tags/Easyx/"},{"name":"多线程","slug":"多线程","permalink":"https://帆帆.icu/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}],"categories":[],"tags":[{"name":"心理学","slug":"心理学","permalink":"https://帆帆.icu/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"C++","slug":"C","permalink":"https://帆帆.icu/tags/C/"},{"name":"C语言","slug":"C语言","permalink":"https://帆帆.icu/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"Python","permalink":"https://帆帆.icu/tags/Python/"},{"name":"二进制","slug":"二进制","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"机器编码","slug":"机器编码","permalink":"https://帆帆.icu/tags/%E6%9C%BA%E5%99%A8%E7%BC%96%E7%A0%81/"},{"name":"APP","slug":"APP","permalink":"https://帆帆.icu/tags/APP/"},{"name":"链表","slug":"链表","permalink":"https://帆帆.icu/tags/%E9%93%BE%E8%A1%A8/"},{"name":"文件","slug":"文件","permalink":"https://帆帆.icu/tags/%E6%96%87%E4%BB%B6/"},{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"},{"name":"导数","slug":"导数","permalink":"https://帆帆.icu/tags/%E5%AF%BC%E6%95%B0/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://帆帆.icu/tags/MarkDown/"},{"name":"消费主义","slug":"消费主义","permalink":"https://帆帆.icu/tags/%E6%B6%88%E8%B4%B9%E4%B8%BB%E4%B9%89/"},{"name":"睡眠","slug":"睡眠","permalink":"https://帆帆.icu/tags/%E7%9D%A1%E7%9C%A0/"},{"name":"句","slug":"句","permalink":"https://帆帆.icu/tags/%E5%8F%A5/"},{"name":"小说","slug":"小说","permalink":"https://帆帆.icu/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"数据结构","slug":"数据结构","permalink":"https://帆帆.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"https://帆帆.icu/tags/%E6%A0%91/"},{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://帆帆.icu/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡","slug":"冒泡","permalink":"https://帆帆.icu/tags/%E5%86%92%E6%B3%A1/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://帆帆.icu/tags/BFS/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"并查集","slug":"并查集","permalink":"https://帆帆.icu/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"RMQ","slug":"RMQ","permalink":"https://帆帆.icu/tags/RMQ/"},{"name":"二分","slug":"二分","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E5%88%86/"},{"name":"位图","slug":"位图","permalink":"https://帆帆.icu/tags/%E4%BD%8D%E5%9B%BE/"},{"name":"位运算","slug":"位运算","permalink":"https://帆帆.icu/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"BT","slug":"BT","permalink":"https://帆帆.icu/tags/BT/"},{"name":"String","slug":"String","permalink":"https://帆帆.icu/tags/String/"},{"name":"MST","slug":"MST","permalink":"https://帆帆.icu/tags/MST/"},{"name":"Prim","slug":"Prim","permalink":"https://帆帆.icu/tags/Prim/"},{"name":"LCA","slug":"LCA","permalink":"https://帆帆.icu/tags/LCA/"},{"name":"Easyx","slug":"Easyx","permalink":"https://帆帆.icu/tags/Easyx/"},{"name":"多线程","slug":"多线程","permalink":"https://帆帆.icu/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}