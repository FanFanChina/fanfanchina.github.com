{"meta":{"title":"桃花换小鱼干の博客","subtitle":"","description":"","author":"张帆帆","url":"https://xn--ctta.icu","root":"/"},"pages":[{"title":"友情链接","text":"","path":"link/index.html","date":"09-15","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"09-15","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"09-15","excerpt":""}],"posts":[{"title":"地宫取宝","text":"题目来源 地宫取宝 题目解析 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;const int N = 55, MOD = 1000000007;int g[N][N], n, m, k;int f[N][N][13][14];int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; g[i][j]; g[i][j]++; } f[1][1][1][g[1][1]] = 1; f[1][1][0][0] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (i == 1 &amp;&amp; j == 1) continue; for (int u = 0; u &lt;= k; u++) for (int v = 0; v &lt;= 13; v++) { int&amp; val = f[i][j][u][v]; val = (val + f[i - 1][j][u][v]) % MOD; val = (val + f[i][j - 1][u][v]) % MOD; if (g[i][j] == v &amp;&amp; u &gt; 0) { for (int c = 0; c &lt; v; c++) { val = (val + f[i - 1][j][u - 1][c]) % MOD; val = (val + f[i][j - 1][u - 1][c]) % MOD; } } } } int res = 0; for (int i = 0; i &lt;= 13; i++) res = (res + f[n][m][k][i]) % MOD; cout &lt;&lt; res; return 0;} 反思总结 01.最多加两次就要 MOD 02.g[i] [j]++使得f数组下标不会为负数","path":"2022/03/02/L_蓝桥杯/D_地宫取宝/","date":"03-02","excerpt":"","tags":[{"name":"DP","slug":"DP","permalink":"https://帆帆.icu/tags/DP/"}]},{"title":"蚂蚁感冒","text":"题目来源 蚂蚁感冒 题目解析 01.碰到回头可以看成互相穿过⭐ 02.以感冒的蚂蚁为边界，分左右两边，分类讨论 完整代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 55;int a[N],n;int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i]; int left = 0,right = 0; //左边往右，右边往左 for(int i=0;i&lt;n;i++) { if((abs(a[i])&lt;abs(a[0]))&amp;&amp;a[i]&gt;0) left++; else if((abs(a[i])&gt;abs(a[0]))&amp;&amp;a[i]&lt;0) right++; } if(a[0]&gt;0&amp;&amp;right&gt;0) { cout&lt;&lt;1+left+right; } else if(a[0]&gt;0&amp;&amp;right==0) { cout&lt;&lt;1; } else if(a[0]&lt;0&amp;&amp;left&gt;0) { cout&lt;&lt;1+left+right; } else if(a[0]&lt;0&amp;&amp;left==0) { cout&lt;&lt;1; } return 0;} 反思总结 01.跳脱思维","path":"2022/03/01/L_蓝桥杯/M_蚂蚁感冒/","date":"03-01","excerpt":"","tags":[{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"}]},{"title":"摘花生","text":"题目来源 摘花生 题目解析 01.集合：从（1，1）到（i，j）点的所有路线的集合 02.集合种所有路线的花生总数的最大值 03.计算：最后到达（i，j）时，f [i] [j] = max(f [i - 1] [j], f [i] [j - 1]) + g [i] [j] 04.输出f [r] [c] 完整代码 12345678910111213141516171819202122232425262728#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int f[N][N], g[N][N], r, c;int main(){ int t; cin &gt;&gt; t; while (t--) { memset(f, 0, sizeof f); memset(g, 0, sizeof g); cin &gt;&gt; r &gt;&gt; c; for (int i = 1; i &lt;= r; i++) for (int j = 1; j &lt;= c; j++) cin &gt;&gt; g[i][j]; f[1][1] = g[1][1]; for (int i = 1; i &lt;= r; i++) for (int j = 1; j &lt;= c; j++) f[i][j] = max(f[i - 1][j], f[i][j - 1]) + g[i][j]; cout &lt;&lt; f[r][c] &lt;&lt; endl; } return 0;} 反思总结 4","path":"2022/03/01/L_蓝桥杯/Z_摘花生/","date":"03-01","excerpt":"","tags":[{"name":"DP","slug":"DP","permalink":"https://帆帆.icu/tags/DP/"},{"name":"线性DP","slug":"线性DP","permalink":"https://帆帆.icu/tags/%E7%BA%BF%E6%80%A7DP/"}]},{"title":"最长上升子序列","text":"题目来源 最长上升子序列 题目解析 01.状态表示： **集合f [i] ：所有以a [i]为结尾的最长上升子序列的集合 ** 属性：所有最长子序列的长度的最大值 02.状态计算： 不同点：以a [i]为结尾的最长上升子序列的倒数第二位可能是 空 or a[k] (1&lt;= k &lt; i) **状态方程：f[i]=max(f[j]+1,f[i]) ** 03.附加条件：a[i]前面的那个数一点小于a[i] 完整代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int a[N], f[N], n, res = 0;int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) { f[i] = 1; for (int j = 1; j &lt;= i; j++) { if (a[j] &lt; a[i]) f[i] = max(f[j] + 1, f[i]); } } for (int i = 1; i &lt;= n; i++) res = max(res, f[i]); cout &lt;&lt; res; return 0;} 反思总结 最后一个不同点，不一定是a[i]本身，而可能是a[i-1]","path":"2022/03/01/L_蓝桥杯/Z_最长上升子序列/","date":"03-01","excerpt":"","tags":[{"name":"DP","slug":"DP","permalink":"https://帆帆.icu/tags/DP/"},{"name":"线性DP","slug":"线性DP","permalink":"https://帆帆.icu/tags/%E7%BA%BF%E6%80%A7DP/"}]},{"title":"计算机网络","text":"简介 本篇博客是对 湖南科技大学-高军-计算机网络 课程笔记记录，具体请移步课程计算机网络 概述 因特网 01.网络：若干节点和连接结点的链路形成的集合 02.互联网：多个网络通过路由器互联形成互联网 03.因特网：世界上最大的互联网 04.ISP：Internet Service Provide 因特网服务提供商（中国移动、联通等） 信息交换(3种) 01.电路交换 📞——用户线——（电话交换机——中继线——电话交换机）n——用户线——📞 02.报文交换 发送方A——B——C——接受方D 03.分组交换 信息等分添加首部——分多个路由线路缓存转发——去除首部，信息合并 对比如下： 计算机网络的定义 计算机网络的分类 网络性能指标 比特 以下为数据量单位 1B 8bit 1KB 2 ^ 10 B 1MB 2 ^ 20 B 1GB 2 ^ 30 B 1TB 2 ^ 40 B **拓展：买来的固态硬盘和系统上显示的大小不一样的原因是厂家使用的数据量单位和计算机的不一样，厂家的1GB = 10 ^ 9 B ，换算成计算机显示的大小应该将总的 Byte / 2 ^ 20 ** 速率 以下为数据传送时比特率或数据率单位 bit/s（b/s、bps） bit/s b/s、bps Kbps 10 ^ 3 bps Mbps 10 ^ 6 bps Gbps 10 ^ 9 bps Tbps 10 ^ 12 bps 带宽 两种表述： 吞吐量 时延 01.三种时延 02.如何计算？ 03.例题 时延带宽积 往返时间 利用率 丢包率","path":"2022/02/28/J_计算机/J_计算机网络/","date":"02-28","excerpt":"","tags":[{"name":"网络","slug":"网络","permalink":"https://帆帆.icu/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"买不到的数目","text":"题目来源 买不到的数目 题目解析 01.dfs暴搜 02.打表找规律：(p-1)x(q-1)-1 完整代码 1234567891011121314151617181920212223242526//暴搜#include&lt;iostream&gt;using namespace std;int p, q;bool dfs(int m,int p,int q){ if (m == 0) return true; if (m &gt;= p &amp;&amp; dfs(m - p, p, q))return true; if (m &gt;= q &amp;&amp; dfs(m - q, p, q))return true; return false;}int main(){ cin &gt;&gt; p &gt;&gt; q; int res; for (int i = 1; i &lt;= 100000; i++) { if (!dfs(i, p, q)) res = i; } cout &lt;&lt; res; return 0;} 123456789//Math#include&lt;iostream&gt;using namespace std;int main(){ int p,q; cin&gt;&gt;p&gt;&gt;q; cout&lt;&lt;(p-1)*(q-1)-1; } 反思总结 01. (p-1)x(q-1)-1","path":"2022/02/28/L_蓝桥杯/M_买不到的数目/","date":"02-28","excerpt":"","tags":[{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"}]},{"title":"K倍区间","text":"题目来源 K倍区间 题目解析 01.一维度前缀和 02.双重循环会导致O（n）复杂度，导致超时 03.我们对公式变形：(s[j]-s[i-1])%k==0 —— (s[i-1]%k==s[j]%k) 04.用一个数组来记录不同余数出现的次数，用res巧妙地求和，例如某个余数次数出现四次，区间数为 0+1+2+3，所以我们在记录前求和即可 完整代码 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;typedef long long ll;const int N = 1e5+10;ll s[N],cnt[N],n,k,res;int main(){ scanf(\"%lld%lld\",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;s[i]); s[i]+=s[i-1]; } cnt[0] = 1; for(int i=1;i&lt;=n;i++) { res+=cnt[s[i]%k]; cnt[s[i]%k]++; } printf(\"%lld\",res); return 0;} 反思总结 01.一维度的前缀和可以在输入的时候直接前缀和数组来求 02.typedef long long ll 和 宏命令不一样需要加分号","path":"2022/02/28/L_蓝桥杯/K倍区间/","date":"02-28","excerpt":"","tags":[{"name":"前缀和","slug":"前缀和","permalink":"https://帆帆.icu/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"QT","text":"QT安装下载 略 使用介绍 01.三大基类：widget派生出mainwindows和diglog 02.名称和路径不要中文 **03.自动对齐 ctrl+i、注释 ctrl+/ ** 04.同名文件切换F4 第一个QT程序 12345678910#include \"mywidget.h\"#include &lt;QApplication&gt; //应用程序的类int main(int argc, char *argv[]) //argc命令行变量的数量、argv[]命令行变量数组{ QApplication a(argc, argv); //QApplication a，Q应用程序的对象a，有且仅有一个 myWidget w; //类myWidget的对象w w.show(); //w对象的方法 return a.exec(); //让a进入消息循环，以便于窗口一直存在} 按钮 123456789101112//第一种写法myWidget::myWidget(QWidget *parent) : QWidget(parent){ //创建一个按钮 QPushButton * btn= new QPushButton; //btn-&gt;show();//以顶层方式弹出窗口控件 //设置按钮的依赖对象 btn-&gt;setParent(this); //显示文本 btn-&gt;setText(\"你好啊\");} 123456789//第二种写法+重置窗口大小myWidget::myWidget(QWidget *parent) : QWidget(parent){ QPushButton *btn=new QPushButton(\"hahaha\",this); resize(600,400); //重置窗口大小}//弊端：按照控件的大小创造窗口的大小//解决方法:重置窗口大小 123456789//同时显示两个按钮myWidget::myWidget(QWidget *parent) : QWidget(parent){ QPushButton *btn1=new QPushButton(\"第一个按钮\",this); QPushButton *btn2 = new QPushButton(\"第二个按钮\",this); btn2-&gt;move(100,100); //如果不移动开的话会覆盖掉 resize(600,400);} 窗口 12345678910//设置窗口标题myWidget::myWidget(QWidget *parent) : QWidget(parent){ QPushButton *btn1=new QPushButton(\"第一个按钮\",this); QPushButton *btn2 = new QPushButton(\"第二个按钮\",this); btn2-&gt;move(100,100); resize(600,400); setWindowTitle(\"你好\"); //设置窗口标题} 12345678910//设置固定窗口大小myWidget::myWidget(QWidget *parent) : QWidget(parent){ QPushButton *btn1=new QPushButton(\"第一个按钮\",this); QPushButton *btn2 = new QPushButton(\"第二个按钮\",this); btn2-&gt;move(100,100); setWindowTitle(\"你好\"); setFixedSize(600,400);//设置固定窗口大小，这样可以不用重置窗口大小} 1//坐标系:左上角为原点、向右为x轴，向下为y轴 1234567891011//小练习myWidget::myWidget(QWidget *parent) : QWidget(parent){ setWindowTitle(\"piupiupiupiu\"); setFixedSize(600,400); QPushButton *btn1=new QPushButton(\"这是一个假的按钮\",this); QPushButton *btn2 = new QPushButton(\"你看，╰(*°▽°*)╯我不就是一个button 吗 ？\",this); btn1-&gt;move(100,100); btn2-&gt;move(100,200);} 12345678910//点击按钮关闭窗口myWidget::myWidget(QWidget *parent) : QWidget(parent){ setWindowTitle(\"piupiupiupiu\"); setFixedSize(600,400); QPushButton *btn = new QPushButton(\"点击关闭窗口\",this); btn-&gt;move(200,100); connect(btn,&amp;QPushButton::clicked,this,&amp;myWidget::close);} 自定义信号 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//老师class Teacher : public QObject{ Q_OBJECTpublic: explicit Teacher(QObject *parent = nullptr);signals: //自定义信号，返回值为空 //只需要声明，不需要实现 //可以有参数，可以重载 void hungry();public slots:};//学生class Student : public QObject{ Q_OBJECTpublic: explicit Student(QObject *parent = nullptr);signals:public slots: //返回值为空,需要声明,需要实现 void treate();};//treat函数实现void Student::treate(){ qDebug()&lt;&lt;\"我请客！！！\";}//窗口定义两个对象class myWidget : public QWidget{ Q_OBJECT //Q_OBJECT宏，允许对象使用信号和槽机制public: myWidget(QWidget *parent = 0); void classIsOver(); ~myWidget(); void isOver(); Teacher *t; Student *s;};//窗口定义触发函数void myWidget::isOver(){ emit t-&gt;hungry();}//初始化类、信号连接、触发信号myWidget::myWidget(QWidget *parent) : QWidget(parent){ setWindowTitle(\"piupiupiupiu\"); setFixedSize(600,400); this-&gt;s = new Student(this); this-&gt;t = new Teacher(this); connect(t,&amp;Teacher::hungry,s,&amp;Student::treate); isOver();}","path":"2022/02/25/B_编程语言/QT/","date":"02-25","excerpt":"","tags":[{"name":"QT","slug":"QT","permalink":"https://帆帆.icu/tags/QT/"}]},{"title":"四平方和","text":"题目来源 四平方和 题目解析 01.数据范围 0&lt;N&lt;5∗1e6——O（n）的算法 or 常数较小的 O（nlogn） 02.暴力枚举三个数每个数小于等于sqrt（n），O（n*根号n），会超时 03.所以我们只能枚举两个数，c和d，存到哈希表，然后枚举a和b，算出来c和d的平方和，判断在哈希表中是否存在 完整代码 123456789101112131415161718192021222324//暴力枚举#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;int n;int main(){ cin &gt;&gt; n; for (int a = 0; a * a &lt;= n; a++) for (int b = a; a * a + b * b &lt;= n; b++) for (int c = b; a * a + b * b + c * c &lt;= n; c++) { int d = sqrt(n - a * a - b * b - c * c); int t = d; if (a * a + b * b + c * c + t * t == n) { cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ' &lt;&lt; c &lt;&lt; ' ' &lt;&lt; d; return 0; } } return 0;} 123456789101112131415161718192021222324252627282930313233343536//O(n)#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 5e6+10;int n, C[N], D[N];int main(){ memset(C, -1, sizeof C); scanf(\"%d\", &amp;n); for (int c = 0; c * c &lt;= n; c++) for (int d = c; c * c + d * d &lt;= n; d++) { int s = c * c + d * d; if (C[s] == -1) { C[s] = c; D[s] = d; } } for (int a = 0; a * a &lt;= n; a++) for (int b = a; a * a + b * b &lt;= n; b++) { int t = n - a * a - b * b; if (C[t] != -1) { printf(\"%d %d %d %d\", a, b, C[t], D[t]); return 0; } } return 0;} 反思总结 01.memset的库不是algorithm 而是 cstring 02.桶排序也是哈希表的一种","path":"2022/02/25/L_蓝桥杯/S_四平方和/","date":"02-25","excerpt":"","tags":[{"name":"枚举","slug":"枚举","permalink":"https://帆帆.icu/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"哈希","slug":"哈希","permalink":"https://帆帆.icu/tags/%E5%93%88%E5%B8%8C/"}]},{"title":"机器人跳跃问题","text":"题目来源 机器人跳跃问题 题目解析 01.想这道题的思路——二分、dfs、贪心，dp 。。。 02.题目关键词——至少以多少能量值开始游戏——区间求左边界问题——二分 03.具有二段型，最小值左边不行，本身和其右边可以 完整代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;const int N = 100010;int n,a[N];bool check(int e){ for(int i=1;i&lt;=n;i++) { e=2*e-a[i]; if(e&gt;1e5) return true; if(e&lt;0) return false; } return true;}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); int l=0,r=1e5+1; while(l+1!=r) { int mid = l+r&gt;&gt;1; if(check(mid)) r=mid; else l=mid; } cout&lt;&lt;r; return 0;} 反思总结 01.两种情况应该列式子化简写出来，不然发现不了规律","path":"2022/02/23/L_蓝桥杯/J_机器人跳跃问题/","date":"02-23","excerpt":"","tags":[{"name":"二分","slug":"二分","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"SQL","text":"MySQL安装与使用 安装 MySQL 安装 使用 01.注释快捷键—— ctrl+/ SELECT 12#使用数据库use sql_store; #使用sql_store数据库 1234#获取所有列 *select * from customers #获取customers的所有列where customer_id = 1 #添加限制条件————id = 1order by birth_date #按某一列排序 123#选取多列use sql_store;select first_name,last_name from customers 123456#选取时进行运算use sql_store;select points, points*10+5 from customers 123456#选取时起别名use sql_store;select points as hahaha, points*10+5 as ' biubiubiu' #附加空格时加上'或\" from customers 123#删去重复项use sql_store;select distinct state from customers 12345678#小练习use sql_store;select * from products;select name, unit_price as 'unit price', unit_price * 1.1 as 'new price'from products WHERE 1234#限定整数use sql_store;select * from customers where points &gt; 2000 1234#限定字符串 use sql_store;select * from customers where state = 'VA' #state = 'va'也可以 1234#or use sql_store;select * from customers where state != 'VA' #state &lt;&gt; 'va'也可以 1234#限定日期use sql_store;select * from customers where birth_date &gt; '1990-01-01' 1234#小练习use sql_store;select * from orders where order_date &gt;= '2019-01-01' AND OR NOT 123use sql_store;select * from customers where birth_date &gt;= '1990-01-01' and points &gt; 1000 123use sql_store;select * from customers where birth_date &gt;= '1990-01-01' or points &gt; 1000 1234use sql_store;select * from customers where birth_date &gt;= '1990-01-01' or points &gt; 1000 and state = 'VA' # and &gt; or 1234#notuse sql_store;select * from customers where not(birth_date &gt;= '1990-01-01' or points &gt; 1000) 1234#小练习use sql_store;select * from order_items where order_id = 6 and unit_price * quantity &gt; 30 IN 123456789#OR —— IN-- use sql_store;-- select * from customers-- where state = 'VA' or state = 'FL' or state = 'CO'use sql_store;select * from customers where state in ('VA','FL','GA') 1234#NOT + INuse sql_store;select * from customers where state not in ('VA','FL','GA') 1234#小练习use sql_store;select * from products where quantity_in_stock in (49,38,72) BETWEEN 123use sql_store;select * from customers where points between 1000 and 3000 1234#小练习use sql_store;select * from customers where birth_date between '1990-01-01' and '2000-01-01' LIKE 123456# %use sql_store;select * from customers where last_name like 'B%' #B打头-- where last_name like '%B%' #含B-- where last_name like '%B' #B结尾 1234# _use sql_store;select * from customers where last_name like 'b____y' 12345# 小练习1use sql_store;select * from customers where address like '%TRAIL%' or address like '%AVENUE%' 1234# 小练习2use sql_store;select * from customers where phone like '%9' REGEXP","path":"2022/02/22/B_编程语言/SQL/","date":"02-22","excerpt":"","tags":[{"name":"SQL","slug":"SQL","permalink":"https://帆帆.icu/tags/SQL/"}]},{"title":"前缀和","text":"题目来源 前缀和 题目解析 01.借用S[ i ]表示前i个数的和，S[ 0 ] = 0 02.S数组可以在需求和的数组读入时一并算出 完整代码 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int main(){ const int N=100010; int n,m,a[N],s[N]; s[0]=0; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; s[i]=s[i-1]+a[i]; } while(m--) { int l,r; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl; } return 0;} 反思总结 01.cout&lt;&lt;s[r]-s[l-1]而不是cout&lt;&lt;s[r]-s[l]","path":"2022/02/18/L_蓝桥杯/Q_前缀和/","date":"02-18","excerpt":"","tags":[{"name":"前缀和","slug":"前缀和","permalink":"https://帆帆.icu/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"数的三次方根","text":"题目来源 数的三次方根 题目解析 01.用二分去逼近 完整代码 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main(){ double n; cin &gt;&gt; n; double l = -10000, r = 10000; //n的3次方根一点在n的范围内 while (r - l &gt; 1e-8) //多精确2位 { double mid = (l + r) / 2; if (mid * mid * mid &gt; n) r = mid; else l = mid; } printf(\"%lf\", l); //默认保留小数点后6位 return 0;} 反思总结 无","path":"2022/02/18/L_蓝桥杯/S_数的三次方根/","date":"02-18","excerpt":"","tags":[{"name":"二分","slug":"二分","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"子矩阵的和","text":"题目来源 子矩阵的和 题目解析 01.容斥原理的运用 02.S[i] [j] 表示1、1到i、j区域的面积 完整代码 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q, g[N][N], s[N][N];int main(){ scanf(\"%d%d%d\", &amp;n,&amp;m,&amp;q); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { scanf(\"%d\", &amp;g[i][j]); s[i][j] = s[i-1][j] + s[i][j-1]-s[i-1][j-1]+g[i][j]; } while (q--) { int x1, y1, x2, y2; scanf(\"%d%d%d%d\", &amp;x1,&amp;y1,&amp;x2,&amp;y2); cout &lt;&lt; s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1] &lt;&lt; endl; } return 0;} 反思总结 01.前缀和：s[i] [j] = s[i-1] [j] + s[i] [j-1]-s[i-1] [j-1]+g[i] [j];","path":"2022/02/18/L_蓝桥杯/Z_子矩阵的和/","date":"02-18","excerpt":"","tags":[{"name":"前缀和","slug":"前缀和","permalink":"https://帆帆.icu/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"数的范围","text":"题目来源 数的范围 题目解析 01.常规的二分搜索 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;const int N = 100010;int a[N], n, q;int main(){ cin &gt;&gt; n &gt;&gt; q; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; while (q--) { int p; cin &gt;&gt; p; int l = -1, r = n; while (l + 1 != r) { int mid = l + r &gt;&gt; 1; if (a[mid] &lt; p) l = mid; else r = mid; } if (r==n||a[r]!=p) cout &lt;&lt; \"-1 -1\" &lt;&lt; endl; else { cout &lt;&lt; r &lt;&lt; ' '; int r = n; while (l + 1 != r) { int mid = l + r &gt;&gt; 1; if (a[mid] &gt; p) r = mid; else l = mid; } cout &lt;&lt; l &lt;&lt; endl; } } return 0;} 反思总结 01.确定左右边界点 02.确定红蓝范围 03.小于L等，大于R等","path":"2022/02/17/L_蓝桥杯/S_数的范围/","date":"02-17","excerpt":"","tags":[{"name":"二分","slug":"二分","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"飞行员兄弟","text":"题目来源 飞行员兄弟 题目解析 01.一共16个把手，将±图转化为01图，用 k：0——2^16-1来枚举所有按的方式 02.图的状态也可以一用int state来存储 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;int state;int calcu(int x,int y){ return x*4+y;}void transOne(int x,int y){ state^=(1&lt;&lt;calcu(x,y));}void transAll(int x,int y){ for(int i=0;i&lt;4;i++) { transOne(x,i); transOne(i,y); } transOne(x,y);}int main(){ for(int i=0;i&lt;4;i++) { string s; cin &gt;&gt; s; for(int j=0;j&lt;4;j++) if(s[j]=='+') state|=1&lt;&lt;calcu(i,j); } for(int i = 0; i &lt; 1 &lt;&lt; 16; i++) { int step=0,backup=state; vector&lt;pair&lt;int,int&gt; &gt; res; for(int j=0;j&lt;4;j++) { for(int k=0;k&lt;4;k++) { if(i&gt;&gt;calcu(j,k)&amp;1) { transAll(j,k); res.push_back(make_pair(j,k)); step++; } } } if(!state) { cout&lt;&lt;step&lt;&lt;endl; for(int i=0;i&lt;res.size();i++) cout&lt;&lt;res[i].first + 1&lt;&lt;' '&lt;&lt;res[i].second + 1&lt;&lt;endl; } state=backup; res.clear(); } return 0;} 反思总结 01.vector &lt;pair&lt;int,int&gt; &gt; 的使用 02.位运算——异或","path":"2022/02/15/L_蓝桥杯/F_飞行员兄弟/","date":"02-15","excerpt":"","tags":[{"name":"枚举","slug":"枚举","permalink":"https://帆帆.icu/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"01背包","text":"题目来源 01背包 题目解析 状态表示 集合：只考虑前i件物品，且体积不超过j的选法的集合 属性：选法的价值的MAX 状态计算 划分： 不同点：对于当前最后有一个物品即第i个物品可以选可以不选 1234//集合一：不选择第i个物品f[i][j]=f[i-1][j]//集合二：不选择第i个物品f[i][j]=f[i-1][j-v[i]]+w[i] MAX 12//取两个集合最大值填入f[i][j]f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]) 完整代码 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int N = 1010;int f[N][N];int v[N], w[N];int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) { f[i][j] = f[i - 1][j - v[i]] + w[i]; } f[i][j] = max(f[i - 1][j], f[i][j]); } } cout &lt;&lt; f[n][m]; return 0;} 反思总结 无","path":"2022/02/15/L_蓝桥杯/L_零一背包/","date":"02-15","excerpt":"","tags":[{"name":"DP","slug":"DP","permalink":"https://帆帆.icu/tags/DP/"}]},{"title":"位运算","text":"置1 1#define setbit(x,y) x|=(1&lt;&lt;y) 置0 1#define clrbit(x,y) x&amp;=~(1&lt;&lt;y) 取反 1#define reversebit(x,y) x^=(1&lt;&lt;y) 查看 1#define getbit(x,y) ((x) &gt;&gt; (y)&amp;1)","path":"2022/02/15/Z_杂七杂八/W_位运算/","date":"02-15","excerpt":"","tags":[{"name":"位运算","slug":"位运算","permalink":"https://帆帆.icu/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"带分数","text":"题目来源 带分数 题目解析 01.直接对a,b,c暴力枚举也可以写 02.对分式变形 b = n * c - a * c ,这样只用枚举a和c 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int N = 20;bool sta[N], temp[N];int n, res;bool check(int a, int c){ int b = n * c - a * c; if (!a || !b || !c) return false; memcpy(temp, sta, sizeof sta); while (b) { int t = b % 10; b /= 10; if (temp[t]||t==0) return false; //确保t!=0 temp[t] = true; } for (int i = 1; i &lt;= 9; i++) { if (!temp[i]) return false; } return true;}void dfs_c(int u, int a, int c){ if (u &gt;= 10) return; if (check(a, c)) res++; for (int i = 1; i &lt;= 9; i++) { if (!sta[i]) { sta[i] = true; dfs_c(u + 1, a, c * 10 + i); sta[i] = false; } }}void dfs_a(int u, int a){ if (a &gt;= n) return; //a必然小于n if (a) dfs_c(u, a, 0); for (int i = 1; i &lt;= 9; i++) { if (!sta[i]) { sta[i] = true; dfs_a(u + 1, a * 10 + i); sta[i] = false; } }}int main(){ cin &gt;&gt; n; dfs_a(0, 0); cout &lt;&lt; res &lt;&lt; endl; return 0;} 反思总结 01.记录状态的sta数组也可以用一个int的state替代，这样不用恢复现场，在遍历时也方便点 02.对a搜索树的叶节点上再对c搜索 03.要确保第一次dfs_a() 时return条件为 a&lt;n","path":"2022/02/14/L_蓝桥杯/D_带分数/","date":"02-14","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"}]},{"title":"翻硬币","text":"题目来源 翻硬币 题目解析 01.这种题目不要乱想，手动模拟即可 02.ooo——&gt;oox这种情况不会出现 完整代码 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main(){ string s1 , s2; int ans = 0; cin &gt;&gt; s1&gt;&gt;s2; for(int i=0;i&lt;s1.size();i++) { if(s1[i]!=s2[i]) { s1[i+1]='o'+('*'-s1[i+1]);//忽略第i个硬币的反转，因为对后面没有影响 ans++; } } cout&lt;&lt;ans; return 0;} 反思总结 01.反转相邻两个硬币时，其实可以忽略第一个 02.反转可以用（A &lt;–&gt; B）：T=‘A’+(‘B’-T)","path":"2022/02/14/L_蓝桥杯/F_翻硬币/","date":"02-14","excerpt":"","tags":[{"name":"模拟","slug":"模拟","permalink":"https://帆帆.icu/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"递归实现组合型枚举","text":"题目来源 递归实现组合型枚举 题目解析 01.每层函数选一个数字，for循环每次的起始位置不断后移 02. S——选择的数、U——已选个数、State——选数状态 完整代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int n, k;void dfs(int s,int u,int state){ if (u == k) { for (int i = 0; i &lt; n; i++) if (state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for (int i = s; i &lt; n; i++) dfs(i+1, u + 1, state | 1 &lt;&lt; i);}int main(){ cin &gt;&gt; n &gt;&gt; k; dfs(0,0,0); return 0;} 反思总结 01.最关键的就是随着函数往下递 for 循环会后移起始位置 02.如果每次for都 i=0开始，那么就是随机选&lt;=3个数","path":"2022/02/13/L_蓝桥杯/D_递归实现组合型枚举/","date":"02-13","excerpt":"","tags":[{"name":"递归","slug":"递归","permalink":"https://帆帆.icu/tags/%E9%80%92%E5%BD%92/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"}]},{"title":"费解的开关","text":"题目来源 费解的开关 题目解析 01.如果用BFS代码很长，时间大概在1.5S左右 02.本题可以用递推的方法, 0行——4行 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;char map[5][5];const int INF = 0x3f3f3f3f;int dx[] = { 0,-1,1,0,0 }, dy[] = { 0,0,0,-1,1 };void turn(int x, int y){ for (int i = 0; i &lt; 5; i++) { int tx = x + dx[i]; int ty = y + dy[i]; if (tx &gt;= 0 &amp;&amp; tx &lt; 5 &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; 5) map[tx][ty] ^= 1; }}int work(){ int ans = INF; //枚举第一行的按法 for (int k = 0; k &lt; 1 &lt;&lt; 5; k++) { int res = 0; char temp[5][5]; memcpy(temp, map, sizeof map); //按第一行 for (int i = 0; i &lt; 5; i++) { if (k &gt;&gt; i &amp; 1) { turn(0, i); res++; } } //递推 for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 5; j++) { if (map[i][j] == '0') { turn(i + 1, j); res++; } } } bool is_successful = true; //判断最后一行 for (int i = 0; i &lt; 5; i++) { if (map[4][i] == '0') { is_successful = false; break; } } //更新最小值 if (is_successful) ans = min(res, ans); memcpy(map, temp, sizeof temp); } //返回最小值 if (ans &gt; 6) return - 1; return ans;}int main(){ int n; cin &gt;&gt; n; while (n--) { for (int i = 0; i &lt; 5; i++) cin &gt;&gt; map[i]; cout &lt;&lt; work() &lt;&lt; endl; } return 0;} 反思总结 01.连成一块的数字需要用字符数组保存 02.使用C语言的memcpy函数就不要用string数组 03.异或数字1不仅对数字1和0管用，对字符1和0也管用","path":"2022/02/13/L_蓝桥杯/F_费解的开关/","date":"02-13","excerpt":"","tags":[{"name":"递推","slug":"递推","permalink":"https://帆帆.icu/tags/%E9%80%92%E6%8E%A8/"}]},{"title":"递归实现指数型枚举","text":"题目来源 递归实现指数型枚举 题目解析 01.数据范围：1≤n≤15（n&lt;=30），所以可以使用递归,2的n次方 02.抛弃使用数组记录选择的数字，使用int 型数state的比特位记录 03.二叉搜索树 04.看与——&amp;、置或 ——| 完整代码（一） 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int n;void dfs(int k,int state){ if (k == n) { for (int i = 0; i &lt; n; i++) { if (state &gt;&gt; i &amp; 1) //看state的第i位是否为1，为1则输出 cout &lt;&lt; i + 1 &lt;&lt; \" \"; } cout &lt;&lt; endl; return; } dfs(k + 1, state); dfs(k + 1, state | 1 &lt;&lt; k); //state的第k位置为1}int main(){ cin &gt;&gt; n; dfs(0, 0); return 0;} 完整代码（二） 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int N = 20;bool state[N];int n;void dfs(int k){ if (k == n+1) { for (int i = 1; i &lt;= n; i++) { if (state[i]) cout &lt;&lt; i &lt;&lt; ' '; } cout &lt;&lt; endl; return; } state[k] = true; dfs(k + 1); state[k] = false; dfs(k + 1);}int main(){ cin &gt;&gt; n; dfs(1); return 0;}","path":"2022/02/11/L_蓝桥杯/D_递归实现指数型枚举/","date":"02-11","excerpt":"","tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://帆帆.icu/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"递归","slug":"递归","permalink":"https://帆帆.icu/tags/%E9%80%92%E5%BD%92/"}]},{"title":"递归实现排列型枚举","text":"题目来源 递归实现排列型枚举 题目解析 01.因为是全排列，所以我们需要用数组记录选入的数，一个state记录转状态 02.选完之后我们需要恢复原来的状态，dfs经典的回溯模型 完整代码（一） 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;const int N=15;int a[N],book[N];int n;void dfs(int step){ if(step&gt;n) { for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;' '; cout&lt;&lt;endl; return; } for(int i=1;i&lt;=n;i++) { if(!book[i]) { a[step]=i; book[i]=1; dfs(step+1); book[i]=0; //回溯 } } return;}int main(){ cin&gt;&gt;n; dfs(1); return 0;} 完整代码（二） 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 15;int a[N], n;void dfs(int k, int state){ if (k == n) { for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; endl; return; } for (int i = 0; i &lt; n; i++) { if (!(state &gt;&gt; i &amp; 1)) { a[k] = i+1; dfs(k + 1, state | (1 &lt;&lt; i)); } }}int main(){ cin &gt;&gt; n; dfs(0, 0); return 0;}//状态写dfs函数的参数里面就不费事写回溯了，原调函数会保留数据","path":"2022/02/11/L_蓝桥杯/D_递归实现排列型枚举/","date":"02-11","excerpt":"","tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://帆帆.icu/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"递归","slug":"递归","permalink":"https://帆帆.icu/tags/%E9%80%92%E5%BD%92/"}]},{"title":"简单斐波那契","text":"题目来源 简单斐波那契 题目解析 01.使用数组打表递推 02.递归函数现算 03.递归+剪枝 完整代码（一） 1234567891011121314151617//打表#include&lt;iostream&gt;using namespace std;int main(){ int n; cin&gt;&gt;n; int f[50]; f[1]=0; f[2]=1; for(int i=3;i&lt;=50;i++) f[i]=f[i-1]+f[i-2]; for(int i=1;i&lt;=n;i++) cout&lt;&lt;f[i]&lt;&lt;\" \"; return 0;} 完整代码（二） 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main(){ int n; cin&gt;&gt;n; int a=0; int b=1; for(int i=1;i&lt;=n;i++) { cout&lt;&lt;a&lt;&lt;' '; int t=a+b; a=b;b=t; } return 0;}","path":"2022/02/11/L_蓝桥杯/J_简单斐波那契/","date":"02-11","excerpt":"","tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://帆帆.icu/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"递归","slug":"递归","permalink":"https://帆帆.icu/tags/%E9%80%92%E5%BD%92/"},{"name":"打表","slug":"打表","permalink":"https://帆帆.icu/tags/%E6%89%93%E8%A1%A8/"}]},{"title":"闫氏DP分析法","text":"整体思路 01背包问题 题目：01背包问题 状态表示 集合：只考虑前i件物品，且体积不超过j的选法的集合 属性：选法的价值的MAX 状态计算 划分： 不同点：对于当前最后有一个物品即第i个物品可以选可以不选 1234//集合一：不选择第i个物品f[i][j]=f[i-1][j]//集合二：不选择第i个物品f[i][j]=f[i-1][j-v[i]]+w[i] MAX 12//取两个集合最大值填入f[i][j]f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]) 完整代码 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int MAX = 1010;int n, m;int f[MAX][MAX];int v[MAX], w[MAX];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) { f[i][j] = f[i - 1][j - v[i]] + w[i]; } f[i][j] = max(f[i][j], f[i - 1][j]); } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 优化写法 12345678910111213141516171819202122//优化f[i][j]、v[i]、w[i]#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int dp[N];int v, w;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; v &gt;&gt; w; for (int j = m; j &gt;= v; j--) dp[j] = max(dp[j], dp[j - v] + w); } cout &lt;&lt; dp[m]; return 0;}","path":"2022/02/09/S_算法与数据结构/S_算法/DP/Y_闫氏DP分析法/","date":"02-09","excerpt":"","tags":[{"name":"DP","slug":"DP","permalink":"https://帆帆.icu/tags/DP/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"双向排序","text":"题目来源 双向排序 题目解析 解题思想 01.如果暴力使用sort进行排序，则会时间超限 02.所以我们首先要对指令输入进行分类压缩 03.压缩完毕后观察指令执行的形式和特点，设计算法 第一个指令的压缩 原因：因为原本的序列为升序，所以第一条指令必须是降序才会起效（top的大小为指令的条数，初始值为0） 12345678910int p, q;cin &gt;&gt; p &gt;&gt; q;if (p == 0){ }else if (top)//只有先输入0指令才会输入1指令{ } 连续相同指令的压缩 原因：因为连续相同的指令执行的总过程等效于长度最大的那条指令 12while (top &amp;&amp; stk[top].first == 0) q = max(stk[top--].second, q); 更长的降指令，对前面两条指令的抵消的压缩 例子：12345 （0，3）——32145 （1，2）——31245 （0，4）——43215 12while (top &gt;= 2 &amp;&amp; stk[top - 1].second &lt;= q) top -= 2; Note：不难发现压缩之后的指令，无论是对前缀进行升排序还是对后缀进行降排序，这两类的指令执行的长度都越来越小，我们可以发现含有这种趋势的指令在执行时，某些数按规律的被固定住，例子如下： 所以我们借用left和right和k（k=n）去固定这些数 123456789101112int left = 1, right = n, k = n; for (int i = 1; i &lt;= top; i++) { if (stk[i].first == 0) while (left &lt; right&amp;&amp;right&gt;stk[i].second) ans[right--] = k--; else while (left &lt; right &amp;&amp; left&lt;stk[i].second) ans[left++] = k--; if (left &gt; right) break; } 对于指令执行完之后，数未能全部固定完的情况，如上图1未固定（虽然在正确位置），我们要再做相同的处理 123456if (top % 2) while (left &lt;= right) ans[left++] = k--; else while (left &lt;= right) ans[right--] = k--; 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAX 100005using namespace std;const int N = 100010;pair&lt;int, int&gt;stk[N];int main(){ int n, m, ans[MAX]; cin &gt;&gt; n &gt;&gt; m; int top = 0; while (m--) { int p, q; cin &gt;&gt; p &gt;&gt; q; if (p == 0) { while (top &amp;&amp; stk[top].first == 0) q = max(stk[top--].second, q); while (top &gt;= 2 &amp;&amp; stk[top - 1].second &lt;= q) top -= 2; stk[++top] = { 0,q }; } else if (top) { while (top &amp;&amp; stk[top].first == 1) q = min(stk[top--].second, q); while (top &gt;= 2 &amp;&amp; stk[top - 1].second &gt;= q) top -= 2; stk[++top] = { 1,q }; } } int left = 1, right = n, k = n; for (int i = 1; i &lt;= top; i++) { if (stk[i].first == 0) while (left &lt; right&amp;&amp;right&gt;stk[i].second) ans[right--] = k--; else while (left &lt; right &amp;&amp; left&lt;stk[i].second) ans[left++] = k--; if (left &gt; right) break; } if (top % 2) while (left &lt;= right) ans[left++] = k--; else while (left &lt;= right) ans[right--] = k--; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; \" \"; return 0;}","path":"2022/01/20/S_算法与数据结构/S_算法/Math/S_双向排序/","date":"01-20","excerpt":"","tags":[{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"杨辉三角","text":"题目来源 杨辉三角形 题目解析 数学性质 01.杨辉三角一般构造方法——第一纵行和右斜行均为1，其余位置的数等于上面数加上上面的数的前一个数的和 02.杨辉三角左右对称，并且中间位置的数最大 03.如果抛去右半边，杨辉三角每一个数的大小等于一个组合数 C（ R , K），K为斜行数、R为横行数，每一斜行的第一个数对应的组合数R = 2 x K 04. 若 n 存在于杨辉三角中，那么n一定会在n行或n行之前出现 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;int n;LL C(int a, int b){ LL res = 1; for (int i = a, j = 1; j &lt;= b; i--, j++) { res = res * i / j; if (res &gt; n) return res; // 大于n已无意义，防爆LL } return res;}bool find(int k){ int l = 2 * k; int r = max(n, l); while (l &lt; r) { int m = l + r &gt;&gt; 1; if (C(m, k) &gt;= n) r = m; else l = m + 1; } if (C(r, k) == n) { cout &lt;&lt; 1ll * (1+r)*r/2 + k + 1 &lt;&lt; endl; return true; } return false;}int main(){ cin &gt;&gt; n; for (int i = 16;; i--) { if (find(i)) break; } return 0;} 关键点 01.使用组合数构造杨辉三角，使用二分法查找 02.计算组合数时防爆LL，边乘边除，并且时时判断是否大于n","path":"2022/01/20/S_算法与数据结构/S_算法/Math/Y_杨辉三角/","date":"01-20","excerpt":"","tags":[{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"},{"name":"二分","slug":"二分","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E5%88%86/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Dijkstra","text":"Dijkstra算法——单源最短路径算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define MAX 50#define INF 0x3f3f3f3fint n, m;int map[MAX][MAX];int book[MAX], dis[MAX];void dijkstra(int s){ //初始化 book[s] = 1; for (int i = 1; i &lt;= n; i++) dis[i] = map[s][i]; for (int i = 1; i &lt;= n; i++) { //找最小并标记 int temp = INF, t = s; for (int j = 1; j &lt;= n; j++) { if (book[j] == 0 &amp;&amp; dis[j] &lt; temp) { t = j; temp = dis[j]; } } if (t == s) return; book[t] = 1; //t的邻接点借东风 for (int j = 1; j &lt;= n; j++) if (book[j] == 0 &amp;&amp; map[t][j] != INF) if (dis[j] &gt; dis[t] + map[t][j]) dis[j] = dis[t] + map[t][j]; }}int main(){ memset(map, 0x3f, sizeof(map)); cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; map[a][b] = min(map[a][b], c); } int s; cin &gt;&gt; s; map[s][s] = 0; dijkstra(s); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; dis[i] &lt;&lt; \" \"; return 0;}//测试样例//5 8//1 2 2//1 3 5//2 3 2//2 4 6//3 4 7//4 3 2//3 5 1//4 5 4//1//输出//0 2 4 8 5 Summary： 01.初始化 02.找最小 03.借东风","path":"2021/12/09/S_算法与数据结构/S_算法/T_图论/Dijkstra算法/","date":"12-09","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"SP","slug":"SP","permalink":"https://帆帆.icu/tags/SP/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://帆帆.icu/tags/Dijkstra/"}]},{"title":"Heavy Transportation","text":"题目来源 Heavy Transportation Note：某条路的最大承重量其实是该条路的最小边","path":"2021/12/07/S_算法与数据结构/S_算法/T_图论/Heavy Transportation/","date":"12-07","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"SP","slug":"SP","permalink":"https://帆帆.icu/tags/SP/"}]},{"title":"灌溉","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#define MAX 101using namespace std;int map[MAX][MAX];int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; int t; cin &gt;&gt; t; while (t--) { int a, b; cin &gt;&gt; a &gt;&gt; b; map[a][b] = 1; } int k; cin &gt;&gt; k; while (k--) { int t = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (map[i][j] == t) { if (i - 1 &gt;= 1) map[i - 1][j] = t+1; if (i + 1 &lt;= n) map[i + 1][j] = t+1; if (j - 1 &gt;= 1) map[i][j - 1] = t+1; if (j + 1 &lt;= m) map[i][j + 1] = t+1; } } } t++; } int cnt = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (map[i][j]) cnt++; } cout &lt;&lt; cnt; return 0;}","path":"2021/12/06/L_蓝桥杯/G_灌溉/","date":"12-06","excerpt":"","tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://帆帆.icu/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"删除字符","text":"123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main(){ string s; int n; cin &gt;&gt; s &gt;&gt; n; while(n--) { for (int i = 0; i &lt; s.size(); i++) { if (s[i] &gt; s[i + 1]) { s.erase(i, 1); break; } } } cout &lt;&lt; s; return 0;}","path":"2021/12/06/L_蓝桥杯/S_删除字符/","date":"12-06","excerpt":"","tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://帆帆.icu/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"朴素贝叶斯性别判定系统","text":"引言 根据朴素贝叶斯分类算法而作的性别判定系统 数据来源：网络爬虫 链接: train.txt 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;vector&gt;#include&lt;locale&gt;#include&lt;fstream&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;comutil.h&gt;#include&lt;windows.h&gt;#pragma comment(lib,\"comsuppw.lib\")#define MAX 21000using namespace std;double p1, p0; //先验概率double sum1, sum0; //总和统计int statMan[MAX]; //统计数组(男)int statWoman[MAX]; //统计数组(女)vector &lt;wstring&gt; manName; //Name向量(男)vector &lt;wstring&gt; womanName; //Name向量(女)void interFace(); //界面void duceDate(); //引入数据void statDate(); //统计数据void handleDate(); //处理数据double pMan(wchar_t w); //概率函数double pWoman(wchar_t w); //概率函数void judgeDate(string s); //判断数据wstring converse(const string&amp; s); //string转wstringint main(){ duceDate(); statDate(); interFace(); return 0;}void interFace(){ cout &lt;&lt; \"系统加载中\"; for (int i = 1; i &lt;= 3; i++) { Sleep(700); cout &lt;&lt; \".\"; } cout &lt;&lt; endl &lt;&lt; \"系统加载成功！\\n\" &lt;&lt; endl; cout &lt;&lt; \"****************************\" &lt;&lt; endl; cout &lt;&lt; \"* 朴素贝叶斯性别预测系统 *\" &lt;&lt; endl; cout &lt;&lt; \"* 输入姓名预测性别 *\" &lt;&lt; endl; cout &lt;&lt; \"* 输入over程序结束 *\" &lt;&lt; endl; cout &lt;&lt; \"****************************\" &lt;&lt; endl; string s = \"hello\"; while (s != \"over\") { cout &lt;&lt; \"--&gt; \"; cin &gt;&gt; s; if (s == \"over\") break; else judgeDate(s); } cout &lt;&lt; \"已结束,下次再见\" &lt;&lt; endl;}void duceDate(){ for (int i = 1; i &lt; MAX; i++) statMan[i] = statWoman[i] = 1; ifstream f(\"train.txt\"); if (!f.is_open()) cout &lt;&lt; \"The file can not open\" &lt;&lt; endl; else { int temp; string name; int gender; for (int i = 1; i &lt;= 12000; i++) { f &gt;&gt; temp &gt;&gt; name &gt;&gt; gender; if (gender == 1) manName.push_back(converse(name)); else womanName.push_back(converse(name)); } } f.close();}void statDate(){ p1 = manName.size() * 1.0 / (manName.size() + womanName.size()); p0 = womanName.size() * 1.0 / (manName.size() + womanName.size()); //统计(男) for (int i = 0; i &lt; manName.size(); i++) { int len = manName[i].size(); if (len == 1) { wchar_t t = manName[i][0]; statMan[t - 19967]++; } else { wchar_t t1 = manName[i][0]; wchar_t t2 = manName[i][1]; statMan[t1 - 19967]++; statMan[t2 - 19967]++; } } //统计(女) for (int i = 0; i &lt; womanName.size(); i++) { int len = womanName[i].size(); if (len == 1) { wchar_t t = womanName[i][0]; unsigned short c = t; statWoman[c - 19967]++; } else { wchar_t t1 = womanName[i][0]; wchar_t t2 = womanName[i][1]; unsigned short c = t1; statWoman[c - 19967]++; c = t2; statWoman[c - 19967]++; } } for (int i = 1; i &lt; MAX; i++) { sum1 += statMan[i]; sum0 += statWoman[i]; }}double pMan(wchar_t w){ unsigned short c = w; return statMan[c - 19967] / sum1;}double pWoman(wchar_t w){ unsigned short c = w; return statWoman[c - 19967] / sum0;}void judgeDate(string s){ wstring ws = converse(s); int wsl = ws.size(); if (wsl == 2) { double pa = pMan(ws[1]) * p1; double pb = pWoman(ws[1]) * p0; cout &lt;&lt; \"概率：\" &lt;&lt; \"男 \" &lt;&lt; pa / (pa + pb) &lt;&lt; \" 女 \" &lt;&lt; pb / (pa + pb); cout &lt;&lt; \"\\n结果：\"; if (pa &gt;= pb) cout &lt;&lt; \"男\\n\"; else cout &lt;&lt; \"女\\n\"; } else { double pa = pMan(ws[1]) * pMan(ws[2]) * p1; double pb = pWoman(ws[1]) * pWoman(ws[2]) * p0; cout &lt;&lt; \"概率：\" &lt;&lt; \"男 \" &lt;&lt; pa / (pa + pb) &lt;&lt; \" 女 \" &lt;&lt; pb / (pa + pb); cout &lt;&lt; \"\\n结果：\"; if (pa &gt;= pb) cout &lt;&lt; \"男\\n\"; else cout &lt;&lt; \"女\\n\"; }}wstring converse(const string&amp; s){ _bstr_t t = s.c_str(); wchar_t* pwchar = (wchar_t*)t; wstring result = pwchar; return result;} 实例测试结果 样本数据：男50人，女50人 男性预测正确率：90.23% 女性预测正确率：81.33% 综合正确率：85.78% 感谢名录 Do_r Arthur 阳 Ttkx Mine`♡ 沫殇心 Tremor. 太阳 yeyu 不如去散步 偷偷藏不住 有一点疼的小耳朵 ECCENTRIC salad days 桃李不言 Maid Kneel 程喻吖 咿呀咿呀呦","path":"2021/11/09/S_实践项目/P_朴素贝叶斯模型/","date":"11-09","excerpt":"","tags":[{"name":"概率论","slug":"概率论","permalink":"https://帆帆.icu/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"汇编语言","text":"寄存器 以下寄存器均为对编程人员可见的可编程寄存器 通用寄存器 数据寄存器 AX——累加（Accumulate） BX——基地址（Base） CX——计数（Count） DX——存数据（Date） 特殊寄存器 SP——堆栈指针（Stake） BP——基地址指针（Base） SI——源变址（Source Index） DI——目的变址（Destination Index） 专用寄存器 标志寄存器 FLAGS 指令指针寄存器 IP 段寄存器 CS——代码段（Code） CS指明代码段基地址 : IP(指令指针)——当前执行的指令位置 DS——数据段（Date） 没有特定的寄存器存储数据段的偏移地址，需要自己计算（EA） SS——栈段（Stack） SS指明栈段基地址 : SP(堆栈指针)——指明栈顶 ES——附加段（Extra） 存储器 字节，字和双字 8位——字节 16位——字 32位——双字 编号规则 从0开始，直到最大 eg：IA-32（0-2的32次方（0-FFFFFFFF）H） 4个二进制位对应一个16进制位 每一个地址指向一个字节，如下图： MMU MMU——Memory Manage Unit（存储管理单元）、 逻辑地址和物理地址 逻辑地址=段基地址：偏移地址 同一个存储单元的不同表示方式，逻辑地址利于我们去编程。 逻辑地址——MMU——物理地址 指令分类 执行性语句：标号:硬性助记符 操作数，操作数;注释 说明性语句：名字 伪指令助记符 参数,参数, …;注释 执行性语句类似于高级语言中的赋值等（完成具体的功能） 说明性语句类似于高级语言中的定义变量，结构体，类等（说明一些属性） 操作数 （一）立即数——无地址含义，只表示运算数据（请立即给我一个数，不要墨迹） （二）寄存器——运算的数据放在CPU的寄存器组里（最快！！！） （三）存储器——运算的数据放在内存里 [ ] 表示偏移地址 寻址方式 立即寻址 指令直接给出，适用于立即数 寄存器寻址 大多指的是通用寄存器 存储器寻址 使用——[偏移地址] Note:存储器操作数的字长本身不确定，其字长取决于指令中另外一个寄存器的操作数，或通过其他方式指定字长 直接寻址 12mov ax,[1200H] ;默认使用Date Segment段基地址mov ax,ex:[1200H] ;重设为Extra Segment段基地址 间接寻值 使用间址寄存器BX，BP，SI，DI（只有也只能有这4个） 12mov bx,1200Hmov ax,[bx] BX，SI，DI——默认在数据段 BP——默认在堆栈段 另：SP——始终指向栈顶 相对寻址 1mov ax,[bx+date]; 12345mov ax,2000H ;2000H送给axmov ds,ax ;ax送给dxmov bx,1200H ;1200H送给Bxmov al,[bx+5] ;在Date Segment基地址偏移1205H个单位的字节送给al寄存器;其他写法5[bx]、[bx]5 主要用于一维数组的操作，常数作为表头地址，间址寄存器作为相对地址 基址、变址寻址 基址寄存器的内容（BX，BP） + 变址寄存器的内容（SI，SP） BX——默认在数据段 BP——默认在堆栈段 123mov si,1100H ;si==1100Hmov bx,si ;bx==1100Hmov ax,[bx+si] ;DateSegment段偏移2200H和2201H个单位的地址所指向的字节的数送给ax寄存器 基址、变址、相对寻址 基址寄存器的内容（BX，BP） + 变址寄存器的内容（SI，SP）+位移量 主要用于二维数组的操作，表头地址，行地址和列地址 123mov di,1100Hmov bp,dimov al,[bp][di]5;StackSegment段偏移2205H个单位的地址所指向的字节的数送给al寄存器 隐含寻址 1mul bl ;equal: ax=al*bl 寻址方式 Test 1234567mov ax,bx ;寄存器寻址mov dl,80H ;立即寻址mov ax,VAR[bx][si] ;6000H*16+0050H+0800H+00A0H=608F0H(5位)mov al,'B' ;立即寻址mov di,es:[bx] ;2000H*16+0800H=20800Hmov dx,[bp] ;1500H*16+1200H=16200Hmov bx,20H[bx] ;6000H*16+0800H+20H=60820H 物理地址，偏移地址，基地址针对均为存储器，寄存器的地址是固定的 指令 数据传送类 MOV 12345678mov al,bx ;错误：字长不等mov ax,10H ;正确：立即寻址mov ax,bx ;正确：寄存器寻址mov ax,[bx]05H ;正确：存储器寻址mov ds,1000H ;错误：段寄存器不可以用立即寻址赋值mov [bx][bp],bx ;错误：目的操作数寻址方式错误（bx和bp为不同的两个段）mov dx,09H ;正确：立即数的字长是不确定的，可以补0mov [1200],[si] ;错误：mov指令不能同时为存储器c eg: 将(*)的ASCⅡ码2AH送入内存数据段1000H开始的100个单元中 12345678mov di 1000H ;起始位置mov cx,64H ;100D=64Hmov al,'*' ; *AGAIN: mov [di],al inc di ;di++ dec cx ;cx-- jnz AGAIN ;cx!=0 则继续 hlt ; PUSH、POP 特点：先进后出、以字（双字节，16位）为单位 note：操作数可以是寄存器或存储器的两个单元，但不能是立即数 单操作数指令的操作数一定不能是立即数！！！ 交换指令 (XCHG REG,MEM/REG) note: 两个操作数必须至少有一个寄存器，不允许使用段寄存器 12xchg ax,bx ;寄存器交换xchg [2000],cl ;内存与寄存器交换 查表指令(XLAT) 表头：BX 偏移量：AL 值返回对象：AL 将BX+AL所指单元的内容送给AL 字位扩展指令 note：将有符号数的符号位扩展到高位 123456cbw ;将al扩展到ax;最高位为1，执行后ah为FFH(有符号数);最高位为0，执行后ah为00Hcwd ;将ax扩展到dx,ax;最高位为1，执行后dx为FFFFH;最高位为0，执行后dx为0000H 上述指令只针对有符号数有意义，无符号数拓展只需要在高位加足够多的0即可！！！ 地址传送指令 LEA：取偏移地址（近地址指针,当前段内） LDS、LES、远地址指针（用于多模块设计） 将变量的16位偏移地址写入到目标寄存器 12mov al,i ;将i变量的内容送给allea bx,i ;将i变量的地址送给bx note: lea是取地址，mov是取值 eg: 1234567891011lea si,MEM1lea di,MEM2mov cl,50AGAIN: mov al,[si]mov [di],alinc siinc didec cljnz AGAINHLT 标志传送指令 FLAGS是一个16位的寄存器，一共有9个标志位，其余7个是空闲位 LAHF：将FLAGS低8位内容(含5个标志位)装入AH SAHF：将AH的内容写回到FLAGS低8位中 输入输出指令 端口：除了在CPU内部有寄存器组，接口处也有寄存器组，为了区分，接口里面的寄存器叫做端口，CPU可以直接读写端口 指令格式： IN acc，PORT（port：端口地址） OUT PORT，acc（port：端口地址） acc——al/ax（绝对不能是ah） 12345in ax,80H;从80H端口读入一个16bit数据到ax（端口地址8位）mov dx,2400Hin al,dx;从2400H端口读入一个8bit数据（端口地址16位）out 35h,ax;将ax的值写到35H端口中去out ax,35H;格式错误！！！ note：端口地址有两种，其取决于机器的物理架构，地址处对应的寄存器存放的数据可以是8bit也可以是16bit，和地址无关。 算术运算类 加 add：普通相加(影响FLAGS) 123456789mov al,78H;01111000add al,99h;10011001;al:00010001;cf(carry):最高为0，所以向前有进位、cf=1(进位标志);sf(senior):最高位为0、sf=0 (最高位标志);af(assist):第3位到第4位有进位、af=1 (半加进位标志);zf(zero):结果不为0、zf=0 (为0判断);pf():1个数为偶数、pf=1;of(overflaw):次高位进位状态和最高位进位状态相同、of=0 adc：带进位相加(影响FLAGS) add会使进位丢失，adc会保留进位到下一位上去 Note:运算前cf的值是随机的一个值，需要先清0，防止干扰运算CLC inc：加1指令(只影响5个状态位，不影响cf) 1inc ax;ax++、inc：increase 减 SUB：普通减法(影响FLAGS) SBB：带借位减法(影响FLAGS) DEC：减1指令(只影响5个状态位，不影响cf) 1234567 mov bl,2NEXT1: mov cx,0FFFFH;最高位为A-F时需要在前面加0，便于编译器识别NEXT2: dec cx jnz NEXT2 ;ZF=0转到NEXT2 dec bl jnz NAXT1 ;ZF=0转到NEXT1 HLT ;暂停 NEG：取负数（negative） 操作数为0时，cf=0，其他情况，cf=1（有借位） Note：0减去一个负数——对负数取补码，故又名（求补指令） CMP(比较指令，仅影响标志位) 1234cmp ax,bx;无符号;ax&gt;bx、无借位、cf=0;ax&lt;bx、有借位、cf=1;ax=bx、cf=1、zf=1 123cmp ax,bx;有符号;of AND sf 状态相同、ax&gt;bx;of AND sf 状态不同、ax&lt;bx 乘 和加减运算指令的区别：对于有符号数和无符号数有不同的助记符号 1.MUL（无符号数）、采用隐含寻址 123MUL OPRD;oprd为8位——al*oprd——&gt;ax;oprd为16位——ax*oprd——&gt;dxax 例子： 1mul byte ptr[bx];在ds段偏移地址位bx的单元（一个byte）和al相乘 2.IMUL（有符号数）、采用隐含寻址 除 1.DIV（无符号数）（被除数是除数的双倍字长） 123DIV OPRD;oprd为8位——ax/oprd——&gt;al：商、ah：余数;oprd为16位——dxax/oprd——&gt;ax：商、dx：余数 2.IDIV（有符号数） 实例 12345mov si,1200hmov word ptr[si],8765h;数据段偏移si的地方写入一个字mov al,[si];数据段偏移si的地方的内容（一个字节）写给alinc simul byte pty[si];65h*87h——ax=3543h 1234mov si,1200hmov word ptr[si],8765hmov ax,[si];数据段偏移si的地方的内容（一个字）写给axmul word ptr[si];8765h*8765h——&gt;dx=479bh、ax=add9h 总结： 01.使用存储器操作数时，需要用PTR声明操作字长 02.乘积是乘数的双倍字长，被除数是除数的双倍字长 逻辑运算类 01.非运算要求操作数不能是立即数 02.除\"非运算\"，其余指令的执行都会影响除AF外的标志 03.无论执行结果如何，都会使标志位OF=CF=0 04.非运算不影响任何标志位 与 123and bl,[si];按位相与，写回bland al,0fh;al高四位清零，写回aland ax,ax;操作数不变，使of和cf清零 12345678 mov dx,3f8h ;端口大于一个字节使用dx寄存器again: in al,dx ;从dx端口读入一个字节 and al,02h ;和00000010与（逻辑乘） jz again ;al为0继续循环，否者跳出循环 mov dx,38fh mov ax,data out dx,ax 或 12or cl,0fh;cl高4不变，cl低4为1（逻辑加）or ax,ax;ax不变，使of=cf=0 eg：将一个2进制的9，变成字符9 1234;二进制的9：00001001;字符9的ASCii码:30hmov al,9 ;00001001or al,30h ;00111001-39h 非 1not byte ptr[bx];数据段偏移bx地方的一个字节内容取反再收送回去 异或 Note：相同为0，不同为1（可以看成相减取绝对值） 12xor bl,80h;对bl的最高位取反、80h:10000000xor ax,ax;对ax清零 测试指令 Note：Test的目的在于修改标志位，不计算的 And 1test al,01h;al和01h相与(and)，但不修改al的值 移位指令 非循环移位Shift 逻辑：最高/低位移到CF标志位，高/低位补0，不保留符号 01.逻辑左移(无符号数) 12shl oprd,1 ;为1时可以直接给出shl oprd,cl;&gt;=1时必须用cl 02.逻辑右移(无符号数) 12shr oprd,1 ;为1时可以直接给出shr oprd,cl;&gt;=1时必须用cl 举个例子： 123mov al,68hmov cl,2shr al,cl 算术：最高/低位移到CF标志位，高/低位补符号位，保留符号 01.算术左移(有符号数、补码) 12sal oprd,1 ;为1时可以直接给出sal oprd,cl;&gt;=1时必须用cl 02.算术右移(有符号数、补码) 12sar oprd,1 ;为1时可以直接给出sar oprd,cl;&gt;=1时必须用cl 总结： 当运算要求保留符号位时，采用算术移位，否者采用逻辑移位，算术移位和逻辑移位都是线性的。 循环移位Rotate 不带进位位的循环: 最高位和最低位来回循环，最高/低位放入CF标志位 01.左移 1rol 02.右移 1ror 带进位位的循环:CF参与循环移位，构成大的循环 01.左移 1rcl 02.右移 1rcr 应用： 1.测试某些位的状态 2.高低位交换 123mov al,12hmov cl,4ror al,cl;12h——&gt;21h 3.与非循环移位指令一起组成32位或更长字长数的移位 例题如下： Addendum：压缩BCD码使用4位二进制数表示一位十进制数 1234567891011121314151617181920lea si,m1lea di,m2mov ch,4Next: mov al,[si] mov bl,al and al,0fh;高4位清零 or al,30h;高4位变成3，相当于加30h mov [di],al inc di mov al,bl mov cl,4 shr al,cl or al,30h mov [di],al inc di inc si dec ch jnz Next hlt 串操作指令 Note：SI——Source、DI——Direction 重复前缀 01.无条件重复 REP——当cx!=0时REP后的指令将继续重复执行 02.条件重复 REPE(REPZ)——CX!=0 and zf=1（相等——Equal相减为0——Zero） REPNE(REPNZ)——CX!=0 and zf=0（不相等——NE，相减不为0——NZ） MOVSB和CMPSB 12345678910111213lea si,mem1les di,mem2mov cx,200cld ;clear df(destination flag清0)rep movsb;按字节传送cldrepe cmpsbjz stopdec simov al,[si]mov bx,alstop: hlt SCASB和SCASW 123456789101112mov di,2000hmov bx,dimov cx,10 ;查询次数mov al,'A' ;待查询字符CLD ;从上往下搜索repne scasb ;不相等（不等于零）时继续扫描jz Found ;相等（等于0）时跳出循环（jz——judge zf）Found: dec di mov data2,di inc di sub di,bx;查询次数为di LODSB和LODSW 12lodsb ;al&lt;--[ds:si]lodsw ;ax&lt;--[ds:si] 一般不加重复前缀 STOSB和STOSW 12stosb ;al--&gt;[es:si]stosw ;ax--&gt;[es:si] 程序控制指令 转移指令 01.JMP（段内、无条件） Note：地址放在寄存器中（16bit） 1jmp lable;段内直接转移 1234mov bx,1200hjmp bx ;段内间接转移mov bx,1200jmp word ptr[bx] 02.JMP FAR(段间、无条件) Note：地址放在内存中（32bit） 1jmp dword ptr[bx];CS：高字节、IP：低字节 03.条件转移指令 例题： 123456789101112131415xor al,almov plus,almov minus,almov zero,almov cx,100cldcheck: lodsb or al,al js x1 jz x2 x0: inc plusx1: inc minusx2: inc zero 循环控制 过程调用 中断控制 续行符——\" \\ \" 汇编语言默认不区分大小写 执行结束——不等于—— 汇编结束 12345678;inc——increase;dec——decrease;jmp——jump;jc——jump carry;jnz——jump not zero(cx不为0跳转);jnc——jump not carry;lahf——lay low flags to ah;sahf—— masm有一个不成文的规定，那就是在定义完数据段后，所定义的变量均向后100h个单元，需要我们将ds段寄存器置位，在程序的start:后面加上如下指令： mov ax,data mov ds,ax 程序实例 一 向内存0:200-0:23F依次传送数据0-63（3FH） 12345678910111213141516171819date SEGMENTdate ENDScode SEGMENT ASSUME cs:code,ds:date start: mov ax,0 ;初始化段地址 mov ds,ax mov bx,200h ;初始化偏移地址 mov cx,64 ;循环64-1、共63次 mov dx,0 ;传入数据 C: mov [bx],dx inc dx inc bx Loop C mov ax,4c00h int 21hcode ENDS END start 二 编写code段代码，用push指令将a段中的word数据逆序存储到b段中 1234567891011121314151617181920212223assume cs:codecode SEGMENT a SEGMENT dw 1,2,3,4,5,6,7,8 a ENDS b SEGMENT dw 0,0,0,0,0,0,0,0 b ENDS start: mov ax,b ;初始化 mov ss,ax mov sp,16 mov ax,a mov ds,ax mov bx,0 mov cx,8 C: mov dx,word ptr [bx] push dx add bx,2 loop Ccode ENDS END start 补充 MOV 传送代名字项 12345678910111213date segment m1 db 'ABCDEF$'date endscode segment assume cs:code,ds:date start: mov ax,date mov ds,ax mov ax,m1+2 ;将m1+2地址指向的内容往后两个字节传给ax ;低给低、高给高code ends end start 数据段定义内容存放 12345date segment m1 db 'abcdefg';低——&gt;高:abcdefg ;只有db可以在一个''内合起来定义，其他的不可以合起来 m2 dw 'AB','CD','EF';低——&gt;高:BADCEFdate ends 数据段向寄存器传送内容 无论数段如何定义，始终低地址给低位，高地址给高位","path":"2021/11/01/B_编程语言/H_汇编/","date":"11-01","excerpt":"","tags":[{"name":"汇编","slug":"汇编","permalink":"https://帆帆.icu/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"归并排序","text":"核心思想 不断二分，直到分为一个最小单元，然后借助辅助数组进行并的操作。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;int temp[100];void merge(int a[], int left, int mid, int right){ for (int i = left; i &lt;= right; i++) temp[i] = a[i]; int i = left, j = mid + 1, k = left; while (k &lt;= right) { if (i &lt;= mid &amp;&amp; j &lt;= right) { if (temp[i] &lt;= temp[j]) a[k++] = temp[i++]; else a[k++] = temp[j++]; } else { if (j == right + 1) a[k++] = temp[i++]; else a[k++] = temp[j++]; } }}void mergeSort(int a[],int left,int right){ if (left &gt;= right) return; int mid = (left + right) / 2; mergeSort(a,left, mid); mergeSort(a, mid+1,right); merge(a, left, mid, right);}int main(){ int a[100], n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; mergeSort(a, 1, n); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i]&lt;&lt;' ';}","path":"2021/10/02/S_算法与数据结构/S_算法/P_排序/G_归并排序/","date":"10-02","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://帆帆.icu/tags/%E6%8E%92%E5%BA%8F/"},{"name":"归并","slug":"归并","permalink":"https://帆帆.icu/tags/%E5%BD%92%E5%B9%B6/"}]},{"title":"Learning How to Learn","text":"大脑的两种模式 专注模式和发散模式 这是两种完全不同的模式，就像硬币的两面，一次只能看见一个面。 学习困难的事情时我们需要在两种不同模式之间的来回切换，这样才能更好的学习。 面对拖延症 理论：当我们做不喜欢的事情时，会有神经上的不适感，但我们真的去做时，这种不适感会很快消失。 策略：1.定时25分钟 2.屏蔽会打扰你的事物 3.完全专注 4.小奖励😀 数理类学科为何更难学？ 原因：数理类学科往往伴随着抽象的的符号和定义，我们无法类比隐喻。 策略：熟能生巧，越是抽象的东西越要进行练习，练习加强形成的神经元模式，直到我们熟练掌握。 Note：在学习的时候我们需要拼命专注，就像举重练习一样，要拼尽全力，不能懒散。学习完毕后，我们需要适当的休息或者转移注意力到其他不那么耗脑力的事物上。 记忆的两种模式 工作记忆：及时的记忆模式，像一块模糊的黑板，有效容量为 4 长期记忆：像我们熟知的仓库一样。 策略：将工作记忆放到长期记忆的最好方法时间隔去重复工作记忆 例如：一个星期的一、二、三、五、七（Anki大法！！！） 睡眠对学习的重要性 睡眠可以清除我们脑中的毒素，使我们脑袋更清醒。 睡眠时，我们的前额叶皮质完全解放出来，这样就能让其加强我们的神经元模式。 是时候小睡一会了！！！ 类比的用处 学习一样新的事物时，可以与现实中的事物类比，这样便于我们更好的理解。 组块 1.专注 在你精神力强的时段屏蔽一切会干扰你的事情，拿出25min 2.理解 对于题解，我们不能太过深究某个细节，我们还要理解步骤之间的联系。即：为何进行这一步？ 3.练习 将你学到的东西运用起来，你要知道在哪里会用到他们。 一些小技巧 （一）阅读+回顾（反复） 回顾的同时加强了我们对知识的理解，切勿毫无理解就搭建思维导图，也不要低效地反复阅读。 Note：在常规条件外回顾会加强我们对材料的理解 （三）一种看待记忆的方式 组块化使我们大脑工作记忆的缓存被清理 （三）学习是对能力的错觉 看一眼答案就以为自己会了 对书籍做大量标记 Note：我们喜欢重读笔记或课本的原因是，这些行为不那么痛苦，会让我们有一种知识就在脑海中的错觉，只会自欺欺人。 应对策略：自测","path":"2021/09/30/Z_杂七杂八/Learning How to Learn/","date":"09-30","excerpt":"","tags":[{"name":"learn","slug":"learn","permalink":"https://帆帆.icu/tags/learn/"}]},{"title":"贝叶斯","text":"贝叶斯公式 公式造型： P(A|B): ‘|’ 表示given、存在前提的意思，P(A|B)指在B事件发生的条件下A事件发生的概率。 推理过程： (一) A problem about Steve (二)常常忽略的一点！！！ 在考虑概率的大小的同时，不能够感性的去判断，我们需要理性的去分析概率和什么有关系，常常会我们会忽略的一点是Librarian和Farmer的比例。 (三)将Librarian和Farmer的比例考虑在内 假设Librarian和Farmer的比例为1：20，假设有10名Librarian和20名Farmer。我们可以将一个正方形分成两部分来分别表示Librarian和Farmer，面积之比为1：20 (其实这就是先验概率) (四)考虑这两部分各自独立的概率 (五)完整公式 消去总人数 贝叶斯公式！！！ P(E)是更常见的写法，它表示在全体样本(210人)中符合我们要求的人(4+20)的概率。","path":"2021/09/29/S_数学/B_贝叶斯/","date":"09-29","excerpt":"","tags":[{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"},{"name":"概率论","slug":"概率论","permalink":"https://帆帆.icu/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"贝叶斯","slug":"贝叶斯","permalink":"https://帆帆.icu/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"}]},{"title":"插入排序","text":"核心思想 i扫描整个集合，借助j，不断将i位点的数插入到已排序的集合中 运用优势 对于部分有序的排序问题，插入排序的运行是线性的，速度非常快！ 完整代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main(){ int a[10], n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int t; for (int i = 1; i &lt;= n; i++)//i为已排序和未排序集合的分界点 { int j = i;//比较的起始位点 while (j &gt;= 2) { if (a[j] &lt; a[j-1])//不断和左边比较 { t = a[j]; a[j] = a[j-1]; a[j-1] = t; } j--; } } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; ' '; return 0;} 优化代码 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main(){ int a[10], n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 2; i &lt;= n; i++) { int j = i, t; while (j &gt;= 2&amp;&amp;a[j]&lt;a[j-1]) { t = a[j]; a[j] = a[j - 1]; a[j - 1] = t; j--; } } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i]&lt;&lt;' ';}","path":"2021/09/29/S_算法与数据结构/S_算法/P_排序/C_插入排序/","date":"09-29","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://帆帆.icu/tags/%E6%8E%92%E5%BA%8F/"},{"name":"插入","slug":"插入","permalink":"https://帆帆.icu/tags/%E6%8F%92%E5%85%A5/"}]},{"title":"快速排序","text":"基本思想 基准数的比较产生交换，基准数就位，递归 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;int a[100];void mySort(int left,int right){ if (left &gt;= right) return; int temp = a[left]; int i = left; int j = right; while (i != j) { while (j &gt; i) { if (a[j] &lt;= temp) break; j--; } while (i &lt; j) { if (a[i] &gt; temp) break; i++; } if (i &lt; j) { int t = a[i]; a[i] = a[j]; a[j] = t; } } a[left] = a[i]; a[i] = temp; mySort(left, i-1); mySort(i + 1, right);}int main(){ for (int i = 1; i &lt;= 10; i++) cin &gt;&gt; a[i]; mySort(1,10); for (int i = 1; i &lt;= 10; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; return 0;}","path":"2021/09/29/S_算法与数据结构/S_算法/P_排序/K_快速排序/","date":"09-29","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://帆帆.icu/tags/%E6%8E%92%E5%BA%8F/"},{"name":"快速","slug":"快速","permalink":"https://帆帆.icu/tags/%E5%BF%AB%E9%80%9F/"}]},{"title":"希尔排序","text":"核心思想 使用不同增量进行排序，使待排数组逐渐趋于有序，最终进行-1排序，其实就是插入排序，所以最终一定会得到正确的排序。 完整代码 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int main(){ int a[100], n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int h = 1; while (h &lt; n)//使用1、4、13、的增量 h = 3 * h + 1; h /= 3; while (h &gt;= 1) { for (int i = h + 1; i &lt;= n; i++)//h-sort { int j = i, t; while (j - h &gt;= 1)//防止越界 { if (a[j] &lt; a[j - h]) { t = a[j]; a[j] = a[j - h]; a[j - h] = t; } j -= h; } } cout &lt;&lt; h &lt;&lt; \"-sort\" &lt;&lt; endl; h /= 3; } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; ' '; return 0;} 更优代码 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int main(){ int a[10], n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int h = 1; while (h &lt; n) h = h * 3 + 1; h /= 3; while (h) { //h-sort for (int i = h + 1; i &lt;= n; i++) { int j = i, t; while (j &gt;= h + 1 &amp;&amp; a[j] &lt; a[j - h]) { t = a[j]; a[j] = a[j - h]; a[j - h] = t; j -= h; } } h /= 3; } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i]&lt;&lt;' ';}","path":"2021/09/29/S_算法与数据结构/S_算法/P_排序/X_希尔排序/","date":"09-29","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://帆帆.icu/tags/%E6%8E%92%E5%BA%8F/"},{"name":"希尔","slug":"希尔","permalink":"https://帆帆.icu/tags/%E5%B8%8C%E5%B0%94/"}]},{"title":"选择排序","text":"核心思想 i扫描整个集合，将未排序的集合的最小最值和 i 位点交换,形成已排序集合 完整代码 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main(){ int a[10], n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int t; for (int i = 1; i &lt; n; i++)//i为已排序和未排序集合的分界点 { int k = i;//用来寻找未排序集合的最小值的下标(初始化为i、即未排序集合起点) for (int j = i; j &lt;= n; j++)//未排序集合（j到n） { if (a[k] &gt; a[j]) k = j; } t = a[i]; a[i] = a[k]; a[k] = t; } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; ' '; return 0;}","path":"2021/09/29/S_算法与数据结构/S_算法/P_排序/X_选择排序/","date":"09-29","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://帆帆.icu/tags/%E6%8E%92%E5%BA%8F/"},{"name":"选择","slug":"选择","permalink":"https://帆帆.icu/tags/%E9%80%89%E6%8B%A9/"}]},{"title":"积极心理学（三）","text":"有关自助书籍的真相 （一）《思考致富》《秘密》《正面思考的力量》等书籍过分强调了思考创造现实，创造成功这一事实。但这只是等式的一半，成功除了相信，还离不开辛勤的工作。如果仅仅依靠相信，言过其实，效果甚微，甚至造成毁灭性的后果。 （二）苏格兰皇家银行《正面思考》短片 不可忽视的精神力量 论据 安慰剂效应 失效的吐根 过敏植物 精神力量强大的科学依据 理论 动力+重构一致性是我们精神力量强大大原因。 重构图式和外界信息一致性的4种方式 ①更新图式（积极/消极） ②忽视外界信息（积极/消极） ③主动验证，寻找符合我们图式的证据（积极/消极） ④创造新的现实（积极/消极） 论据 （一）Roger Banister相信他能跑进4分钟以内，干劲十足，最终④创造了新的现实。 （二）爱迪生对失败5000次用主观解读来①更新他的图式并④创造新的现实 （三）宣传人类在六十年代末登月④创造新的现实 Note：成功别无他法，我们都是从失败走向成功，相信自己可以成功并干劲十足地去创造属于我们的新的现实 目标设定上的区别 悲观主义者 乐观主义者 短期 现实 不现实 长期 现实 现实 解释 （1）悲观主义者信念低下，所以他们消极地面对他们的目标，最终失败了他会向人们解释，他本来就说过了他做不好，偶尔的成功他也会认为是运气使然，所以从短期还是长期来看他们的目标一直很现实。 （2）乐观主义者拥有很高的信念于是设立很高的目标，从短期来看他的目标很不现实，但他从失败中学习，一次又一次，认为自己会做到，并辛勤劳动，最终他实现了他的目标，所以从长期来看他们的目标又是现实的 实践 试着像乐观者一样思考，设立短期不现实而长期现实的目标，从失败中学习，创造属于你的现实。","path":"2021/09/19/J_积极心理学/3/","date":"09-19","excerpt":"","tags":[{"name":"心理学","slug":"心理学","permalink":"https://帆帆.icu/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"图","text":"邻接矩阵 无向图 1234567891011121314151617#include&lt;iostream&gt;#define MAX 10000using namespace std;int map[MAX][MAX];int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b; cin &gt;&gt; a &gt;&gt; b; map[a][b] = 1; map[b][a] = 1; } return 0;} 有向图 12345678910111213141516#include&lt;iostream&gt;#define MAX 10000using namespace std;int map[MAX][MAX];int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b; cin &gt;&gt; a &gt;&gt; b; map[a][b] = 1; } return 0;} 带权图 123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAX 10000using namespace std;int map[MAX][MAX];int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; memset(map, 0x3f, sizeof(map)); while (m--) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; map[a][b] = c; } return 0;} 邻接表 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;typedef struct note{ int date; note* next;}Note,*Link;void init(Link p,int n){ for (int i = 1; i &lt;= n; i++) *(p + i) = { i,NULL };}void add(Link s,int a, int b){ Link t = new Note; *t = { b,(s + a)-&gt;next }; (s + a)-&gt;next = t;}int main(){ int n; cin &gt;&gt; n; Link p = new Note[n+1]; init(p,n); while (n--) { int a, b; cin &gt;&gt; a &gt;&gt; b; add(p, a, b); } return 0;} 链式向前星 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int maxn = 10000;const int maxe = 20000;//头节点、边序号、边数组int head[maxn], cnt;struct Edge{ int to, w, next;}edge[maxe];void add(int u, int v, int w){ edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;}int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; while(m--) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } for (int i = head[1]; i; i = edge[i].next) { } return 0;}","path":"2021/09/19/S_算法与数据结构/S_数据结构/S_树、图/T_图/","date":"09-19","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://帆帆.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","permalink":"https://帆帆.icu/tags/%E5%9B%BE/"}]},{"title":"Catch That Cow","text":"题目来源 Catch That Cow 题目解析 BFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAX = 1000010;int book[MAX], d[MAX];//d[b]表示的是n点到b点所需的时间int n, k;void bfs(){ queue&lt;int&gt; q; book[n] = 1; d[n] = 0; q.push(n); while (!q.empty()) { int u = q.front(); q.pop(); if (u == k) { cout &lt;&lt; d[k]; return; } int x; x = u + 1;//往右走 if (x &gt;= 0 &amp;&amp; x &lt;= 100000 &amp;&amp; book[x] == 0) { d[x] = d[u] + 1; book[x] = 1; q.push(x); } x = u - 1;//往左走 if (x &gt;= 0 &amp;&amp; x &lt;= 100000 &amp;&amp; book[x] == 0) { d[x] = d[u] + 1; book[x] = 1; q.push(x); } x = u * 2;//穿越 if (x &gt;= 0 &amp;&amp; x &lt;= 100000 &amp;&amp; book[x] == 0) { d[x] = d[u] + 1; book[x] = 1; q.push(x); } }}int main(){ cin &gt;&gt; n &gt;&gt; k; bfs(); return 0;} DFS（n到k） 1234567891011121314151617181920212223242526272829303132//时间超限#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, k, m = 0x3f3f3f3f;void dfs(int x,int step){ if (step &gt; m) return; if (x == k) { m = min(m, step); return; } if (x == 0) dfs(x + 1, step + 1); if (x &lt; k) { dfs(x + 1, step + 1); dfs(x - 1, step + 1); dfs(x * 2, step + 1); } if (x &gt; k) dfs(k, step + (x - k));}int main(){ cin &gt;&gt; n &gt;&gt; k; dfs(n,0); cout &lt;&lt; m; return 0;} DFS（k到n） 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, k;int dfs(int t){ if (t &lt;= n) return min(n - t, 2 * t - n + 1); if (t % 2 == 0) return min(dfs(t / 2) + 1, t - n); else return min(min(dfs(t + 1) + 1, dfs(t - 1) + 1), t - n);}int main(){ cin &gt;&gt; n &gt;&gt; k; if (n &gt;= k) cout &lt;&lt; n - k; else { if (n == 0)//先向前走一步 { n = 1; cout &lt;&lt; dfs(k) + 1; } else cout &lt;&lt; dfs(k); } return 0;}","path":"2021/09/19/S_算法与数据结构/S_算法/T_图论/Catch That Cow/","date":"09-19","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"BFS","slug":"BFS","permalink":"https://帆帆.icu/tags/BFS/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Ideal Path","text":"题目来源 Ideal Path AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;#define maxn 100001#define maxe 200001#define inf 0x7fffffffint n, m, flag = 1;queue&lt;int&gt; q1, q2, q3;int book1[maxn], h[maxn];//头节点、边序号int head[maxn], cnt;struct Edge{ int to, c, next;}e[maxe];void add(int u, int v, int c){ e[++cnt].to = v; e[cnt].c = c; e[cnt].next=head[u]; head[u] = cnt;}void bfs1()//逆向标高{ int u; h[n] == 0; q1.push(n);//初始化 book1[n] = 1; while (!q1.empty()) { u = q1.front(); q1.pop(); for (int i = head[u]; i; i = e[i].next) { if (book1[e[i].to] == 0) { h[e[i].to] = h[u] + 1; q1.push(e[i].to); book1[e[i].to] = 1; } } } cout &lt;&lt; h[1] &lt;&lt; endl;}void bfs2(){ //初始化 q1.push(1); q2.push(inf); int u, c; while (!q1.empty()) { int minc = inf - 1; while (!q1.empty())//寻找每一层的最小值 { u = q1.front(); c = q2.front(); q1.pop();q2.pop(); if (minc &gt; c) { while (!q3.empty()) q3.pop(); minc = c; } if (minc == c) q3.push(u);//将最近临接点入队 } if (minc != inf - 1) { if (flag) flag = 0; else cout &lt;&lt; \" \"; cout &lt;&lt; minc; } while (!q3.empty()) { int u = q3.front(); q3.pop(); for (int i = head[u]; i; i = e[i].next) if (h[e[i].to] == h[u] - 1) { q1.push(e[i].to); q2.push(e[i].c); } } for (int i = head[u]; i; i = e[i].next) if (h[e[i].to] == h[u] - 1) { q1.push(e[i].to); q2.push(e[i].c); book2[e[i].to] == 1; } }}int main(){ cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); } bfs1(); bfs2(); return 0;} 代码解析 问题一：为什么要反向标记高度？ 答：逆向标高是为了正向求解做铺垫，在正向求解时往高度减一的方向进行，其截至条件就是高度为0即n的位置，因为高度为0的点只有一个，所以这样可以确保正向求解一定会到达n点。","path":"2021/09/19/S_算法与数据结构/S_算法/T_图论/Ideal Path/","date":"09-19","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"BFS","slug":"BFS","permalink":"https://帆帆.icu/tags/BFS/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"积极心理学（二）","text":"准许为人 理论 人类情绪就像万有引力一样，都是客观存在的，我们无法改变！ 论据 忽视万有引力造飞船 大骗局（告诉他人自己很好） AA运动宣言 实践 一、ABC理论：我们无条件接受自己的情绪，但是不代表我们屈服于自己的情绪，在行为上我们选择道德的做法！ 二、冥想：在情感上感受准许为人的含义。链接：1:04:35 人们总是按你做的做 理论 人们总是按你做的做，而非说的做！ 论据 一、圣雄甘地吃太多糖 二、将手放在脸颊上的测试 三、成为你想在世界上想看到的改变！（Nice） 实践 以身作则：不要告诉别人该怎么办，你应该以身作则先办到那件事再说！当你办到那件事情后，你就成为了榜样。传播快乐的最好方法是争取自己的快乐，教育孩子诚实的方法是自己先要诚实，我们需要当一个务实的理想主义者，理想和善意是远远不够的，最重要的是我们的行动！ 信念即自我完成预言 理论 信念激发我们本身存在的潜能，潜能被激发，我们更容易实现我们要做的事情，信念成了自我实现的预言！ 论据 Roger Banister——梦想一英里——突破心理界限 皮格马利翁效应 —— 期望越高，成绩越好。 快速迸发者测试 —— 老师对学生的信念 对老师的信念，对员工的信念！ 人们怎样便怎样待他，他便还是那样的人，一个人能够或应该怎样便怎样待他，他便会成为能够怎样或应当怎样的人 —— 歌德 实践 我相信我可以完成这件事情，我相信他能完成这件事情，我的信念预言着事情最终被我实现！！！ 情境的力量 理论 情境的力量是巨大的！！！ 论据 权力服从研究 监狱实验——犯人和狱警两种角色的情境 75岁以上的男人在20年前的环境中生活——心理和生理年龄减小 飞行模拟器中视力变化 映射实验 实践 通过映射构建有意识的和潜意识的积极环境 在身边放置爱人的照片，喜欢的画作等 放置喜爱的名人名言 阅读喜欢的书籍，积极的电影，听喜欢的音乐(不要当作背景音乐，要仔细专注地去听，感受你的喜爱之情) 将自己平时生活所说的消极词汇换为积极词汇","path":"2021/09/17/J_积极心理学/2/","date":"09-17","excerpt":"","tags":[{"name":"心理学","slug":"心理学","permalink":"https://帆帆.icu/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"C语言","text":"引言 本文主要记录一些 C 语言的细节问题 EOF 对于 scanf(\"%d%d\", &amp;a, &amp;b); 而言 如果 a 和 b 都被成功读入，那么 scanf 的返回值就是 2 如果只有a 被成功读入，返回值为 1 如果 a 和 b 都未被成功读入，返回值为 0 如果遇到错误或遇到 end of file，返回值为 EOF，且返回值为 int 型 当读文件操作时，遇到文件结束位置或读数据出错均会返回 EOF C 语言中所有的输入输出操作均是按读文件的思想来设计的，或者说是文件操作的一种特例，如 getchar（）就是 fgetc (stdin) 的一个宏 文件操作 大佬的博客 - CSDN 内存分配 123456Cint* f(){ int *p=malloc(100); return p;} malloc 为动态分配，p 为静态分配（用变量名） f（）函数运行结束后，malloc 分配的 100字节的空间依旧存在，而变量p 则不存在了（编译器可能会保存一次） 字符串 在 C语言中这样会报错，但在 Java 中可以这么用 C语言的正确写法 12345678910C#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ char ch[20] = \"China\"; strcpy(ch, \"Lisi\"); printf(\"%s\", ch); return 0;} 结构体与指针 1234567891011Cstruct note{ int date; char name[20];};struct note Std;printf(\"%d\",std.date);struct note *p=&amp;Std;printf(\"%d\",p-&gt;date);//p-&gt;date == (*p).date == Std.date 无名结构体 一、编译器对无名结构体的处理是随机生成一个不重复的变量名 二、无类型名的结构体变量在声明结构体时就得定义（后续去用的话不知道名字） 三、因为名字是随机的，所以不可以相互赋值，例子如下： 12345678Cstruct{ int x;}a;struct{ int x;}b;b = a; //报 incompatible type error 四、结构体的指针也无法使用，例子如下： 1234567891011C#include&lt;stdio.h&gt;struct{ int x;}a, * pa;void main(){ pa-&gt;x = 1; //报 pa 是 NULL printf(\"%d\", pa-&gt;x);} 五、用 typedef 处理后可以正常使用，例子如下： 1234567891011121314C#include&lt;stdio.h&gt;typedef struct{ int x;}a, * pa;void main(){ a b; pa l; l = &amp;b; b.x = 1; printf(\"%d\", l-&gt;x);} 六、对于多个内部相同属性的结构体可以用无名结构体方式处理，更方便。 scanf和gets scanf 遇到空格停止读取，gets 遇到回车停止读取 字符串截取函数 1234567891011121314151617181920212223242526C#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define MAX 100//p：待截取的字符串头指针//s：截取的起始位点//n：截取长度char* Intercept_String(char *p, int s, int n){ char* h; int j = 0; h = (char*)malloc((n + 1) * sizeof(char)); for (int i = s; i &lt; n + s; i++) { *(h+j)= *(p+i); j++; } *(h + j) = '\\0'; return h;}int main(){ char ch[MAX]; gets_s(ch); printf(\"%s\", Intercept_String(ch, 2, 3)); return 0;} 0x3f3f3f3f 0x3f3f3f3f 的十进制是 1061109567，是 109 级别的，而一般场合下的数据都是小于 109 的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形 memset 相关链接 memset 实现原理是根据字节来设置的 对于int而言有四个字节我们这样memset 1memset(map, 0x3f, sizeof(map)); 随机数 1.头文件 stdlib.h 2.设置随机数种子(Set Rand) srand(unsigned int(time(NULL))) 3.Rand函数 rand()%100【0-99】 rand()%100+1【1-100】 4.实例：洗牌 123456789101112131415161718#include&lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;int main(){ int a[10], n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; srand((unsigned int)time(NULL)); int r = rand()%i+1; int t; t = a[r]; a[r] = a[i]; a[i] = t; } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i]&lt;&lt;' ';} New用法 异或的用法 1234567891011#include&lt;stdio.h&gt;int main(){ int a, b; scanf_s(\"%d%d\", &amp;a, &amp;b); a = a ^ b; b = a ^ b; a = a ^ b; printf(\"%d %d\", a, b); return 0;} printf补零输出 123456789101112#include&lt;stdio.h&gt;int main(){ int a = 1; //宽度已知 printf(\"%02d\\n\", a); //宽度未知 int b = 2; int l = 3; //宽度 printf(\"%0*d\",l,b); return 0;}","path":"2021/09/16/B_编程语言/C语言/","date":"09-16","excerpt":"","tags":[{"name":"C语言","slug":"C语言","permalink":"https://帆帆.icu/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Python","text":"环境搭建 Python 提取码：ed8m 基础语法 注释 12345# 单行注释''' 多行注释''' Hello World 1print(\"Hello World\") 输出 1234567891011121314151617181920212223#1a=10print(\"a=\",a)#print()自动换行#2age=18print(\"我的年龄是%d岁\"%age)#3s=\"China\"print(\"我的年龄是%d岁、我的国籍是%s\"%(age,s))#4print(\"我的名字是%s、我来自%s\"%(\"非洲小白孩\",\"非洲\"))''' %(替换对象1,替换对象2...)'''#5print(\"你好！%s，我来自%s，我叫%s，今年%d岁\"%(\"HAQI\",\"China\",\"FanFan\",18))#6print(\"www\",\"baidu\",\"com\",sep=\".\")#Separate隔开、用 . 隔开#7print(\"hello \",end=\"\")#为\"\"时不换行print(\"world\")#8print(\"-\"*30) 输入 12345678#1password = int(input(\"please input password：\"))#\" \"内为提示语print(\"The password is\",password)print(type(password))#输入的内容默认的类别是字符串or数字#2a = int('10231')print(type(a)) 随机数 123import randoma = random.randint(1,10)print(a) if判断语句 12345678910111213141516#1a = 100b = 101if a&gt;b: print('a &gt; b')#必须要有缩进，且同一范围内必须对齐else : print(\"a &lt; b\")#2score = 90if score &gt;= 90: print(\"优秀\")elif score&gt;70 and score&lt;90: print(\"一般\")else: print(\"不及格\") for循环语句 12345678910111213141516171819202122232425262728293031323334353637383940414243#1for i in range(5): print(i,end=\" \")print(\"\")for i in range(1,5): print(i,end=\" \")print(\"\")for i in range(1,6,2): print(i,end=\" \")print(\"\")#1for c in \"China\": print(c,end=\"\")print(\"\")for d in [\"adas\",\"dsadad\",\"sdawd\"]: print(d,end=\" \")print(\"\")a = [\"dada\",\"dawd\",\"dwad\"]for i in a: print(i,end=\" \")print(\"\")a = [\"dada\",\"dawd\",\"dwad\"]for i in range(1,len(a)): print(\"下标:\",i,a[i])print(\"\")#3i=0while i&lt;5: print(i) i+=2sum = 0m = 100while m: sum+=m m-=1else: print(\"求和完毕1-100的和为：\",sum)#4for i in \"Room\": if i==\"o\": pass else: print(i) 九九乘法表 123456789101112131415for i in range(1,10): for j in range(1,10): if j&lt;=i: print(i,\"*\",j,\"=\",i*j,end=\"\\t\") print(\"\")i = j = 1while i&lt;=9: j=1 while j&lt;=9: if j&lt;=i: print(i,\"*\",j,\"=\",i*j,end=\"\\t\") j+=1 i+=1 print(\"\") 字符串 123456789101112131415161718192021222324252627282930313233343536373839404142#1word = 'Hello'sentence = \"这是一个句子\"paragraph = ''' 嘿嘿 这是一个段落 哈哈哈'''print(word)print(sentence)print(paragraph)#2str1 = \"I'm a student\"#双引号内单引号失去作用print(str1)#str2 = 'I'm a student'会报错str2 = 'I\\'m a student'#标识该 ' 无索引字符串地作用print(str2)#str3 = \"Jack said \"I like you\"\"#会报错str3 = \"Jack said \\\"I like you\\\"\"print(str3)str4 ='Jack said \"I like you\"'#单引号内双引号失去作用print(str4)#3string = \"China\"print(string[0])print(string[0:3])#默认跨度为1print(string[0:3:1])print(string[0:4:2])#跨度为2print(string[:3])#第三单元之前的(不包含3)print(string[3:])#第三单元后的（包含3）#区间访问时左闭右开！！！#4s = \"你好\"print(s+\"，成都！\")#“+”表示字符串相连接print(s*3)#5print(\"hello\\nworld\")print(r\"hello\\nworld\")#r使转义字符失效 列表 定义列表 1234567891011#定义一个空的列表nameList = []#定义非空列表nameList = [\"小张\",\"小王\",\"小李\"]print(nameList[0])#混合类型nameList = [1,\"China\",89.2]print(type(nameList[0]))print(type(nameList[1]))print(type(nameList[2]))print(\"\") 遍历列表 12345678910#遍历print(\"开始For循环遍历nameList\")nameList = [\"小张\",\"小王\",\"小李\"]for name in nameList: print(name)print(\"开始While循环遍历nameList\")i = 0 while i&lt;len(nameList): print(nameList[i]) i+=1 增加元素 1234567891011121314151617181920212223242526272829#增加单个元素nameList = [\"小张\",\"小王\",\"小李\"]print(\"------增加前------\")for name in nameList: print(name,end = \" \")print(\"\")nameTemp = input(\"请输入add的元素：\")nameList.append(nameTemp)print(\"------增加后------\")for name in nameList: print(name,end = \" \")print(\"\")PYTHON#增加一个是列表的元素a = [1,2]b = [3,4]a.append(b)print(a)PYTHON#拓展列表（合并列表）a = [1,2]b = [3,4]a.extend(b)print(a)PYTHON#插入元素（原有元素被挤到下一位）a = [1,2]a.insert(1,\"China\")#1位置插入 Chinaprint(a) 删除元素 1234567891011121314151617181920212223242526#删除指定位置元素a = [1,\"China\",3,4]del a[2]print(a)PYTHON#弹出尾部元素a = [1,\"China\",3,4]a.pop()print(a)PYTHON#删除指定内容的元素a = [1,\"China\",3,4]a.remove(1)print(a)PYTHON#clear:清空列表nameList = [\"小张\",\"小王\",\"小李\"]print(\"-----删除前------\")for name in nameList: print(name,end = \" \")print(\"\")nameList.extend(2)print(\"------删除后------\")for name in nameList: print(name,end = \" \")print(\"\") 修改元素 1234#指定下标赋值即可a = [1,\"China\",3,4]a[1] = 2print(a) 查询元素 123456789#注意数据类型有数字和字符串a = [1,\"China\",3,4]temp = input(\"请输入您要查找的数据:\")if temp in a: print(temp,\"存在\")elif int(temp) in a: print(temp,\"存在\")else: print(temp,\"不存在\") 12345678910#输出列表中某一元素的下标myList = ['a','b','c','d']print(myList.index('a'))#我们也可以精确范围myList = ['a','b','c','d']print(myList.index('a',0,2))#如果找不到元素就会报错myList = ['a','b','c','d']print(myList.index('a',1,2))#ValueError: 'a' is not in list 123#统计元素个数myList = ['a','b','c','d','a']print(myList.count('a')) 12345678910111213141516171819202122#反转和排序myList = ['a','b','c','d','a']myList.reverse()print(myList)myList.sort()print(myList)myList.sort(reverse=True)#排序后反转（降序）print(myList)#办公室分配import randomoffices = [[],[],[]]names = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\"]for name in names: index = random.randint(0,2) offices[index].append(name)i = 0while i&lt;3: print(\"%d号办公室有%d人，分别为 \"%(i+1,len(offices[i])),end=\"\") for name in offices[i]: print(name,end=\" \") print(\"\") i+=1 元组 定义元组 123456tup = ()print(type(tup))tup = (50)#等价于tup = 50print(type(tup))#&lt;class 'int'&gt;tup = (50,)print(type(tup))#&lt;class 'tuple'&gt; 元组的相关操作 12345678910111213141516#可遍历，查找，整体删除tup = (1,2,3,4,5)for i in tup: print(i)print(tup[3])print(tup[-1])if 4 in tup: print(\"Yes\")tupx =tup+tupprint(tupx)tupx.sort()#AttributeError: 'tuple' object has no attribute 'sort'print(tupx)tup = (1,2,3,4,5)del tupprint(tup)#NameError: name 'tup' is not defined 字典 定义 1d = {\"name\":\"吴彦祖\",\"age\":18}#键+值 访问和查找 12345678#访问d = {\"name\":\"吴彦祖\",\"age\":18}print(d[\"name\"])print(d[\"age\"])print(d[\"geand\"])#键不存在时直接访问会 KeyError: 'geand'#判断某个key是否存在print(d.get(\"grand\"))#显示：Noneprint(d.get(\"grand\",0))#显示：0（初始化为0） 增加键值对 1234key = input(\"请输入新的键：\")p = input(\"请输入新键的值：\")d[key] = pprint(d[key]) 删除键值对 12345678#deld = {\"name\":\"吴彦祖\",\"age\":18}del d[\"name\"]print(d[\"name\"])#KeyError: 'name'#cleard = {\"name\":\"吴彦祖\",\"age\":18}d.clear()print(d)#打印结果为 {} 修改键值对 123d = {\"name\":\"吴彦祖\",\"age\":18}d[\"name\"]=\"哈哈\"print(d) 查找与遍历键值对 123456789101112d = {\"name\":\"吴彦祖\",\"age\":18}print(d.keys())#['name', 'age']print(d.values())#['吴彦祖', 18]print(d.items())#[('name', '吴彦祖'), ('age', 18)]、每一项是一个元组#遍历d = {\"name\":\"吴彦祖\",\"age\":18}for key in d.keys(): print(key)for value in d.values(): print(value)for key,value in d.items(): print(\"key=%s value=%s\"%(key,value)) 在列表中也有类似的表达： 1234567891011names = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\"]for i,x in enumerate(names):#对names枚举 print(i,x)# 1 B# 2 C# 3 D# 4 E# 5 F# 6 G# 7 H# 8 I 集合 12345#去重myList = [1,2,2,3,4]s = set(myList)print(s) 网络爬虫 Request库的使用 基本语法 123456import requestsurl = 'http://www.santostang.com/'r = requests.get(url) print(r.encoding) #编码格式print(r.status_code) #状态码（200==成功）print(r.text) #内容 url定制 123456import requestsurl = 'http://www.santostang.com/'keyDict = {'k1':'v1','k2':'v2'}r = requests.get(url,params=keyDict)print(r.url)print(r.text) headers定制 1234567import requestsurl = 'http://www.santostang.com/'headers={'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62' }r = requests.get(url,headers=headers)print(r.status_code) POST请求 1234567import requestsurl = 'http://www.santostang.com/'submitData = {'k1':'v1','k2':'v2'}r = requests.post(url,data = submitData)print(r.status_code)print(r.text)#注意是data！！！ DouBan 123456789101112131415161718import requestsfrom bs4 import BeautifulSoupbaseUrl = 'https://movie.douban.com/top250?start='headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62', 'Host':'movie.douban.com'}movieList = []for i in range(0,10): link = baseUrl+str(i*25) r = requests.get(link,headers=headers) print('The status of page',str(i+0),'is',r.status_code) soup = BeautifulSoup(r.text,'lxml') divList = soup.find_all('div',class_='hd') for t in divList: movie = t.a.span.text.strip() movieList.append(movie)print(movieList)","path":"2021/09/16/B_编程语言/Python/","date":"09-16","excerpt":"","tags":[{"name":"Python","slug":"Python","permalink":"https://帆帆.icu/tags/Python/"}]},{"title":"机器编码","text":"引言 本片文章关于计算机是如何二进制存储数字的 为什么选择二进制？ 大多数人类文明选择了十进制 (因为手指头有 10 根，最开始人们计数是靠手去数的) 但也有例外，玛雅人采用 20 进制服务于天文历法的计数，楔形文字采用 60 进制 计算机在发明以后，需要选用一种进制来储存数据 当时选有 10 进制的，3 进制的，8 进制的，但事实证明 2 进制才是最不容易出错的 其实电路中电压的高低，是电容上电荷的多少，是磁盘上的磁化程度，光盘上的蚀刻程度，光纤中发光二极管或者 “小灯泡” 的亮度 —— 而这些全都是（几乎）连续的物理量，并没有什么天然的 “只能取两个值” 的属性。 计算机选择 2 进制只是因为相对而言 2 进制更不容易出错 机器编码 原码 例如我们要存储一个十进制整数3 3——00000011（我们可以用 1byte（字节）去存储） 在 C语言中给一个整数分配 4个byte，所以 3 在 C 语言分配的内存中表示如下 3——00000000 00000000 00000000 00000011 一个字节占 8 位，我们所说的 32 位 / 64 位系统指的是系统能够一次性处理多少位 32 位即 4 个 byte，4 个 byte 可以表示 2 的 32 次方 = 4294967296（bit）个地址，约 4G 64 位即 8 个 byte，8 个 byte 可以表示 2 的 64 次方 = 4294967296 的 32 次方（bit）大于 1 亿 GB 接下来我们考虑一个 8位的系统 数值有正负之分，计算机就用一个数的最高位存放符号 (0为正,1为负) 3 表示为 00000011，最高位为 0 表示其为正数 -3 表示为 10000011，最高位为 1 表示其为负数 那么 1byte 能表示数值的范围为 (1~127 到 -127~-1, )（最高位 0 到 1）共 256 个 表示完了后，我们用该编码加减运算的时候出现了问题，如下：假设字长为 8bits 1-1=1+(-1)=0 00000001b + 10000001b = 10000010b (结尾用字母 b 或者 B 表示二进制数) 但 10000010b=-2 显然是不正确 我们称这种编码为原码，原码是人脑最容易理解和计算的表示方式. 但原码的加减法运算不能够顺利进行，由此发明了补码 补码 在上述描述中用源码做减法结果是不对的，我们抛开原码这一概念 假如 1+x=0 00000001b+x=00000000b 解得x=11111111b，其实 11111111b就是 -1，但是我们并不能很好的识别出来 我们需要一个过程把 -1 的原码，转换成 11111111b 即可，对于 - 1 而言，原码为 10000001b，现在我们要做的就是，把 10000001b 转换成 11111111b，我们仔细发现最高位是不变的，其余位置反置，然后再加一就得到了 11111111b 了 我们在仔细看这个过程 第一步：最高位不变，其余反置 (取反) 第二步：加上 00000001b 总结：负数原码和补码之间转换（除符号位外）取反加一 我们通过观察得出取反加一这个规律，下面我们通过推导得到这个结论 0 减去一个数的补码 = 该数相反数的补码，以至于这两个数的补码进行运算时和为 0 补码补全了原码无法减法的不足，也补全了负数运算的空缺，并且其表示的负数和正数是一一互补的，为什么叫补码呢，就像数学中的补角一样，30 度的补角是 150 度二者的和是 180 度，180 度是一个在角度上的一个常见数，是一个凑整的状态。 我们再回想一下刚刚那个公式，00000000 其实也是一个凑整的状态，只是进位的 1 丢失了 (原本是 100000000)，你可以理解为补码去表示的一对正负数，表示正数的补码和负数的补码是互补的，二者之和是一个凑整的状态！ 观察以下式子： 00000000b=11111111b+00000001b 00000000b-x =11111111b-x+00000001b (代换) =(11111111b-x)+00000001b 其实括号内就是那个取反操作 括号右侧加00000001 其实就是加1 反码其实是将原码转化为补码的一个桥梁，取反是一个操作 特殊的一对补码： 10000000+10000000=00000000 00000000+00000000=00000000 上述两个补码与自身互补，转成原码后，又因为 1 表示负 我们用 1000000 表示 - 128，没有 + 128，用 00000000 表示 0 不分正负 8bit 可以表示带符号的数的范围: 1～127，-1～-127，0 和 -128 机器编码总结 正数：原码 = 反码 = 补码 负数：反码 = 最高位不变其余反置、补码 = 源码的反码 + 1 反码其实和源码的关系不大，只是一种得到补码的手段 对于有符号的数而言，假如是 n位的，则可以表示 -2的n-1次方，无 +2 的 n-1 次方 (有负无正) END","path":"2021/09/16/J_计算机/J_机器编码/","date":"09-16","excerpt":"","tags":[{"name":"二进制","slug":"二进制","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"机器编码","slug":"机器编码","permalink":"https://帆帆.icu/tags/%E6%9C%BA%E5%99%A8%E7%BC%96%E7%A0%81/"}]},{"title":"积极心理学（一）","text":"积极心理学 引言 《积极心理学》是一门以健康模型为核心的课程，相对于传统的疾病模型，积极心理学更注重于对个人积极性的培养，而并不是直接面对心理疾病。你生病了，只是因为你的生活还不够健康，你不去追求那些使你健康的东西，积极心理学可以帮助我们达到那种充满激情，紧张的生活状态。 一切的前提 学习本课程最重要的不是理论，而是学习完理论之后的实践环节，你只需要做出一种努力，即应用的努力 安静 理论 安静是我们文化所缺失的一部分，我们会忍不住打破沉默。 安静是一种最深层次的学习媒介，记忆再现的过程，使我们区分出什么是最重要的，什么是不那重要的 安静给了我们经历过后反省自己所闻的机会 论据 《教学的勇气》 有酒和没酒的小鼠走迷宫 崇尚安静的印第安人文化 实践 内省： 一、找一个安静的环境，仔细回顾之前的经历（学习经历，交流经历等等） 二、仔细想想什么是最重要的，哪些是很重要的，哪些是不那么重要的 注：一步骤和二步骤交替进行，直到自己认为达到了内省的效果！ Transform 理论 大多数教育只是在传递信息，这是远远不够的，关键在于接收信息的容器的形状，信息是客观存在的，形状决定了我们的自尊水平和快乐水平！ 论据 比赛目标是前三名，结果是第八名的两种解读 —— 解读模型的重要性 实践 一、构建解读模型：当我们教别人一些东西时，我们不光要传递信息，还要想办法为信息的理解构建一种解读模型 二、失败变成机遇：失败后自省 (见安静的理念)，让我们看看我们能学到什么！ 关于多余的石头 引言 《大卫》—— 米开朗基罗 真相 对失败的恐惧，对成功的畏惧，完美主义等等不是与生俱来的，在世经历让我们被限制，使我们无法窥视自己的内心，社会的教条，长辈的训诫，有时候会是那多余的石头，将自我封闭掉。凿掉多余的石头像极了人生的第三境界 —— 看山是山，看水是水！ 问题的力量 理论 教育的目的在于让一个人不断地发问！ 问题制造现实，制造可能性，一个问题引起一场探索 一个问题能够将我们的专注力聚焦到某个现实中，是聚焦神器 论据 由致病模型到建康模型的转变使积极心理学有了长足的进展 几何图形的数量 实践 问和答：作为教育者的身份时，不仅要让你的教育对象多问，及时提出问题！并且多对教育者抛出问题！ 自问：当你要学习专注一件事时，试着对其不断提出问题，能够让我们迅速专注于所做的事情！ 扩大与兼顾：当问题所关注的事情只是一件或者所关注的事情具有正反面时，尝试扩大范围 or 兼顾正反面！ 没人会来的 理论 没有人会来到你的生活中帮你解决你所遇到的问题，一切的成败都靠你自己，教育者的存在是为了我们个人的前进创造条件，一切都要靠我们自身做出努力！ 实践 常常问自己，自己改变了什么？、 思考自己需要在哪些方面做出努力 时刻认识自己才是自己生活的缔造者，做出行动，天高任鸟飞！","path":"2021/09/16/J_积极心理学/1/","date":"09-16","excerpt":"","tags":[{"name":"心理学","slug":"心理学","permalink":"https://帆帆.icu/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"Blog客户端（APP）","text":"下载地址 Blog 客户端 (点击下载)","path":"2021/09/16/S_实践项目/Blog客户端/","date":"09-16","excerpt":"","tags":[{"name":"APP","slug":"APP","permalink":"https://帆帆.icu/tags/APP/"}]},{"title":"爬虫之旅","text":"开始前的准备：包库引入 平台：VS Code 在终端中输入下列代码 12pip install bs4pip install xlwt 引入模块 12345from bs4 import BeautifulSoup #网页解析、获取数据import re #文字匹配import urllib.request,urllib.error #指定url，获取网页import xlwt #Excel操作import sqlite3 #进行sql数据库操作 建立框架 1234567891011121314#主函数def main(): baseurl = \"https://movie.douban.com/top250?start=\" dateList = getDate(baseurl) savePath = \".\\\\豆瓣电影TOP250.xls\" saveDate(savePath)#爬取网页def getDate(baseurl): dateList = [] return dateList#保存数据def saveDate(savePath): 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from bs4 import BeautifulSoup #网页解析、获取数据import re #文字匹配import urllib.request,urllib.error,urllib.parse #指定url，获取网页import xlwt #Excel操作import sqlite3 #进行sql数据库操作def main(): baseurl = \"https://movie.douban.com/top250?start=\" dateList = getDate(baseurl) #savePath = \".\\\\豆瓣电影TOP250.xls\" #saveDate(savePath)findName = re.compile(r'&lt;span class=\"title\"&gt;(.*?)&lt;/span&gt;') #name规则findOtherName = re.compile(r'&lt;span class=\"other\"&gt;(.*?)&lt;/span&gt;') #name规则findLink = re.compile(r'&lt;a href=\"(.*?)\"&gt;') #link规则findImgSrc = re.compile(r'&lt;img.*src=\"(.*?)\"',re.S) #imgSrc规则#爬取并解析网页def getDate(baseurl): j = 1 for i in range(0,250,25): bs = BeautifulSoup(askURL(baseurl+str(i)),\"html.parser\") for item in bs.find_all('div',class_=\"item\"): item = str(item) name = re.findall(findName,item)[0] otherName = re.findall(findOtherName,item)[0] link = re.findall(findLink,item)[0] img = re.findall(findImgSrc,item)[0] print(\"Top\",j,name) print(\"链接:\",link) print(\"图片:\",img) j+=1#保存数据def saveDate(savePath): print(\"\")#爬取单个网页def askURL(url): header={ \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 Edg/94.0.992.31\" } req=urllib.request.Request(url,headers=header,method='GET') try: response = urllib.request.urlopen(req) return response.read().decode('utf-8') except urllib.error.URLError as e: if hasattr(e,\"code\"): print(e.code) if hasattr(e,\"reason\"): print(e.reason)#入口if __name__ == \"__main__\": main() 补充 Urllib库的使用 123456#get方式请求import urllib.request#引入URL库的requestresponse = urllib.request.urlopen(\"http://www.baidu.com\")print(response)print(response.read()) #网页源代码（未解码）print(response.read().decode('utf-8')) #网页源代码（utf -8解码） 12345678#post方式请求import urllib.request #引入URL库的requestimport urllib.parse #键值对解析器data = bytes(urllib.parse.urlencode({\"Hello\":\"World\"}),encoding = \"utf-8\") #post的数据包response = urllib.request.urlopen(\"http://httpbin.org/post\",data = data)print(response)print(response.read()) #网页源代码（未解码）print(response.read().decode('utf-8')) #网页源代码（utf -8解码） 1234567#超时处理try: import urllib.request response = urllib.request.urlopen(\"http://httpbin.org/get\",timeout=0.01) print(response.read().decode('utf-8')) #网页源代码（utf -8解码）except urllib.error.URLError as e: print(\"访问超时！\") 12345678import urllib.requestresponse = urllib.request.urlopen(\"http://httpbin.org/get\")print(response.status) #状态码：200response = urllib.request.urlopen(\"https://movie.douban.com\")print(response.status) #状态码：418（被发现是爬虫）response = urllib.request.urlopen(\"https://www.baidu.com\")print(response.getheaders())print(response.getheader(\"Server\")) 伪装成电脑 伪装前： 1234567import urllib.parseimport urllib.requesttry: response = urllib.request.urlopen(\"https://www.douban.com\") print(response.status)except urllib.error.HTTPError as e: print(\"你是茶壶！\") 伪装后： 12345678910import urllib.parseimport urllib.requesturl = \"https://www.douban.com\"data = bytes(urllib.parse.urlencode({\"name\":\"Arthur\"}),encoding='utf-8')headers={ \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 Edg/94.0.992.31\"}req = urllib.request.Request(url=url,data= data,headers=headers,method=\"POST\")response = urllib.request.urlopen(req)print(response.status) 爬取单个网页 1234567891011121314151617181920import urllib.parseimport urllib.requestdef main(): url = \"https://www.douban.com\" print(askURL(url))def askURL(url): header={ \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 Edg/94.0.992.31\" } req=urllib.request.Request(url,headers=header) try: response = urllib.request.urlopen(req) return response.status except urllib.error.URLError as e: if hasattr(e,\"code\"): print(e.code) if hasattr(e,\"reason\"): print(e.reason)if __name__ == \"__main__\": main() beautifulSoup库的使用 12345678910111213#printfrom bs4 import BeautifulSoupf = open(\"1.html\",\"rb\")html = f.read()bs = BeautifulSoup(html,\"html.parser\")print(bs) #整个文档print(bs.name) #文档名称print(bs.title) #标签、内容print(bs.title.string) #内容print(bs.title.attrs) #属性空print(bs.a) #标签、属性、内容print(bs.a.string) #内容print(bs.a.attrs) #属性（以键值对形式储存） find_all 123456from bs4 import BeautifulSoupf = open(\"1.html\",\"rb\")html = f.read().decode(\"utf-8\")bs = BeautifulSoup(html,\"html.parser\")aList = bs.find_all(\"a\")print(aList) 1234567import refrom bs4 import BeautifulSoupf = open(\"1.html\",\"rb\")html = f.read().decode(\"utf-8\")bs = BeautifulSoup(html,\"html.parser\")aList = bs.find_all(re.compile(\"a\"))#包含\"a\"的输出print(aList) 123456789import refrom bs4 import BeautifulSoupf = open(\"1.html\",\"rb\")html = f.read().decode(\"utf-8\")bs = BeautifulSoup(html,\"html.parser\")def nameExist(tag): return tag.has_attr(\"name\")aList = bs.find_all(nameExist)print(aList)","path":"2021/09/16/S_实践项目/P_爬虫之旅/","date":"09-16","excerpt":"","tags":[{"name":"Python","slug":"Python","permalink":"https://帆帆.icu/tags/Python/"}]},{"title":"导数的本质","text":"导数 “导数”名称的来源 导数通常来讲指的是变化率，导数的 “导” 字是指导的意思。 对于一个二维平面上的曲线而言，其曲线的弯曲变化率决定了该曲线的最终形态 换而言之，变化率（导数）指导了如何去画出这个图像，如何去得到这个图像，这就是导数名称的来源。 由变化到变化率 我们暂且忘记我们学过的求导公式，既然导数表示的是变化率 那么我们就可以通过观察事物变化特点，得到其变化率，也就是其导数。 而对于事物的变化，我们需要关注的只有变化前和变化后这两种状态即可 举个例子：对于 y=2x 而言 x 是自变量（自己在其取值范围内可任意变化大小） y 是因变量（因为 x 的变化而引起相应的变化） 我们不在关注实际的函数图像形式，上文已经提到，我们需要关注的只有变化前和变化后这两种状态即可 在这里我们借用一下数轴 变化前也就 x 本身，想象一下，x 本是一个数轴上的一个点， 因为 x 本身拥有一个取值范围，所以如果遍历 x 的所有可能性，那么在数轴上 x 会形成线段的状态（可能有很多段）。 当我们对 x 进行乘以 2 时，这些线段会被拉伸为原来的 2 倍，拉伸之后我们将这条数轴上的线段称为 y。 仔细想想看上述的 x 经历了什么，其变化过程就在于那个拉伸的过程。 拉伸的过程中，点的位置发生偏移，x 实质上就是一个点，x 的位置偏移就是 x 的实际变化过程，x=1 的点会偏移 2 位置，-1 的点会偏移到 -2 的位置，而有一个点始不发生偏移，那就是数轴的原点。 既然 x 的变化我们已知晓，也就是 x 表示的点的偏移，但这是远远不够的，就像知道空间中一个点偏移到另外一个点，我们只知道其变化，而并不知道变化率，变化率无从求出。 还记得上文我们提到的吗？ 我们需要关注的只有变化前和变化后这两种状态即可 我们回到变化前的状态，也就是数轴上的某些点均匀分布构成的线段 对于 x=1 这个点而言，我们去描述其状态其实就是下面这段话 该点位于原点右侧一个单位长度处 这段话包含了相对位置信息，而并非只是说 x=1 是一个点 而变化后呢？ 该点位于原点右侧两个单位长度处 所以求得变化率时其实就是 —— 距离原点的距离之比 也就是 2 前后状态之比也就是变化率也就是导数，如果在 x-y 坐标系里面表示 也就是 x 是变化前的状态，y 是变化后的状态 对其 x 和 y 轴作垂线，其交点组成的线段就是 y=2x 的图像，图像的斜率恰好为变化率。 对于原点的个人猜测（可不看） 原点的特点在于始终会回到原来的位置，即不会发生偏移。 至于原因在于其值为 0 的特殊性，任何数乘对其作用无效。 数乘其实就是放缩，这一点在线性代数和上文中显而易见） 我们在对一个事物去观察时，往往需要一个基准点，就像我们看一个东西时我们往往会找准一个角度去看，再换下一个角度一样。在实分析里面，我们学数学是为了是为了数学分析事物的实用性，所以在数学建模时我们选用的坐标系都会有一个原点（无论是直角坐标系还是极坐标系），可能在名称上略有不同，但终究是为了在数学上确定一个基准点，这个点与数建模对象无关，只和建模结果有关。还是上面那个例子，我们看一样事物时，选取不同的角度也就是不同的基准点，但事物始终时同一个事物，选取的角度不同，看到的结果也会不同，也就是建模结果不同。 结语 虽然这一切在学过高中数学的人而言十分简单！ 但对于背后的思维过程的推理仔细去想也是十分美妙的！ END","path":"2021/09/16/S_数学/D_导数的本质/","date":"09-16","excerpt":"","tags":[{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"},{"name":"导数","slug":"导数","permalink":"https://帆帆.icu/tags/%E5%AF%BC%E6%95%B0/"}]},{"title":"学生学籍管理系统","text":"引言 借用基础链表知识和一些文件操作写的学籍管理系统 完整代码（VC++6.0） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486C#include&lt;conio.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;windows.h&gt;#define BUFSIZE 20typedef struct Student{ char Name[10]; //姓名 int Number; //学号 int Grade; //年级 int Class; //班级 struct Student* next;}student,*link;link h, t, p;void Clear(); //清屏void Head(); //头指针void Menu(); //主菜单void Return(); //返回菜单void Findmenu(); //查找菜单void Keycontrol(); //键盘交互void Add(); //添加信息void Addexample(); //添加信息输入示例void Find(); //查找信息void Findname(); //按姓名查找void Findnumber(); //按学号查找void Delete(link p); //删除信息void View(link p); //显示信息void Modify(link p); //修改信息void Shift(); //切换为中文void Input(); //导入信息void Output(); //导出信息void Autooutput(); //自动导出void Inputduce();void ppp();int main(){ Head(); Shift(); Menu(); return 0;}void Clear(){ system(\"cls\");}void Head(){ h = t = (link)malloc(sizeof(student)); t-&gt;next = NULL;}void Menu(){ Clear(); printf(\"\\n\"); printf(\"****************************\\n\"); printf(\"* 学生学籍信息管理系统 *\\n\"); printf(\"* (1)添加信息 *\\n\"); printf(\"* (2)查找信息 *\\n\"); printf(\"* (3)导入信息 *\\n\"); printf(\"* (4)导出信息 *\\n\"); printf(\"* (5)退出系统 *\\n\"); printf(\"****************************\\n\"); printf(\"\\n\"); Keycontrol(); getchar();}void Returnmenu(){ printf(\"\\n\"); printf(\"即将为你返回主菜单\"); printf(\".\"); Sleep(500); printf(\".\"); Sleep(500); printf(\".\"); Sleep(500); printf(\".\"); Sleep(500); printf(\".\"); Sleep(500); while (_kbhit()) getchar(); Menu();}void Keycontrol(){ printf(\"请输入：\"); int n; scanf(\"%d\", &amp;n); switch (n) { case 1: getchar(); Add(); break; case 2: getchar(); Find(); break; case 3: getchar(); Input(); break; case 4: getchar(); Output(); break; case 5: getchar(); Autooutput(); ppp(); break; default: getchar(); printf(\"\\n\"); printf(\"选项不存在,请重新输入\\n\"); printf(\"\\n\"); Keycontrol(); break; }}void Addexample(){ printf(\"\\n\"); printf(\"输入示例：\\n\"); printf(\"\\n\"); printf(\"姓名：张三\\n\"); printf(\"学号：200912047\\n\"); printf(\"年级：20级\\n\"); printf(\"班级：1班\\n\"); printf(\"\\n\");}void Add(){ Clear(); Addexample(); link p = (link)malloc(sizeof(student)); printf(\"请输入姓名：\");gets(p-&gt;Name); if (p-&gt;Name[0]=='\\0')//直接回车就重新输入 Add(); else { printf(\"\\n\"); printf(\"请输入学号：\"); scanf(\"%d\", &amp;p-&gt;Number); printf(\"\\n\"); printf(\"请输入年级：\"); scanf(\"%d级\", &amp;p-&gt;Grade); printf(\"\\n\"); printf(\"请输入班级：\"); scanf(\"%d班\", &amp;p-&gt;Class); getchar(); } printf(\"\\n\"); printf(\"(1)确认添加 (2)重新输入\\n\"); printf(\"\\n\"); printf(\"请输入：\"); int n; scanf(\"%d\", &amp;n); if(n==2) Add(); else { t-&gt;next = p; t = p; t-&gt;next = NULL; printf(\"\\n\"); getchar(); printf(\"添加成功!\"); printf(\"\\n\"); Returnmenu(); }}void Findmenu(){ Clear(); printf(\"\\n\"); printf(\"(1)按姓名查找\\n\"); printf(\"\\n\"); printf(\"(2)按学号查找\\n\"); printf(\"\\n\"); printf(\"请输入：\");}void Find(){ Findmenu(); int n; scanf(\"%d\", &amp;n); switch (n) { case 1: getchar(); Findname(); break; case 2: getchar(); Findnumber(); break; default: getchar(); Find(); break; }}void Findname(){ Clear(); printf(\"\\n\"); printf(\"请输入姓名：\"); char ch[10]; gets(ch); if (ch[0] == '\\0') Findname(); p = h; int flag = 0; while (p-&gt;next!=NULL) { p = p-&gt;next; if (!strcmp(p-&gt;Name, ch))//相同为0 { flag = 1; break; } } if (flag==0) { printf(\"\\n\"); printf(\"该学生信息不存在!\\n\"); Returnmenu(); } else View(p);}void Findnumber(){ Clear(); printf(\"\\n\"); printf(\"请输入学号：\"); int m; scanf(\"%d\", &amp;m); p = h; int flag = 0; while (p-&gt;next != NULL) { p = p-&gt;next; if (p-&gt;Number == m) { flag = 1; break; } } if (flag==0) { printf(\"\\n\"); printf(\"该学生信息不存在!\\n\"); Returnmenu(); } else View(p);}void View(link p){ Clear(); printf(\"\\n\"); printf(\"信息如下：\\n\"); printf(\"姓名：%s\\n\", p-&gt;Name); printf(\"学号：%d\\n\", p-&gt;Number); printf(\"年级：%d级\\n\", p-&gt;Grade); printf(\"班级：%d班\\n\", p-&gt;Class); printf(\"\\n\"); printf(\"(1)再次查询\\n\"); printf(\"(2)修改信息\\n\"); printf(\"(3)删除信息\\n\"); printf(\"(4)返回主菜单\\n\"); printf(\"\\n\"); printf(\"请输入：\"); int n; scanf(\"%d\", &amp;n); switch (n) { case 1: getchar(); Find(); break; case 2: getchar(); Modify(p); break; case 3: getchar(); Delete(p); break; case 4: getchar(); Returnmenu(); break; default: getchar(); View(p); break; }}void Modify(link p){ Clear(); printf(\"\\n\"); printf(\"修改后的姓名：\"); gets(p-&gt;Name); if (p-&gt;Name[0] == '\\0')//直接回车就重新输入 Modify(p); else { printf(\"\\n\"); printf(\"修改后的学号：\"); scanf(\"%d\", &amp;p-&gt;Number); printf(\"\\n\"); printf(\"修改后的年级：\"); scanf(\"%d级\", &amp;p-&gt;Grade); printf(\"\\n\"); printf(\"修改后的班级：\"); scanf(\"%d班\", &amp;p-&gt;Class); getchar(); } printf(\"\\n\"); printf(\"(1)确认修改 (2)重新修改\\n\"); printf(\"\\n\"); printf(\"请输入：\"); if (getchar() == '2') Modify(p); else { printf(\"\\n\"); getchar(); printf(\"修改成功!\"); Returnmenu(); }}void Delete(link p){ link o = h; while (o-&gt;next != p) o = o-&gt;next; o-&gt;next = p-&gt;next; printf(\"\\n\"); printf(\"删除成功！\"); Returnmenu();}void Shift(){ keybd_event(0x10, 0, 0, 0); keybd_event(0x10, 0, KEYEVENTF_KEYUP, 0);}void Input(){ Clear(); printf(\"\\n\"); printf(\"目前仅支持UTF-8编码的文本！\\n\"); printf(\"\\n\"); printf(\"请把txt文档放在D盘根目录下\\n\"); printf(\"\\n\"); printf(\"请输入txt文件名：\"); char ch[20]; gets(ch); char buf[BUFSIZE]; char h[] = { \"D://\" }; char tt[] = { \".txt\" }; strcat(h, ch); strcat(h, tt); h[2] = h[3] = 92; FILE* fp; fp = fopen(h, \"r\"); if(fp==NULL) { printf(\"\\n\"); printf(\"文件打开失败或文件不存在！\"); printf(\"\\n\"); } fgets(buf, BUFSIZE, fp); link p=(link)malloc(sizeof(student)); int i,j=0; for (i = 9; i &lt; strlen(buf); i++) { p-&gt;Name[j] = buf[i]; j++; } fgets(buf, BUFSIZE, fp); int s=0,d=1; for (i = 9; i &lt; strlen(buf); i++) { s+=(buf[i]-'0')*d; d*=10; } p-&gt;Number = s; fgets(buf, BUFSIZE, fp); s=0;d=1; for (i = 9; i &lt; strlen(buf)-3; i++) { s+=(buf[i]-'0')*d; d*=10; } p-&gt;Grade = s; fgets(buf, BUFSIZE, fp); s=0;d=1; for (i = 9; i &lt; strlen(buf)-3; i++) { s+=(buf[i]-'0')*d; d*=10; } p-&gt;Class=s; t-&gt;next = p; t = p; t-&gt;next = NULL; printf(\"\\n\"); printf(\"添加完毕!\"); printf(\"\\n\"); Returnmenu();}void Output(){ p = h-&gt;next; while (p != NULL) { char h[] = { \"D://\" }; char t[] = { \".txt\" }; strcat(h,p-&gt;Name); strcat(h,t); h[2] = h[3] = 92; FILE* fp = NULL; fp=fopen(h, \"w+\"); fprintf(fp, \"姓名：%s\\n\",p-&gt;Name,10); fprintf(fp, \"学号：%d\\n\",p-&gt;Number); fprintf(fp, \"年级：%d级\\n\", p-&gt;Grade); fprintf(fp, \"班级：%d班\", p-&gt;Class); fclose(fp); p = p-&gt;next; } Clear(); char ch = 92; printf(\"\\n\"); printf(\"导出成功！\\n\"); printf(\"\\n\"); printf(\"命名方式：姓名\\n\"); printf(\"导出格式：txt文档\\n\"); printf(\"导出目录：D:%c\",ch); printf(\"\\n\"); Returnmenu();}void Autooutput(){ p = h-&gt;next; while (p != NULL) { char h[] = { \"D://\" }; char t[] = { \".txt\" }; strcat(h,p-&gt;Name); strcat(h,t); h[2] = h[3] = 92; FILE* fp = NULL; fp=fopen(h, \"w+\"); fprintf(fp, \"姓名：%s\\n\", p-&gt;Name, 10); fprintf(fp, \"学号：%d\\n\", p-&gt;Number); fprintf(fp, \"年级：%d级\\n\", p-&gt;Grade); fprintf(fp, \"班级：%d班\", p-&gt;Class); fclose(fp); p = p-&gt;next; } ppp();}void ppp(){ printf(\"\\n\"); printf(\"已为你自动导出！\\n\"); printf(\"\\n\"); printf(\"正在退出,请稍后\"); printf(\".\"); Sleep(500); printf(\".\"); Sleep(500); printf(\".\"); Sleep(500); printf(\".\"); Sleep(500); printf(\".\"); Sleep(500); printf(\"\\n\"); printf(\"\\n\"); exit(1);}","path":"2021/09/16/S_实践项目/X_学生学籍管理系统/","date":"09-16","excerpt":"","tags":[{"name":"链表","slug":"链表","permalink":"https://帆帆.icu/tags/%E9%93%BE%E8%A1%A8/"},{"name":"文件","slug":"文件","permalink":"https://帆帆.icu/tags/%E6%96%87%E4%BB%B6/"}]},{"title":"MarkDown","text":"文字样式 1234MARKDOWN&lt;font&gt;该处为文字&lt;/font&gt;&lt;font size=6&gt;该处为文字(大小：6)&lt;/font&gt;&lt;font size=5 color=#D1DAF2&gt;**该处为文字(大小：6，颜色：#D1DAF2，已加粗)**&lt;/font&gt; 相关链接 MarkDown 语法 在线 MarkDown 编辑工具 表情图 表情图（备用） 删除线 任务列表 🔲 ✅ ☑️ END","path":"2021/09/16/Z_杂七杂八/MarkDown/","date":"09-16","excerpt":"","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://帆帆.icu/tags/MarkDown/"}]},{"title":"睡眠革命","text":"设定固定起床点 比上班 / 学时间提前 90分钟，保证睡醒有充分时间缓冲状态，不耽误任何事情 倒推理想入眠期 一、刚开始用 5 个周期倒推，之后根据起床状态不停尝试，多退少补，慢慢找到专属自己的作息表。 二、注意，入睡时间不要太晚，不要熬夜！根据昼夜节律，身体在 21 点分泌褪黑素，2-3 点达到睡眠最深的状态，千万别错过这个黄金睡眠阶段 重中之重的睡前睡后程序 睡前 一、入睡前 90 分钟淋浴（降温） 操作方法：如果 23:30 点睡觉，则在 22 点前结束沐浴，22 点 15 分钟左右上床，通过 15 分钟的睡前准备，还有 1 小时左右的睡前阅读、睡前瑜伽等不带刺激大脑的日常安排，到了快 11 点时，保证你能快速入眠，睡得香香的～ 二、足浴（&lt;=15min） 泡脚时下载你的一天，进行复盘，把今日收获或压力，记录下来，让成果可视化；顺便制作明日计划，让第二天有方向感地度过。 三、调节室内温度 科学研究表示，房间温度在 20-25 度时，身体感觉最舒服，最适合入睡。 四、睡前缓和运动 瑜伽类的舒展运动、整理房间等。 五、单调法则 冥想 + 看书 六、调节光线 睡觉前从白灯变成暖灯，杜绝蓝光！ 让手机单独一个屋睡，手机已经到了和大人分开睡的年龄了，不要再宠幸它了，会惯坏的。 注：超过 10 点后不再吃东西；正常作息的人，睡前 90 分钟不再进食 睡后 其他问题 一、睡不着时，就重复入睡程序，下床去泡脚、看书、放轻音乐，别在床上做无用功！","path":"2021/09/16/Z_杂七杂八/S_睡眠革命/","date":"09-16","excerpt":"","tags":[{"name":"睡眠","slug":"睡眠","permalink":"https://帆帆.icu/tags/%E7%9D%A1%E7%9C%A0/"}]},{"title":"无节制消费的元凶","text":"无节制消费的元凶 1、计划报废，将产品做成易损品； 2、不断推陈出新，使人对现状不满，不停购买； 3、出售安全属性等，利用人类本能； 4、广告制作中以消费者焦虑为目标，贩卖焦虑，恐惧式营销，唤醒焦虑再提供一个解决之道； 5、将儿童超级消费者的计划，故事性与授权制的销售，如漫威；同时利用小孩意见对家长购物决策的影响力，针对孩子做广告； 6、将成年人变成孩子一样，成为模范消费者，怂恿成年人释放童心，漫展、周边，成年人与儿童消费市场的界限消失，游戏，成年人更爱暴力行动游戏； 7、新的销售方式：创造 “粘性行为”，如尼奥宠物游戏，玩家反复登陆查看状态，不断回到游戏，商家在这种网站上投放广告，甚至植入游戏内容（植入式广告）； 8、rewards、levels、achievement，挑战与激励并存，用成就激励玩家不停地玩，利用人类天生追求奖励的本能；将这种游戏策略用到市场营销中，游戏化，如集卡，将消费本身变成游戏； 9、成年人消费会更谨慎和犹豫，信贷制改变了这一切，信用卡，即时消费主义，消费欲望被释放并且更容易接受高价，暂时忘记购物欲付款间的紧密联系，现金的拿出会让人感到痛苦；信用卡利用人们对未来的积极预期，促使成年人像小孩子一样消费，我想要并且现在就要； 10、互联网与支付软件，让购物更轻松，省去会让消费者迟疑的中间环节。","path":"2021/09/16/Z_杂七杂八/W_无节制消费的元凶/","date":"09-16","excerpt":"","tags":[{"name":"消费主义","slug":"消费主义","permalink":"https://帆帆.icu/tags/%E6%B6%88%E8%B4%B9%E4%B8%BB%E4%B9%89/"}]},{"title":"句子集","text":"一 1、你是我疲惫生活中唯一的英雄梦想 2、山海的浩瀚，宇宙的浪漫。都在我内心翻腾，在推着我前进。—— 陈粒《绝对占有相对自由》 3、夏天有梅子味的晚霞和两三颗啤酒味的星 4、城南花开，城北花落。城东日升，城西日落 5、来日方长何惧车遥马慢 6、所谓英雄，就是能打破逆境的人啊 7、要问世间什么最难的，明确的爱，直接的厌恶，真诚的喜欢，站在太阳的坦荡和大声无愧的称赞自己 8、如果你看向我，我会温柔的消融，像火山中的雪。—— 米亚科托《耶路撒冷》 9、想被秋天卷起，卷进温柔的风里，柔软的云里，还有橘子味的拥抱里 10、你承诺过的月亮，还是没有出现，而我无眠，或者，我只是衣单天寒地，替你多爱了一夜人间","path":"2021/09/16/X_写作/J_句子集/","date":"09-16","excerpt":"","tags":[{"name":"句","slug":"句","permalink":"https://帆帆.icu/tags/%E5%8F%A5/"}]},{"title":"世界的律动","text":"​ 夕阳渐落，西天的云被染成了鲜艳的橙，万物林立在流彩的霞光之中，像极了严正以待的士兵。一阵暖风在红日光轮下成型，吹向高耸的云白山脉。满山的黄叶微微颤动，光影交错相叠。云白山头，坐着一位十几岁的少年郎，一袭白衣在夕阳的映衬下，显露出暗金色。其手间是一本《诗歌 300 首》，少年一手撑着脑袋，张口朗朗诵读道：余忆童稚时，能张目对日，明察秋毫。见藐小微物，必细察其纹理。 读完该段后便将书丢放到一旁，径直躺下，双手顺势垫住头部，悠然地望着蔚蓝的天空，笑道：沈爷爷小的时候竟能这么有趣，张目对日，那所见一切都会溢满金色，而且一切也会充满了温暖。说到此处，像是想起了什么，猛然翻身坐起，眺望着西天那抹淡淡红晕，会心地笑了起来，太阳公公要去地球另一侧送温暖了，在此之前，西天的云是它最后的温暖对象。 那么地球另一侧的人是否知道张目对日这个秘密呢？少年遐想道，“若我长大了，一定要去地球的那一侧，告诉他们这个秘密，算了，我现在就要告知天下这个大秘密”。 在夕阳最后的余晖中，少年双手成拳，对着西天呐喊：太阳公公！多谢你给我的世界带来金色和温暖！遥远的西天传来阵阵回声，像是这个世界对少年的回应。 随着最后一个 “暖” 字结束，夕阳消失了。 星球的这一侧变成了略带温热的蓝调星球。 这是黑夜来临前的独一无二的蓝调世界，远处的世界渐渐被黑色覆盖，深蓝色慢慢变成黑色。当夜幕袭来，整个天空都会被星河取代。但在此之前，我们会短暂地停留在这个深蓝色世界里面。 “该回家了”，少年将书拿起来，目光四处环绕着这个深蓝世界，向家的方向走去，一步步带着悠闲和惬意，黑夜和冷风被他远远甩在身后，月光微微，轻轻打在他的身上。","path":"2021/09/16/X_写作/S_世界的律动/","date":"09-16","excerpt":"","tags":[{"name":"小说","slug":"小说","permalink":"https://帆帆.icu/tags/%E5%B0%8F%E8%AF%B4/"}]},{"title":"链表","text":"链表结点 12345678typedef struct note{ int date; //数据区域 struct note* next; //指向结点的指针}Note,*link;//typedef相当于再命名//struct note——Note//结点//struct note*——link//指向结点的指针 构建链表 尾插法（尾指针移动） 123456789101112131415link link_t(){ int i; link h, t, p;//头指针，尾指针，中间指针 h = t = (link)malloc(sizeof(Note)); //malloc第一个结点 for (i = 1; i &lt;= n; i++) { p = (link)malloc(sizeof(Note)); //malloc新结点 p-&gt;date = i; //结点数据区域赋值 t-&gt;next = p; //将新结点和上一结点连接 t = p; //新结点成为尾部，t指向新结点 } t-&gt;next = NULL; //最后一个结点的指针域为空 return h; //返回头指针} 尾插法蕴含手动实现队列的思想 尾插法就是先构建头部节点，然后构建身体结点，不断延长身体节点的过程。 头插法（头指针移动） 123456789101112131415link link_h(){ int i; link h,p; h = (link)malloc(sizeof(Note)); //malloc第一个结点 h-&gt;next = NULL; //将第一个节点指针域初始化为空 for (i = 1; i &lt;= n; i++) { p = (link)malloc(sizeof(Note)); //malloc新结点 p-&gt;date = i; //结点数据区域赋值 p-&gt;next = h-&gt;next; //使该层新节点指向上层结点 h-&gt;next = p; //h-&gt;next始终指向每一层的新结点 } return h; //返回头指针} 头插法只需要两个指针变量，因为不需要记录头指针，头指针本身就用来拓展链表 头插法和尾插法的对比 ①头插法构建的链表遍历时正序，而尾插法逆序 ②尾插法比头插法节约一个指针变量 单链表逆置 理论 根据头插法和尾插法一个正序一个逆序的特点，用头插法重构尾插法构建好的链表 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct note{ int date; //数据区域 struct note* next; //指向结点的指针}Note,*link;int n = 10; //节点个数link link_t(); //尾插法生成一个单链表link link_h(); //头插法void print(link x); //单链表输出函数int Find(link x, int m); //根据头指针返回第m个结点的数据int main(){ print(link_t()); //生成一个单链表，并输出 printf(\"\\n\"); print(link_h()); //逆置单链表，并输出 getchar(); getchar(); return 0;}link link_t(){ int i; link h, t, p; h = t = (link)malloc(sizeof(Note)); for (i = 1; i &lt;= n; i++) { p = (link)malloc(sizeof(Note)); p-&gt;date = i; t-&gt;next = p; t = p; } t-&gt;next = NULL; return h;}link link_h(){ int i; link h,p; h = (link)malloc(sizeof(Note)); h-&gt;next = NULL; for (i = 1; i &lt;= n; i++) { p = (link)malloc(sizeof(Note)); p-&gt;date = Find(link_t(), i); p-&gt;next = h-&gt;next; h-&gt;next = p; } return h;}void print(link x){ link p = x-&gt;next; while (p != NULL) { printf(\"%d \", p-&gt;date); p = p-&gt;next; }}int Find(link x, int m){ int i; link p = x-&gt;next; for (i = 1; i &lt; m; i++) p = p-&gt;next; return p-&gt;date;} 要点 单链表输出时若用 p-&gt;next 作为循环条件会导致遗漏最后一个结点","path":"2021/09/16/S_算法与数据结构/S_数据结构/L_链表/L_链表/","date":"09-16","excerpt":"","tags":[{"name":"链表","slug":"链表","permalink":"https://帆帆.icu/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"https://帆帆.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"哈夫曼树（编码）","text":"介绍 哈夫曼树 (Huffman Tree) 背景：著名的 哈夫曼编码 发明人 戴维・霍夫曼于 1999 年 10 月 17 日因癌症去世，享年 74 岁，他发明了著名的的 霍夫曼编码，除了霍夫曼编码以外，他还涉及出二叉最优搜索树的算法，因为其效率最高，所以被命名为霍夫曼算法，是动态规划的一个范例 通过哈夫曼树，我们往往可以得到问题的最优解 所以哈夫曼树也叫做最优二叉树 最优二叉树是在叶子结点和权重确定的情况下，带权路径长度（WPL）最小的二叉树 什么是带权路径长度（WPL） 我们要做的就是找到 WPL 最小的二叉树 构建最优二叉树 不难发现要使得 WPL 最小，那么深度越大的叶子结点权值就越小，深度小的叶子结点权值就越大，我们从下往上，深度减小的方向构建二叉树。 具体步骤： 一、从小到大进行排序，将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 二、取出根节点权值最小的两颗二叉树 三、组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 四、再将这颗新的二叉树， 不断重复 1-2-3 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stack&gt;#include&lt;iostream&gt;using namespace std;typedef struct HTNote{ int date; bool flag; int p, l, r;}HT,*Link;int n; Link p;void input(); //输入数据int findMin(int n); //寻找最小值void createHT(); //创建哈夫曼树void codeHT(); //哈夫曼编码int main(){ input(); createHT(); codeHT(); return 0;}void input(){ cout &lt;&lt; \"请输入权值个数：\"; cin &gt;&gt; n; p = new HT[2 * n]; cout &lt;&lt; \"请输入权值：\"; for (int i = 1; i &lt;= n; i++) { int temp; cin &gt;&gt; temp; *(p + i) = { temp,false,0,0,0 }; }}int findMin(int n){ int min = 0x3f3f3f3f; int k = 0; for (int i = n; i &gt;= 1; i--) { if (min &gt; (p + i)-&gt;date &amp;&amp; (p + i)-&gt;flag == false) { min = (p + i)-&gt;date; k = i; } } (p + k)-&gt;flag = true; return k;}void createHT(){ int t = findMin(n); (p + t)-&gt;flag = true; for (int j = 1; j &lt; n; j++) { int tt = findMin(n + j - 1); *(p + n + j) = { (p + t)-&gt;date + (p + tt)-&gt;date ,true ,0,t,tt }; (p + t)-&gt;p = (p + tt)-&gt;p = n + j; t = n + j; }}void codeHT(){ for (int i = 1; i &lt;= n; i++) { int t = i; cout &lt;&lt; (p + t)-&gt;date &lt;&lt; \"--&gt;\"; stack&lt;int&gt; s; while ((p + t)-&gt;p != 0) { if ((p + (p + t)-&gt;p)-&gt;l == t) s.push(0); if ((p + (p + t)-&gt;p)-&gt;r == t) s.push(1); t = (p + t)-&gt;p; } while (s.size() != 0) { cout &lt;&lt; s.top(); s.pop(); } cout &lt;&lt; endl; }} 适用情况 一、根节点的值等于叶子节点 二、出现最小，最优的字眼时 三、与求最小 WPL 等价时","path":"2021/09/16/S_算法与数据结构/S_数据结构/S_树、图/H_哈夫曼树/","date":"09-16","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://帆帆.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"https://帆帆.icu/tags/%E6%A0%91/"},{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"}]},{"title":"树","text":"二叉树的存储方式 数组存储 完全二叉树 一、由根节点从 1 开始编号（从上到下、从左到右） 二、完全二叉树因为在编号时是连续的，所以可以用数组来表示 一般二叉树 一、将一般二叉树补全为完全二叉树，不存在的结点可以用标记数组进行标记！ 二、会导致空间浪费 ! 链表存储 123456typedef struct note{ int date; struct note* lchild; struct note* rchild;}Note; 构建二叉树 前序构建 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586```### `中序构建`### `后序构建`------## `二叉树的遍历````C#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct BTNote{ char date; struct BTNote* lchild; struct BTNote* rchild;}Note,* link; link CreateBT()//创建树{ link PA = (link)malloc(sizeof(Note)); link PB = (link)malloc(sizeof(Note)); link PC = (link)malloc(sizeof(Note)); link PD = (link)malloc(sizeof(Note)); link PE = (link)malloc(sizeof(Note)); link PF = (link)malloc(sizeof(Note)); PA-&gt;date = 'A'; PB-&gt;date = 'B'; PC-&gt;date = 'C'; PD-&gt;date = 'D'; PE-&gt;date = 'E'; PF-&gt;date = 'F'; PA-&gt;lchild = PB; PA-&gt;rchild = PC; PB-&gt;lchild = PD; PB-&gt;rchild = NULL; PD-&gt;lchild = PD-&gt;rchild = NULL; PC-&gt;lchild = PE; PC-&gt;rchild = PF; PE-&gt;lchild = PE-&gt;rchild = NULL; PF-&gt;lchild = PF-&gt;rchild = NULL; return PA;} void Pre_ergodic(link p) { if (NULL != p) printf(\"%c \", p-&gt;date); else return; Pre_ergodic(p-&gt;lchild); Pre_ergodic(p-&gt;rchild); return; } void In_ergodic(link p) { if (NULL != p) { In_ergodic(p-&gt;lchild); printf(\"%c \", p-&gt;date); In_ergodic(p-&gt;rchild); } } void Post_ergodic(link p) { if (NULL != p) { Post_ergodic(p-&gt;lchild); Post_ergodic(p-&gt;rchild); printf(\"%c \", p-&gt;date); } }int main(){ link p = CreateBT(); printf(\"先序遍历：\"); Pre_ergodic(p); printf(\"\\n\"); printf(\"中序遍历：\"); In_ergodic(p); printf(\"\\n\"); printf(\"后序遍历：\"); Post_ergodic(p); printf(\"\\n\"); return 0;}","path":"2021/09/16/S_算法与数据结构/S_数据结构/S_树、图/S_树/","date":"09-16","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://帆帆.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"https://帆帆.icu/tags/%E6%A0%91/"}]},{"title":"冒泡排序","text":"冒泡排序 冒泡排序也称为沉底排序，通过一次又一次巡回将最大（小）数沉入（冒泡）到末尾 基础代码 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main(){ int n; scanf(\"%d\", &amp;n); int a[100]; int i, j, t; for (i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for (i = 1; i &lt; n;i++)//控制巡回次数(n-1)（两个为一对） { for (j = 1; j &lt; n; j++)//每次巡回都从1开始直到末尾 { if (a[j] &gt; a[j+1]) { t = a[j]; a[j] = a[j+1]; a[j+1] = t; } } } for (i = 1; i &lt;= n; i++) printf(\"%d \", a[i]); return 0;} 上述代码每一次巡回都从 1 到 n-1，末尾的数会在一次又一次循环中逐渐排好，我们无需再巡回到末尾。 于是便有了下面的这段代码 更优代码 1234567891011121314151617181920#include&lt;stdio.h&gt;int main(){ //小于等于2——未排序 / 大于2——已排序 int a[10], n, t = 0;//防止全相等的情况下，t未初始化 scanf_s(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf_s(\"%d\", &amp;a[i]); for (int i = n; i &gt;= 2; i--)//i=1时内层循环不会运行 for (int j = 1; j &lt; i; j++) { if (a[j] &gt; a[j + 1]) { t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; } } for (int i = 1; i &lt;= n; i++) printf(\"%d \", a[i]); return 0;} 最优解 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main(){ int a[10], n, t=0;//防止全相等的情况下，t未初始化 scanf_s(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf_s(\"%d\", &amp;a[i]); for (int i = n; i &gt;= 2; i--)//i=1时内层循环不会运行 { for (int j = 1; j &lt; i; j++) { if (a[j] &gt; a[j + 1]) { t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; } } if (t == a[i - 1])//i位置已为最大值，t用来交换了次大值，也就是i-1位的值 i--; } for (int i = 1; i &lt;= n; i++) printf(\"%d \", a[i]); return 0;}","path":"2021/09/16/S_算法与数据结构/S_算法/P_排序/M_冒泡排序/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://帆帆.icu/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡","slug":"冒泡","permalink":"https://帆帆.icu/tags/%E5%86%92%E6%B3%A1/"}]},{"title":"01 迷宫","text":"题目来源 01 迷宫 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#define MAX 1005int m, n, ans;int map[MAX][MAX];int book[MAX][MAX];void dfs(int x, int y){ book[x][y] = 1; int next[4][2] = { {1,0},{0,1},{-1,0},{0,-1} }; for (int k = 0; k &lt;= 3; k++) { int dx = x + next[k][0]; int dy = y + next[k][1]; if (((map[dx][dy] == 0 &amp;&amp; map[x][y] == 1) || (map[dx][dy] == 1 &amp;&amp; map[x][y] == 0)) &amp;&amp; dx &gt;= 1 &amp;&amp; dx &lt;= n &amp;&amp; dy &gt;= 1 &amp;&amp; dy &lt;= n &amp;&amp; book[dx][dy] == 0) { ans++; dfs(dx, dy); } } return;}void clear(){ ans = 1; int i, j; for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) book[i][j] = 0;}int main(){ int x, y; int i, j; char ch[MAX]; scanf(\"%d%d\", &amp;n, &amp;m); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) scanf(\"%1d\", &amp;map[i][j]); for (i = 1; i &lt;= m; i++) { scanf(\"%d%d\", &amp;x, &amp;y); clear(); dfs(x, y); printf(\"%d\\n\", ans); } return 0;} 以上代码虽然是正确的，但是因为效率过低，在洛谷平台的样例测试中会出现时间超限的情况如下图： 剪枝优化 1//未更 END","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/01 迷宫/","date":"09-16","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"}]},{"title":"AT46 リモコン","text":"题目来源 AT46 リモコン 代码详解 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;int min(int a, int b);int A, B, step, m = 999999999;void dfs(int x, int y,int step){ if (step &gt; m) return; if (x == y) { m = min(step, m); return; } if (x &gt; y)//大于就往下搜 { dfs(x - 1, y,step+1); dfs(x - 5, y,step+1); dfs(x - 10, y,step+1); } if (x &lt; y)//小于就往上搜 { dfs(x + 1, y, step + 1); dfs(x + 5, y, step + 1); dfs(x + 10, y, step + 1); } return;}int main(){ scanf(\"%d %d\", &amp;A, &amp;B); dfs(A, B,0); printf(\"%d\\n\", m); return 0;}int min(int a, int b){ return a &gt; b ? b : a;} 关键点 剪枝 必须剪枝，大于最小次数就退出，不然会递归不会结束，因为不看最小次数则有无数种可能 也就是下面这段代码 12if (step &gt; m) return; 回车符 AT 开头的日本题目输出时必须要回车，否则必错！！！","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/AT46 リモコン/","date":"09-16","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"}]},{"title":"八皇后 Checker Challenge","text":"八皇后问题 题目描述 一个如下的 6×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。 上面的布局可以用序列 2 4 6 1 3 5来描述，第 i 个数字表示在第 i 行的相应位置有一个棋子，如下： 行号 1 2 3 4 5 6 列号 2 4 6 1 3 5 这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。 并把它们以上面的序列方法输出，解按字典顺序排列。 请输出前 3 个解，最后一行是解的总个数。 输入 一行一个正整数 n，表示棋盘是 n×n 大小的。 输出 前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。 样例输入 6 样例输出 2 4 6 1 3 5 3 6 2 5 1 4 4 1 5 2 6 3 4 提示 【数据范围】 对于 100%100% 的数据，6 \\le n \\le 136≤n≤13。 题目来源 八皇后 Checker Challenge 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;int n, cnt;int a[20];int lie[20];//列int u[40];//左斜int v[40];//右斜void pr(){ if (cnt &lt;= 3) { for (int i = 1; i &lt;= n; i++) printf(\"%d \", a[i]); printf(\"\\n\"); }}void dfs(int x){ int i; if (x &gt; n) { cnt++; pr(); return; } for (i = 1; i &lt;= n; i++) { if (lie[i] == 0 &amp;&amp; u[x - i + n] == 0 &amp;&amp; v[x + i] == 0) { lie[i] = 1; u[x - i + n] = 1; v[x + i] = 1; a[x] = i; dfs(x + 1); lie[i] = 0; u[x - i + n] = 0; v[x + i] = 0; } }}int main(){ scanf(\"%d\", &amp;n); dfs(1); printf(\"%d\", cnt); return 0;} 若为N皇后问题（n组问题） 12345678910int main(){ while(scanf(\"%d\", &amp;n),n!=0) { dfs(1); printf(\"%d\\n\", cnt); cnt = 0; } return 0;} 思路详解: 1）本题类型： 我们需要遍历所有的行，然后在遍历行的同时我们要选某一列去放数，有诸多可能性 在这里我们用DFS去遍历所有可能性 2)代码实现： 第一步：定义标记数组： 123int lie[20];//列int u[40];//左斜int v[40];//右斜 问题一：怎么做？ 我们要确保标记点的行和列及左右45度都没其他标记点 因为在这里我们将行数当变量输入DFS函数，一层一层向下递的时候 每一层的函数的行数必然不同，所以行数不必再标记 我们在放一个数时，要对其所在某列，某斜的一串进行标记 所以我们要找到列，左邪，右斜的其本身包含的元素的相同性质 以保证我们标记的是某列某斜的一串 通过观察我们可以发现： 列上的元素本身同列（显而易见） 左斜上元素的行列坐标之和相等 右斜上元素的行列坐标之差的绝对值相等 问题二：为什么左斜和右斜数组开的是列数的二倍？ 因为我们是根据性质去标记的，列数最大为n，n最大为13，我们开20的数组已经足够 但是左斜是行列坐标之和，最大可能是2n，我们开40的数组也会够用 右斜是行列坐标之差，可能为负数，我们在标记时将其加n（如下DFS内） 加n后，最大可能是2n-1，我们开40数组确保够用 第二步：DFS函数： 123456789101112131415161718192021222324void dfs(int x){ int i; if (x &gt; n) { cnt++;//先累加再输出，让cnt大小和pr内函数相匹配 pr(); return; } for (i = 1; i &lt;= n; i++) { if (lie[i] == 0 &amp;&amp; u[x - i + n] == 0 &amp;&amp; v[x + i] == 0) { lie[i] = 1; u[x - i + n] = 1;//确保其对应的数组下下标&gt;=1 v[x + i] = 1;// a[x] = i; dfs(x + 1); lie[i] = 0; u[x - i + n] = 0; v[x + i] = 0;//常见的回溯过程 } }} 第三步：输出： 123456789void pr(){ if (cnt &lt;= 3) { for (int i = 1; i &lt;= n; i++) printf(\"%d \", a[i]); printf(\"\\n\"); }} 简化代码： 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#define MAX 11using namespace std;int n, ans = 0;int h[MAX],l[MAX],zx[MAX],yx[MAX];void dfs(int i){ if (i == n + 1) ans++; for (int j = 1; j &lt;= n; j++) { if (!l[j] &amp;&amp; !zx[i - j] &amp;&amp; !yx[i + j]) { h[i] = 1; l[j] = 1; zx[i - j] = 1; yx[i + j] = 1; dfs(i + 1); h[i] = 0; l[j] = 0; zx[i - j] = 0; yx[i + j] = 0; } }}int main(){ cin &gt;&gt; n; dfs(1); cout &lt;&lt; ans; return 0;} END","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/B_八皇后 Checker Challenge/","date":"09-16","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"}]},{"title":"DFS算法的本质","text":"DFS算法的本质 引言 DFS 俗称深搜，是一种常见的算法模型 我们通过借助函数递归和递归停止条件的运用实现对数据的高级枚举 对于 DFS 算法而言，最重要的是如何去枚举数据，即如何去搜索？ 这是在运用 DFS 之前我们就应该思考的问题，只有对其思考清楚，才不妨碍我们下一步去运用代码实现 DFS！ OK! 让我们开始吧！ 何为搜索？ 让我们先忘记你学过 DFS 算法这件事，抛开脑子中具体的 代码结构，单纯地以一个自然人地角度去思考，什么是搜索？ 单独思考一个词汇可能我们不会获得很多，下面我们借助具体例子来说明： 假如我说 —— 我们去搜索一间房子，你会想到什么？ 寻找？探索？还是在房子里面转悠？ 可能这么说会引起歧义，这里我们再具体一点 换成 —— 我们去搜索这间房子，看看有没有宝藏藏在里面！ 上面两句话地区别在于，一个无目的，一个有目的 一个只是再房间里面转悠，一个在转悠地同时还要看看房间里面有没有宝藏 其实上面这两句话对应了 DFS 算法的两种基本类型 无目的的深度搜索 —— 裸的 DFS 有目的的深度搜索 —— 一般的 DFS (1) 无目的 DFS 就像你去亲戚家做客，主人带你在他家闲逛了解他家的布局 (2) 有目的 DFS 就像土匪掠夺财产时在你家到处探寻，直到找到你的私人小金库！ 但作为 算法 而言我们不能到处瞎转悠，有经验的主人和土匪往往也不会那么做！ 我们需要一种高效的搜索方案，它能让我们在最短时间内完成搜索任务！ 如何搜索？ DFS 的关键要领在于 —— 当下这一步干什么，然后下一步干什么。 这是所有 DFS 搜索🔍算法的核心，我们只要知道当下和下一步的动作，就能通过递归连贯出整个搜索动作。 让我们来举个例子 题目：DFS - 选数 题目大意：求从 N 个数里面选出 K 个数出来并且使选出的数的和为素数的的可能性有几种？ 假如：N=5，K=3 5 个数为：1 2 3 4 5 我们要做的是挑出 3 个数出来然后计算求和并判断和是否为素数。 你可能已经想到怎么去选了，一般的选法如下： 1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 略 我们要做的就是每一次选出一个数，首先仔细观察上述选数过程 当我们去选 1 2 3 时我们发现这是依次递增的，我们不免想到用 For循环去实现这个选数过程，For 循环每进行一次就选入一个数 可能你会这么写： 12345678dfs(int i,int k,int n)//选入的数为i，选了k个数，要选n个数{ if(k==n) //略 for(int i=1;i&lt;=n;i++) dfs(i+1,k+1，n) //略} 但问题来了我们在 1 2 3 选完之后是如何蹦到 1 2 4 呢？ 难不成我们需要再从头选一遍，标记3 已经被选过了，直接越过它去选 4 仔细思考你会发现这是一个无比繁琐的工作，你需要灵活的标记策略来应对不同的选数情况 我们想要的是不再从头去选，而是在选完 1 2 的基础上再去直接选 4 所以我们需要一种方法来保留选完 1 2 时的状态 可能 DFS 算法尚在研究时人们就发现了，他们需要保留一些状态，再去确定下一步的状态 巧妙的是函数递归在设计时就拥有保留中断线程的能力，在选数时我们可以完全用函数递归来写 这样写的好处在于，每一层函数选择一个数，选着完后就像线路一样被保存下来 最简单的我们选完 1，1的状态就被保存下来了，我们要在 1后面选数时，只需要 return 返回到选完 1 时的状态即可，这样我们可以顺利地选出 1 2 1 3 1 4 当前两个数选完后，也就保存了选完两个数的状态 其实我们可以用结点去理解这个过程 最开始我们选择了 1 这个结点，然后我们就可以连接 2/3/4 这三个结点 假如我们连接了 1和2结点就形成了 1-2 的线路，当我么们再往下 DFS 选数时，1-2 这条线路会被保存下来，通过选数和不断 return 返回到 1-2 这条线路的末尾，我们选出了： 1 2 3 1 2 4 1 2 5 核心代码如下： 12345678910111213141516//从x单元开始的选数（每往下递一层，For循环中i开始的位置需要改变）//已选m个数//m个数的和为sum//需要得到k个数,一共n个数void dfs(int x,int m,int sum,int k,int n){ if (m == k) { if (isPrime(sum)) ans++; return; } for (int i = x; i &lt; n; i++) dfs(i+1,m + 1, sum + *(p + i), k, n);//i+1而非x+1（因为是靠i来选数） return;} 部分过程如下： 1 // 选 1 结点 1-2 // 保留 1 结点选 2 结点 1-2-3 // 保留 1-2 线路选 3 结点 1-2 // 返回到 1-2 线路的末尾 1-2-4 // 在已保留 1-2 线路后选 4 结点 1-2 // 返回到 1-2 线路的末尾 1-2-5 // 以此类推！！！ 1-2 1 1-3 1-3-4 1-3 1-3-5 1-3 1 这也是为什么你所见到的 DFS算法都拥有递归调用的原因 DFS 算法本就是依托于函数递归而设计的一种高级枚举算法 至于为什么叫做深度搜索，相信在刚刚梳理的过程中你也可以感受出来，函数一层一层往下递，层层递进，不断深入去探索，直到碰到终止条件 当下这一步干什么，然后下一步干什么，这两步其实干的是同一类型的事情，在选数 这个例子中就是选数二字，DFS 函数的功能就是选数，每一次参数的传入就是一次选数的过程！ 构建DFS的框架 我们在上述讲到了 DFS 算法的内部过程，这可以让我们更好的去理解 DFS 算法是如何执行的，但是在写题时，光有这些是远远不够的，我们还需要一些宏观的框架思维，这可以帮助我们在面对新的问题时，更快速地想出解决办法。 我们从以下三个方面去思考一道 DFS 题目 递归の最大深度 定义：DFS 函数递归套娃时达到最底部（最深处）的过程中所经历的套娃次数 结论：递归の最大深度取决于输入的数据的大小和规模 例子 01. 选数：递归的最大深度其实就是输入的 k 02. 全排列：递归的最大深度其实就是输入的 n+1 的大小，函数一层一层往下递直到 step=n+1 03. 单词接龙：递归的最大深度不定，取决于数据规模，即：有多少个单词 04. 迷宫问题：递归的最大深度不定，取决于数据规模，即：地图的大小和特征 05. 八皇后问题：递归的最大深度就是输入的 n，即：图的边长 不胜枚举！！！ 对于裸的DFS，我们要遍历所有可能性，递归的最大深度不定 对于非裸的DFS，我们要加上 DFS 的 if条件，适时进行归的操作 该层函数与返回到该层函数 该层函数：递之前完成的动作 返回到该层函数：归之后需要完成的动作 代码示例 12345678910111213141516171819void dfs(int step){ if (step == n + 1)//最大深度为n { 略 return; } for (int i = 1; i &lt;= n; i++) { if(book[i]==0) { book[i]=1; p[step]= i;//往结点上放数 dfs(step + 1); book[i]=0; } } return;} 一、递之前完成的动作有 2个 1、For 循环选数、标记数并放数 12345678for (int i = 1; i &lt;= n; i++)//选出一个数{ if(book[i]==0) { book[i]=1;//标记数 p[step]= i;//往结点上放数 }} 2、将 step+1 并传入下一层函数中 (Very Important) 1dfs(step+1); 二、归之后需要完成的动作也有 2个 1、取消标记 1book[i]=0;//取消标记 2、若 for 循环没完则继续选数、标记数并放数 , 完了则跳出For循环 总结: 我们可发现这两个过程是可以首尾部巧妙连接的，也正由此连贯出整个递归过程 通过框架，确认DFS函数的参数！ 例题：数的分割 题目大意：把正整数 n 分解为 k 个正整数，排在后面的数必须大于或等于前面的数，输出所有方案。 1、确认递归深度 分出 k 个数即可，递归深度为 k（可以用 cnt 来计数） 123456if (cnt == k) { if (n == sum) ans++; return; } 2、该层函数 功能：分割出一个数且确保当下分割的数比之前的大（所以要保留分割出来的数进行比较) 123for (int i=cut; i &lt;= n-sum; i++) dfs(cnt + 1, i, sum + i);//cut为上次分割的数，从cut开始保证大于等于这个条件 3、返回到该层函数 功能：无 完整代码如下： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int n, k, ans;void dfs(int cnt,int cut,int sum){ if (cnt == k) { if (n == sum) ans++; return; } if (cut == 0)//第一次分割数最小为1 cut++; for (int i=cut; i &lt;= n-sum; i++)//n-sum用来减少次数，剪枝优化 dfs(cnt + 1, i, sum + i); return;}int main(){ scanf(\"%d%d\", &amp;n, &amp;k); dfs(0,0,0); printf(\"%d\", ans); return 0;} END","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/DFS算法的本质/","date":"09-16","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"}]},{"title":"单词接龙","text":"题目描述 单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的 “龙”（每个单词都最多在 “龙” 中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish，如果接成一条龙则变为 beastonish，另外相邻的两部分不能存在包含关系，例如 at 和 atide 间不能相连。 输入 输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词，输入的最后一行为一个单个字符，表示 “龙” 开头的字母。你可以假定以此字母开头的 “龙” 一定存在。 输出 只需输出以此字母开头的最长的 “龙” 的长度，输出占一行。 样例输入 5 At Touch Cheat Choose Tact A 样例输出 23 提示 条件：n≤20 样例解释：连成的 “龙” 为 atoucheatactactouchoose。 题目来源 P1019 NOIP2000 提高组 单词接龙 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int n, ans, vis[22];string a[22];//第一个参数是上一个字符串//第二个参数是拼接后的长度 void dfs(string x, int s){ //求最长长度 ans = max(ans, s); //枚举每一个字符串 for (int i = 1; i &lt;= n; i++) { int p = 1;//重叠部分长度 int la = x.length(); int lb = a[i].length(); while (p &lt; min(la, lb)) { if (x.substr(la - p) == a[i].substr(0, p) &amp;&amp; vis[i] &lt; 2) { vis[i]++; dfs(a[i], s + lb - p); vis[i]--; break; } p++; } } return;}int main(){ //读入 cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } char t; cin &gt;&gt; t; //枚举找到首字母为t的字符串 for (int i = 1; i &lt;= n; i++) { if (a[i][0] == t) { vis[i]++;//vis数组解决搜两次的问题 dfs(a[i], a[i].length()); vis[i]--; } } cout &lt;&lt; ans; return 0;} 思路详解 （1）这是什么类型的题？ 1）因为要判断 String 能否连接所以必然为一道字符串题 2）我们要将字符串连接起来，其中最小的子问题是两个字符串的连接问题，即最开始的情况下若有 n 个字符串，我们连接其中两个字符串，在确认第一个单词之后，剩下的一个单词的选择有 n 或 n-1 种情况（每个单词只能用两次）然后继续往下连接时还可能有 n 或 n-1 种情况，每一层连接都需要 for 循环所有的字符串，而且是不断往下进行的，所以也是一道深度搜索问题 DFS问题 （2）代码实现 第一步：读入 123456cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } char t; cin &gt;&gt; t; 第二步：找到第一个单词开始DFS 12345678for (int i = 1; i &lt;= n; i++) { if (a[i][0] == t) { vis[i]++;//vis数组解决搜两次的问题 //第一个字母使用过一次 dfs(a[i], a[i].length()); vis[i]--; } } 问题一：为何只传入字符串和其长度可以？ 答：因为如果我们知道两个字符串可以拼接，且知道重合部分的大小，我们就知道拼接后的长度，然后我们拿当前搜索的字符串（末尾的字符串）继续和下一个字符串去判断能否合并即可，也就是意味着我们并不需要把他们连起来就可以知道最终长度是多少 问题二：为何要 vis [i]–; 因为起始位点可能有多个，当我们从一个可行的起始位点往下搜索完毕后，还要可能存在另外一个可行的起始位点，当用另外一个位点时，之前的位点作为起始位点的 1 次 使用次数要消掉 第三步：DFS部分 1234567891011121314151617181920void dfs(string x, int s){ //求最长长度 ans = max(ans, s); //枚举每一个字符串 for (int i = 1; i &lt;= n; i++) { int p = 1;//重叠部分长度 int la = x.length(); int lb = a[i].length(); while (p &lt; min(la, lb)) { if (x.substr(la - p) == a[i].substr(0, p) &amp;&amp; vis[i] &lt; 2) { vis[i]++; dfs(a[i], s + lb - p); vis[i]--; } p++; } }}ans = max(ans, s); 在搜索🔍过程中 s 是不断变化的，我们用取大函数将 s 的最大值赋给一个全局变量 ans，ans 也是本题的最终答案 1int p = 1;//重叠部分长度 我们想让字符串最长，所以最理想的情况下是重叠部分长度为 1，且每次字符串连接的尝试都要使 p 为 1 所以 p 定义在 for 循环内 1while (p &lt; min(la, lb)) 确保两个字符串没有包含关系 1234567if (x.substr(la - p) == a[i].substr(0, p) &amp;&amp; vis[i] &lt; 2) { vis[i]++; dfs(a[i], s + lb - p); vis[i]--; break; } p++; 判断若重合长度为 p 时是否可以连接 若能连接则马上连接（确保 p 最小） 然后更新使用次数再去连接下一个 用当前被连接的字符串 作为下一步要连接字符串的新的起始位点 并且更新长度 所以 dfs(a[i], s + lb - p); 若不能连接 则加大 p 的长度再次判断，直到跳出 while 循环 关于该DFS的回溯详解（important） 若没有return编译器自动补全 当我们拼完了若干个字符串后不能够再继续拼接时 while 循环跳出，for 循环跳出，跑到了 return 的部分 return 回到上一层函数的内部的 dfs 函数结尾 紧接着执行 vis [i]–; 收回末端拼接的字符串然后跳出 while 不再 p++ （若不加 break，会又进行一次连接（eg：pcc 和 ccq），虽然也可以连接但是并不是最长的，最终会被舍去，所以不如提前规避掉，提高程序运行效率） 然后继续 for 循环看看能不能放入一个新的字符串到已经拼接过的字符串中去，若可以则生成新的字符串，若不行则结束 for 循环 return 到再上一层函数中去，然后重复相同的过程 其实和全排列问题差不多，一个是放数字，一个是放字符串只是再放字符串的同时判断了前后两个字符串的连接性,都遍历了所有可能性，函数递归的步骤完全相同 问题：为什么没有 if 递归终止条件？ 因为往下递到头后for循环结束后会遇到return进行归的过程 全排列问题里为了输出所以放置了 if 递归终止条件，然后再在if内return，但是该题不能用if，直接fou循环后加return即可，因为if的条件语句，我们无法找到 我们是遍历所有的可能性（if没必要） 不像全排列一样，在搜索到最底部时需要输出 问题： if 递归终止条件的作用 void的dfs函数无论有没有if,dfs函数终会回溯（void本不需要return） if 只是为了达到题目要求的功能而已 eg:输出数组","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/D_单词接龙/","date":"09-16","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"}]},{"title":"Healthy Holsteins","text":"题目来源 Healthy Holsteins 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;stdio.h&gt;#define MAX 30int n;int p, step;int v[MAX], sum[MAX];int s[MAX][MAX], book[MAX], FangAn[999999][MAX];void record(){ step++; for (int i = 1; i &lt;= p+1; i++) { if (book[i] == 1) { FangAn[step][i] = 1; FangAn[step][p + 1]+=i; FangAn[step][p + 2]++; } }}void solve(){ int min = 9999999, f; for (int i = 1; i &lt;= step; i++) { if (min &gt; FangAn[i][p + 2]) { min = FangAn[i][p + 2]; f = i; } } printf(\"%d \", FangAn[f][p + 2]); for (int j = 1; j &lt;= p; j++) { if (FangAn[f][j] == 1) printf(\"%d \", j); }}void dfs(int i){ if (i == p+1) { int flag = 1; for (int j = 1; j &lt;= n; j++) { if (sum[j] &lt; v[j]) flag = 0; } if (flag == 1) record(); return; } //选 book[i]=1; for (int j = 1; j &lt;= n; j++) sum[j] += s[i][j]; dfs(i + 1); book[i] = 0; //不选 for (int j = 1; j &lt;= n; j++) sum[j] -= s[i][j]; dfs(i + 1); return;}int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;v[i]); scanf(\"%d\", &amp;p); for (int i = 1; i &lt;= p; i++) { for (int j = 1; j &lt;= n; j++) scanf(\"%d\", &amp;s[i][j]); } dfs(1); solve(); return 0;} 关键点 我们从第一种饲料开始往下选，直到i=p+1 123456789101112if (i == p+1) { int flag = 1; for (int j = 1; j &lt;= n; j++) { if (sum[j] &lt; v[j]) flag = 0; } if (flag == 1) record(); return; } 每种饲料有两种状态、即选或者不选 1234567891011//选book[i]=1;for (int j = 1; j &lt;= n; j++) sum[j] += s[i][j];dfs(i + 1);C//不选book[i] = 0;for (int j = 1; j &lt;= n; j++) sum[j] -= s[i][j];dfs(i + 1);","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/Healthy Holsteins/","date":"09-16","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"}]},{"title":"马的遍历","text":"马的遍历 题目描述 有一个 n*m 的棋盘 (1&lt;n,m&lt;=400)，在某个点上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步 输入格式 一行四个数据，棋盘的大小和马的坐标 输出格式 一个 n*m 的矩阵，代表马到达某个点最少要走几步（左对齐，宽 5 格，不能到达则输出 - 1） 输入样例 3 3 1 1 输出样例 0 3 2 3 -1 1 2 1 4 题目来源 P1443 马的遍历 完整代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#define MAX 170000struct queue{ int x;//行坐标 int y;//列坐标};struct queue que[MAX];//最多160000个点这里令MAX=170000int head = 0, tail = 1;//队列引入int a[401][401];int n, m, sx, sy;//定义8组方向，这里的t是try的缩写，表示去试探的方向int tx[16] = { 2,-2,2,-2,-1,1,-1,1 };int ty[16] = { 1,1,-1,-1,2,2,-2,-2 };void init(){ for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = -1; a[sx][sy] = 0;}int main(){ scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;sx, &amp;sy); init();//初始化 //队列初始化 que[1].x = sx; que[1].y = sy; while (head &lt; tail) { head++; for (int i = 0; i&lt;8; i++) { int nx = que[head].x + tx[i]; int ny = que[head].y + ty[i]; if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; a[nx][ny] == -1) { tail++; que[tail].x = nx; que[tail].y = ny; a[nx][ny] = a[que[head].x][que[head].y] + 1; } } } //输出 for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) printf(\"%-5d\", a[i][j]); printf(\"\\n\"); } return 0;} 思路详解 这是什么类型的题？ 我们要得到的是马到达每一个点的最小步数，而 BFS恰好是按照最小步数一层层往下拓展的 在其拓展的同时我们可以自然地得到到达每一个点的最小步数，所以我们可以用 BFS 来解决这道题 代码实现 第一步：读入并初始化 12scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;sx, &amp;sy);//start-x,start-y起点的行坐标和列坐标init();//初始化 initialize - 初始化函数如下： 1234567void init(){ for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = -1; a[sx][sy] = 0;} 问题：为什么要先全令成 - 1 而不是 0？ 答：因为为 0 时表示起点到起点需要 0 步，而不能到达的点需要用 -1 来表示 我们在-1的蓝图上再进行a[sx][sy] = 0 和 BFS 拓展操作 这样再输出时没有被再次赋值的点就是不能到达的点,既符合题目要求，又方便 第二步：引入队列 1int head = 0, tail = 1;//队列引入 123//队列初始化que[1].x = sx;que[1].y = sy; 第三步：BFS的拓展部分（核心代码） 1while (head &lt; tail) 头和尾之间差的是一层的拓展，一个 head 可以拓展出多个 tail。 只有不能再拓展了（tail不再++），head 到达 tail 的位置时结束循环 1head++; 头指针 head 去赶尾指针 tail 向前走（往下拓展） 123456789101112for (int i = 0; i&lt;8; i++) { int nx = que[head].x + tx[i]; int ny = que[head].y + ty[i]; if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; a[nx][ny] == -1) { tail++; que[tail].x = nx; que[tail].y = ny; a[nx][ny] = a[que[head].x][que[head].y] + 1; } } 向八个方向试探，当不越界且未走过时（保证距离最短避免重复走）向下拓展 tail++ 拓宽队列，将新的点入队，记录步数。 问题：为什么是 a[nx][ny] = a[que[head].x][que[head].y] + 1;？ 答：因为 BFS 每一次向下试探拓展，其跨度的大小均为 1（步数） 每一次拓展成功意味着 head 位置的点向 tail 位置的点跨出一步 我们只需要将原来走的步数即（a [que [head].x][que [head].y]）加1即可 第一次进入 while 循环时，我们先 head++，此时 head 为 1，头指针指向起始位置 head位置的点是起始点，起始点的步数为 0 已经初始化过了其向下走一步恰好为0+1=1， 第四步：输出 123456for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) printf(\"%-5d\", a[i][j]); printf(\"\\n\"); } 相似题目 BFS - 迷宫最短路径问题 summary 其实本题也蕴含 DP 问题的思想我们用刚开始走 1 步的点的步数去更新 2 步的点的步数 用前面的数据去更新后面的数据，本身步数的累加便是一个 + 1+1 的更新过程，也蕴含累加的思想 end","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/M_马的遍历/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"BFS","slug":"BFS","permalink":"https://帆帆.icu/tags/BFS/"}]},{"title":"迷宫最短路径问题","text":"迷宫最短路径问题 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;struct note{ int x;//横坐标 int y;//纵坐标 int s;//步数};int main(){ struct note que[2501]; int a[51][51] = { 0 }, book[51][51] = { 0 }; int next[4][2] = { {0,1} ,{1,0} ,{0,-1}, {-1,0} }; int head, tail;//引入队列 int i, j, k, m, n, startx, starty, p, q, tx, ty, flag; //读入目标迷宫大小 scanf(\"%d %d\", &amp;n, &amp;m); //读入迷宫 for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= m; j++) scanf(\"%d\", &amp;a[i][j]); //读入起点和终点 scanf(\"%d %d %d %d\", &amp;startx, &amp;starty, &amp;p, &amp;q); //队列初始化 head = 0; tail = 1; //起点入队 que[1].x = startx; que[1].y = starty; que[1].s = 0; //标记起点 book[startx][starty] = 1; flag = 0;//标识符 while (head &lt; tail) { head++; for (k = 0; k &lt;= 3; k++) { //父单元按规律向4个方向拓展 tx = que[head].x + next[k][0]; ty = que[head].y + next[k][1]; if (tx&lt;1 || tx&gt;n || ty&lt;1 || ty&gt;m) continue;//越界则重新试探 if (a[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0) { //拓展成功则标记拓展的点并将其入队，累加步数。 tail++; book[tx][ty] = 1; que[tail].x = tx; que[tail].y = ty; que[tail].s = que[head].s + 1; } //拓展到目标点时结束拓展调用标识符结束拓展 if (tx == p &amp;&amp; ty == q) { flag = 1; break; } } //若成功标记则结束while循环 if (flag == 1) break; } printf(\"%d\", que[tail].s); getchar(); getchar(); return 0;} 思路详解 1第一步：定义note结构体 我们要记录最路径，路径大小和经过的点数有关 顾名思义我们需要在点上做文章 一个点拥有（x，y）坐标 我们定义一个含距离的关于点的结构体 如下： 123456struct note{ int x;//横坐标 int y;//纵坐标 int s;//步数}; 点的个数和迷宫大小有关 这里我们取最大值如下： 1struct note que[2501]; 1第二步：引入队列的思维 BFS 搜索🔍是由父层向下遍历探索所有可能的子结构 探索成功后之前的子层成为了新的父层继续上述操作 不由可以联想到 父到子 &gt;&gt; head 向下试探，成功则 tail++ 子成父 &gt;&gt; head++ 如下： 123456789101112131415161718192021222324252627282930while (head &lt; tail) { head++；//将1单元成为父单元 for (k = 0; k &lt;= 3; k++) { //父单元按规律向4个方向拓展 tx = que[head].x + next[k][0]; ty = que[head].y + next[k][1]; if (tx&lt;1 || tx&gt;n || ty&lt;1 || ty&gt;m) continue;//越界则重新试探 if (a[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0) { //拓展成功则标记拓展的点并将其入队，累加步数。 tail++;//扩充队列,将新的点入队 book[tx][ty] = 1; que[tail].x = tx; que[tail].y = ty; que[tail].s = que[head].s + 1; } //拓展到目标点时结束拓展调用标识符结束拓展 if (tx == p &amp;&amp; ty == q) { flag = 1; break; } } //若成功标记则结束while循环 if (flag == 1) break; } 1第三步：最小路径 问题 1：为什么拓展到终点时必为最短路径？ 解答：因为每一层拓展均为步数加 1，所以拓展的过程中步数是一样累加的 并没有多走的情况，同步出发，并且只要到终点后 while 循环便会停止，所得 &gt; 一定为最短路径 问题 2：输出最短路径时为什么要用 que[tail].s ? 解答：我们刚开始定义 tail 为 1，tail 表示队尾位置，成功拓展至终点后 ， 终点即为队尾位置即 que [tail].s; summary： （1）本题和 BFS - 马的遍历异同之处？ 本题：将距离 s 定义在结构体之内，使得每一个节点均含有到此的最小步数 other：马的遍历是将距离放在一个二维数组里面，二维数组的下标为位置坐标，我们需要关注的是起点位置为队列的首位，符合以下对应关系： 坐标：(sx,sy)&gt;&gt;(qun [1].x,qun [1].y) 即队列第一单元 步数：a [sx][sy]=0&gt;&gt;a [qun [1].x][qun [1].y]=0 即队列第一单元对应 0 步","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/M_迷宫最短路径问题/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"BFS","slug":"BFS","permalink":"https://帆帆.icu/tags/BFS/"}]},{"title":"全排列","text":"全排列问题 完整代码： 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int n;int a[100], book[100];void dfs(int step) { if (step == n + 1) { for (int i = 1; i &lt;= n; i++) printf(\"%d\", a[i]); printf(\"\\n\"); return; } for (int i = 1; i &lt;= n; i++) { if (book[i] == 0) { a[step] = i; book[i] = 1; dfs(step + 1); book[i] = 0; } } return;}int main(){ scanf(\"%d\", &amp;n); dfs(1); return 0;} 核心代码（DFS 部分）： 1234567891011121314151617void dfs(int step){ if(step==n+1){ for(int i=1;i&lt;=n;i++) printf(\"%d\",a[i]); printf(\"\\n\"); return; } for(int i=1;i&lt;=n;i++){ if(book[i]==0){ a[step]=i; book[i]=1; dfs(step+1); book[i]=0; } } return; } 让我们来深究 DFS 内的具体过程 函数层数和每层函数保留的 i 相等 每一层函数往数组中放入的数即为 i i 的大小也决定了是否能够继续for循环继续放数 return 的过程中必然将上层函数中放入的数收回","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/Q_全排列/","date":"09-16","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"}]},{"title":"选数","text":"题目：选数 问题来源：[P1036 NOIP2002 普及组] 选数 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int* p, ans = 0;int isPrime(int m){ int isPrime = 1; int k = sqrt(m); for (int i = 2; i &lt;= k; i++) { if (m % i == 0) { isPrime = 0; break; } } if (isPrime == 0) return 0; else return 1;}//从x单元开始的选数//已选m个数//m个数的和为sum//需要得到k个数,一共n个数void dfs(int x,int m,int sum,int k,int n){ if (m == k) { if (isPrime(sum)) ans++; return; } for (int i = x; i &lt; n; i++) dfs(i+1,m + 1, sum + *(p + i), k, n);//i+1而非x+1 return;}int main(){ int n, k; scanf(\"%d%d\", &amp;n,&amp;k); p = (int*)malloc(sizeof(int) * n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", p + i); dfs(0,0,0,k,n); printf(\"%d\",ans);} 代码解析： 用 DFS 进行高级的枚举操作时，显然当枚举了 K 个数时，我们需要判断 K 个数的和是否为素数，其代码如下: 123456if (m == k) { if (isPrime(sum)) ans++; return; } 枚举时我们用一个 for 循环来选选取当下 DFS 函数需要选入的数 代码如下： 12for (int i = x; i &lt; n; i++) dfs(i+1,m + 1, sum + *(p + i), k, n);//i+1而非x+1 问：为何需要一个选数的起始位点这个参数，即 x？ 答：每一层 DFS 函数选取一个数，选取哪一个数是由 for 循环里面的 i 决定的 假如是 5 个数里面选 3 个数，我们希望的是选第一个数然后再选两个，完成之后，判断其和是否为素数，再把最后一个数换成其下一位的数。 eg： 1 2 3 4 5 第一次选： 1 2 3 然后： 1 2 4 再然后： 1 2 5 我们选数的基准点是第一个数，每次扩选实际上都是选的 i+1 的那个数，起始位点不变，一直变的是相对位点，所以是 i+1 这个相对位点，而非 x+1，如下： 12for (int i = x; i &lt; n; i++) dfs(i+1,m + 1, sum + *(p + i), k, n);//i+1而非x+1 END","path":"2021/09/16/S_算法与数据结构/S_算法/S_搜索🔍/X_选数/","date":"09-16","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"}]},{"title":"并查集","text":"并查集 基础写法 策略：一个联通分度内全部节点的值统一、 方法：结点序号 —— 数组下标，结点的母结点 —— 数组值 inti函数 刚开始时，所有节点彼此独立的 12345void init(){ for (int i = 1; i &lt;= n; i++) id[i] = i;} Find函数 1234bool Find(int x, int y){ return id[x] == id[y];} Union函数 12345678910void Union(int p, int q){ int pid = id[p]; int qid = id[q]; for (int i = 1; i &lt; MAX; i++) { if (id[i] == pid)//p所在连通分度内所有节点全部连接到q结点所在联通分度 id[i] = qid; }} 可以发现的是，该写法最终使每一个联通分量的每一个结点的值统一，每一个联通分度拥有唯一的值，若对于一个很大的联通分量连接到一个小的连通分量上时，要改变该连通分量上有节点的值，是十分耗费时间的！ 以下是优化写法 优化写法（1） 策略：使用算法中的懒策略 , 我们尽量避免计算，直到不得不进行计算 方法：数组的每一项只包含它的父节点的下标值，两个结点 Union 时我们连接他们的根结点即可 inti函数 刚开始时，所有节点彼此独立的 12345void init(){ for (int i = 1; i &lt;= n; i++) id[i] = i;} 寻找根节点root函数 123456int root(int i){ while (i != id[i]) i = id[i]; return i;} Find函数 1234bool Find(int x, int y){ return root[x]==root[y];} Union函数 123456void Union(int p, int q){ int rp = root(p); int rq = root(q); id[rp]=rq;//连接根结点即可} 总结：虽然没有了 For 循环会比基础写法要快一点，但是在某些情况下还是非常慢，例如若我们在 Find 时要回溯一颗非常瘦长的数，我们也需要耗费大量时间 以下是更优写法 优化写法（2） 策略：在写法（1）的基础上，我们在 Union 时考虑带权算法 方法：在 Union 时我们将权重小的作为子叶连接到权重大的上面 inti函数 刚开始时，所有节点彼此独立的 12345678void init(){ for (int i = 1; i &lt;= n; i++) { id[i] = i; size[i]=1;//size[]数组全部初始化为1 }} 寻找根节点root函数 123456int root(int i){ while (i != id[i]) i = id[i]; return i;} Find函数 1234bool Find(int x, int y){ return root[x]==root[y];} Union函数 12345678910111213141516void Union(int p, int q){ int rp = root(p); int rq = root(q); if(rp==rq)return;//本连接就直接退出 if (size[rp] &lt; size(rq)) { size[rq] += size[rp];//权更新 id[rp] = rq;//小的连大的 } else { size[rp] += size[rq]; id[rq] = rp; }} 总结：上述算法已经十分高效了，接下来我们考虑一种更厉害的优化方案 优化写法（3） 策略：路径压缩 方案：将一颗树压平，除了 root 结点外的其它结点全部连接到 root 节点上 inti函数 刚开始时，所有节点彼此独立的 12345678void init(){ for (int i = 1; i &lt;= n; i++) { id[i] = i; size[i]=1;//size[]数组全部初始化为1 }} 寻找根节点root函数 123456789int root(int i){ while (i != id[i]) { id[i]=id[id[id]];//压缩路径 i = id[i]; } return i;} Find函数 1234bool Find(int x, int y){ return root[x]==root[y];} Union函数 12345678910111213141516void Union(int p, int q){ int rp = root(p); int rq = root(q); if(rp==rq)return;//本连接就直接退出 if (size[rp] &lt; size(rq)) { size[rq] += size[rp];//权更新 id[rp] = rq;//小的连大的 } else { size[rp] += size[rq]; id[rq] = rp; }} 实际运用——渗滤 题目 对一个渗滤图判断是否能进行渗滤 —— 从上到下是否连通 例图 由右图可知，显然上下并不连通！！！ 代码实现(VS2019) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n;int* id, * open;void Egscanf(){ printf(\"样例:\\n\"); printf(\"5\\n\"); printf(\"11010\\n\"); printf(\"00010\\n\"); printf(\"01011\\n\"); printf(\"10100\\n\"); printf(\"11011\\n\"); printf(\"******\\n\"); printf(\"1为open、0为close\\n\");}void init()//结点初始化{ for (int i = 1; i &lt;= n * n; i++) { *(id + i) = i; *(open + i) = 0; }}int root(int x){ while (x != id[x]) { id[x] = id[id[x]];//压缩树 x = id[x]; } return x;}bool Find(int x, int y){ return root(x) == root(y);}void Union(int x){ int sx = x - n; int xx = x + n; int zx = x - 1; int yx = x + 1; if (x&gt;n&amp;&amp; *(open + sx) == 1) { int rx = root(x); int rsx = root(sx); if(!Find(x,sx)) id[rx] = sx;//连接根节点即可 } if (x&lt;=(n*n-n)&amp;&amp; *(open + xx) == 1) { int rx = root(x); int rxx = root(xx); if (!Find(x, xx)) id[rx] = xx;//连接根节点即可 } if (((x-1)%n!=0)&amp;&amp; *(open + zx) == 1) { int rx = root(x); int rzx = root(zx); if (!Find(x, zx)) id[rx] = zx;//连接根节点即可 } if ((x%n!=0)&amp;&amp; *(open + yx) == 1) { int rx = root(x); int ryx = root(yx); if (!Find(x, yx)) id[rx] = yx;//连接根节点即可 }}void Duru()//读入{ printf(\"请输入渗滤装置图的边长:\"); scanf_s(\"%d\", &amp;n); id = (int*)malloc((n*n+1)*sizeof(int)); open = (int*)malloc((n * n + 1) * sizeof(int)); init(); int* p = (int*)malloc((n + 1) * sizeof(int)); printf(\"请输入渗滤装置图\\n\"); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { scanf_s(\"%1d\", p + j); if (*(p + j) == 1) { *(open + (j + (i - 1) * n)) = 1; Union(j + (i - 1) * n); } } } printf(\"已成功读入并处理该图！！！\\n\"); printf(\"命令样式:1 (一号命令、打印渗滤图)\\n\"); printf(\"命令样式:2 8(二号命令、将8号结点位置渗滤功能open)\\n\"); printf(\"命令样式:3 4 7(三号命令、查询4号结点和7号结点是否连通)\\n\"); printf(\"命令样式:4(四号命令、查询该渗滤装置是否能工作)\\n\"); printf(\"请输入控制命令\\n\");}void SX(){ id[0] = 0; id[n * n + 2] = n * n + 2; int roots = id[0]; for (int i = 1; i &lt;= n; i++) { int ri = root(i); id[ri] = roots; } int rootx = id[n*n+2]; for (int i = n*n-n+1; i &lt;= n*n; i++) { int ri = root(i); id[ri] = rootx; }}void print(){ for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { printf(\"%5d\", root(j + n * (i - 1))); } printf(\"\\n\"); }}int main(){ Egscanf(); Duru(); int o=4, p, q; while (o != -1) { scanf_s(\"%d\", &amp;o); if (o == 1) print(); if (o == 2) { scanf_s(\"%d\", &amp;p); open[p] = 1; Union(p); printf(\"%d号结点位置渗滤功能已 open\\n\",p); } if (o == 3) { scanf_s(\"%d%d\", &amp;p, &amp;q); if (Find(p, q)) printf(\"%d结点和%d结点连通\\n\", p, q); else printf(\"%d结点和%d结点不连通\\n\", p, q); } if (o == 4) { SX(); if(Find(0,n*n+2)) printf(\"该渗滤装置能工作!!!\\n\"); else printf(\"该渗滤装置不能工作!!!\\n\"); break; } } return 0;} End","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/B_并查集/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"并查集","slug":"并查集","permalink":"https://帆帆.icu/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"Balanced Lineup","text":"Balanced Lineup 题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152C#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define MAX 50010int h[MAX];int Fmax[MAX][20];int Fmin[MAX][20];int N, Q;int max(int x, int y){ return x &gt; y ? x : y;}int min(int x, int y){ return x &gt; y ? y : x;}void ST_create(){ //初始化0列 for (int i = 1; i &lt;= N; i++) Fmax[i][0] = Fmin[i][0] = h[i]; int k = log2(N);//log(N)/log(2.0) for(int j=1;j&lt;=k;j++)//1到k列 for (int i = 1; i &lt;= N - (1 &lt;&lt; j) + 1; i++) { Fmax[i][j] = max(Fmax[i][j - 1], Fmax[i + (1 &lt;&lt; (j - 1))][j - 1]); Fmin[i][j] = min(Fmin[i][j - 1], Fmin[i + (1 &lt;&lt; (j - 1))][j - 1]); }}int RMQ(int l,int r){ int k = log2(r - l + 1); int m1 = max(Fmax[l][k], Fmax[r - (1 &lt;&lt; k) + 1][k]); int m2 = min(Fmin[l][k], Fmin[r - (1 &lt;&lt; k) + 1][k]); return m1 - m2;}int main(){ int a, b; while (scanf(\"%d %d\", &amp;N, &amp;Q)!=EOF) { for (int i = 1; i &lt;= N; i++) scanf(\"%d\", &amp;h[i]); ST_create(); while (Q--) { scanf(\"%d%d\", &amp;a, &amp;b); printf(\"%d\\n\", RMQ(a, b)); } } return 0;}","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Balanced Lineup/","date":"09-16","excerpt":"","tags":[{"name":"二分","slug":"二分","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E5%88%86/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"RMQ","slug":"RMQ","permalink":"https://帆帆.icu/tags/RMQ/"}]},{"title":"Bit Map","text":"引言 一、类似于桶排序的思想，但我们从一个 int 缩小到一个 bit，占用缩小 32 倍 ` 二、对于一个 32位系统而言，我们用 bitmap 可以存储 42亿左右的巨额数据量 三、我们能够精确迅速地判断某个数据是否存在某个集合中！ 位运算 一、大小关系 1 int 等于 4 byte 1 byte 等于 8 二进制位 二、运算符 &lt;&lt; 左移 —— 乘 2 &gt;&gt; 右移 —— 除 2 举个例子： 123int n = 1; //00000000 00000000 00000000 00000001printf(\"%d\",n &lt;&lt; 1); //00000000 00000000 00000000 00000010//&gt;&gt;同理 ~ ——0 和 1 互换（含符号位）（取反） 举个例子： 123456int n = 1; printf(\"%d\",~n);//00000000 00000000 00000000 00000001(1的原码)//00000000 00000000 00000000 00000001(1的补码)//11111111 11111111 11111111 11111110(~取反运算得到B补码)//10000000 00000000 00000000 00000010(B补码的原码，取反加1，即-2) 对任意一个二进制数取反的含义是什么？1010 取反是 0101 0100 取反是 1011，容易看出取反的本质就是找一个数和原来的相加得到每一位均为 1 的数 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() { int num = 10; //00000000 00000000 00000000 00001010 num = num | (1 &lt;&lt; 5); //00000000 00000000 00000000 00101010 printf(\"%d\\n\", num); system(\"pause\"); return 0;} 示例 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 99999999int bitmap[MAX];//(32x99999999=3,199,999,968约32亿个bit)int main(){ long long p; printf(\"请输入非负整数\\n\"); while (scanf_s(\"%lld\", &amp;p) != EOF) bitmap[p &gt;&gt; 5] = bitmap[p &gt;&gt; 5] | (1 &lt;&lt; p &amp; (32 - 1)); //删除某个数 //bitmap[p &gt;&gt; 5] = bitmap[p &gt;&gt; 5] &amp; ~ (1 &lt;&lt; p &amp; (32 - 1));a return 0;} 参考文献 位数组 (bit 数组) END","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Bit Map/","date":"09-16","excerpt":"","tags":[{"name":"位运算","slug":"位运算","permalink":"https://帆帆.icu/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"位图","slug":"位图","permalink":"https://帆帆.icu/tags/%E4%BD%8D%E5%9B%BE/"}]},{"title":"D To E","text":"题目来源 From D to E and Back 题目解析 问题一：如何存图？ 因为要频繁地判断两节点间是否有边，所以这里采用邻接矩阵最为方便 问题二：什么情况下 E 不可能存在？ 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445C++#include&lt;iostream&gt;#define MAX 500#define REP(i,b,e) for(int i=(b);i&lt;(e);i++)using namespace std;int map[MAX][MAX];bool solve(int n){ REP(i, 0, n) REP(j, 0, n) { bool flag1 = false, flag2 = false; REP(k, 0, n) { if (map[i][k] &amp;&amp; map[j][k]) flag1 = true; if (map[i][k] ^ map[j][k]) flag2 = true; } if (flag1 &amp;&amp; flag2) return false; } return true;}int main(){ int x, n, m; cin &gt;&gt; x; while (x--) { memset(map, 0, sizeof(map)); cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b; cin &gt;&gt; a &gt;&gt; b; map[a][b] = 1; } if (solve(n)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; } return 0;}","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/D To E/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"二叉树重建","text":"题目来源 二叉树重建 题目解析 本题是通过前序遍历和中序遍历得到的顺序推出后序遍历，也就是有两个字符串推出另外一个字符串 样例输入：DBACEGF ABCDEFG 一、由前序得到 root 结点 D（pre [0]），再中序中寻找到对应位置，代码如下： 1234int len = 0;while (pre[0] != in[len]){ len++;} 二、截取 D 的左右子树 D 的左子树的前序遍历为 BAC、中序遍历为 ABC D 的右子树的前序遍历为 EGF、中序遍历为 EFG 重复上述步骤 三、输出当前根节点 因为是后序遍历最后要输出根结点 用 C 语言手动实现字符串截取函数，代码如下： 12345678910111213char* Intercept_string(char *p, int s, int n){ char* h; int j = 0; h = (char*)malloc((n + 1) * sizeof(char)); for (int i = s; i &lt; n + s; i++) { *(h+j)= *(p+i); j++; } *(h + j) = '\\0'; //注意加上字符串截止符 return h;}//p：待截取字符串首地址、s：起始位置、n：截取长度 完整代码 C语言代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define MAX 100char* Intercept_string(char* p, int s, int n){ char* h; int j = 0; h = (char*)malloc((n + 1) * sizeof(char)); for (int i = s; i &lt; n + s; i++) { *(h + j) = *(p + i); j++; } *(h + j) = '\\0'; return h;}void pose_ergodic(char pre[], char in[]){ if (strlen(pre) &lt;= 0) return; int len = 0; while (pre[0] != in[len]) { len++; } pose_ergodic(Intercept_string(pre, 1, len), Intercept_string(in, 0, len)); pose_ergodic(Intercept_string(pre, len + 1, strlen(pre) - 1), Intercept_string(in, len + 1, strlen(in) - 1)); printf(\"%c\", pre[0]);}int main(){ char ch1[MAX], ch2[MAX]; while(~scanf(\"%s%s\", &amp;ch1,&amp;ch2)) { getchar(); pose_ergodic(ch1, ch2); printf(\"\\n\"); } return 0;} C++代码 1234567891011121314151617181920212223242526#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;void postErgodic(string pre, string in){ if (pre.size() != 0) { int len = 0; len = in.find(pre[0]); postErgodic(pre.substr(1,len),in.substr(0,len)); postErgodic(pre.substr(len + 1), in.substr(len + 1)); cout &lt;&lt; pre[0]; }}int main(){ string pre, in; while (cin&gt;&gt;pre&gt;&gt;in) { postErgodic(pre, in); cout &lt;&lt; endl; } return 0;}","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/E_二叉树重建/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"BT","slug":"BT","permalink":"https://帆帆.icu/tags/BT/"},{"name":"String","slug":"String","permalink":"https://帆帆.icu/tags/String/"}]},{"title":"Entropy","text":"题目来源 Entropy 题目解析 问题一：本题什么意思？ 用熵编码简化 ASCII 码，熵编码器是一种数据编码方法，通过将消息编码为删除 “浪费” 或 “额外” 信息，实现无损数据压缩。换句话说，熵编码会删除最初不需要的信息来准确编码消息。高度熵意味着信息会浪费大量信息：在 ASCII 中编码的英语文本是具有非常高熵的消息类型示例。已经压缩的消息，如 JPEG 图形或 ZIP 档案，几乎没有熵，并没有从熵编码的进一步尝试中获益。 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;iostream&gt;#define MAX 30using namespace std;int statistics[MAX];//字母个数int main(){ while (1) { string s; cin &gt;&gt; s; if (s == \"END\") break; memset(statistics, 0, sizeof(statistics)); int n = s.size(); for (int i = 0; i &lt; n; i++) { if (s[i] == '_') statistics[26]++; else statistics[s[i] - 'A']++; } priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for (int i = 0; i &lt;=26; i++) if (statistics[i]) q.push(statistics[i]); int ans = n; while (q.size() &gt;2) { int t, t1, t2; t1 = q.top();q.pop(); t2 = q.top();q.pop(); t = t1 + t2; q.push(t); ans += t; } printf(\"%d %d %.1lf\\n\", n * 8, ans, (double)(n * 8) / ans); } return 0;} Note 将 ans 初始化为 n 意义何在？ 答：最后一次合并的结果的大小一定是 n（哈夫曼树的树根 = 叶子权值之和），这样可以省掉最后一次合并的运算 为什么是 q.size ()&gt;2 因为ans初始化为n，所以最后一次合并不用进行，即还剩下两个节点时就跳出循环了，对于刚好两个结点的情况也适用！ 当 ans 初始化为 0 时怎么写？ 12345678910int ans = 0;while (q.size() !=1){ int t, t1, t2; t1 = q.top(); q.pop(); t2 = q.top(); q.pop(); t = t1 + t2; q.push(t); ans += t;}","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Entropy/","date":"09-16","excerpt":"","tags":[{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Fence Repair","text":"题目来源 Fence Repair 题目解析 问题一：该题的类型是什么？ 每切开一块木板就得到两块木板，两块木板的长度之和等于之前的那一块木板，类似于二叉树 本题又是一道求解最优值的问题，不难想到最优二叉树，即哈夫曼树。 完整代码 1234567891011121314151617181920212223242526272829303132C++#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;Q;int main(){ int n, m; cin &gt;&gt; n; while (n--) { cin &gt;&gt; m; Q.push(m); } if (Q.size() == 1) cout &lt;&lt; m; else { long long sum = 0; while (Q.size() != 1) { int a = Q.top(); Q.pop(); int b = Q.top(); Q.pop(); sum += a + b; Q.push(a+b); } cout &lt;&lt; sum; } return 0;}","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Fence Repair/","date":"09-16","excerpt":"","tags":[{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Huffman 编码树","text":"题目来源 Huffman 编码树 题目解析 问题一：什么是 Huffman 树？ 点击转到 - 哈夫曼树 问题二：需要把整个 huffman 树构造出来吗？ 答：不需要，题目要求我们求 WPL 的大小，所以我们在优先队列里实现这个计算过程就可以了。 问题三：什么是优先队列？ 点击转到 - C++ 完整代码 12345678910111213141516171819202122232425262728C++#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;Q;int ans;int main(){ int n, x; cin &gt;&gt; n; while (n--) { cin &gt;&gt; x; Q.push(x); } while (Q.size()!= 1) { int a, b; a = Q.top(); Q.pop(); b = Q.top(); Q.pop(); Q.push(a + b); ans += a + b; } cout &lt;&lt; ans; return 0;} 要点 1：生成哈夫曼树可以使得带权外部路径长度 WPL 总和最小 要点 2：新生成的结点值之和即为最终答案，所以无需等到哈夫曼树完全生成后再计算","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Huffman 编码树/","date":"09-16","excerpt":"","tags":[{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Inverting Huffman","text":"题目来源 Inverting Huffman CSDN - 反转树 题目解析 问题一：本题有最大值吗？ 本题不存在最大值，因为通过等比放大，我们可以得到无数种可能，二叉树的形态不变，节点值的大小可以无限大。 问题二：刚开始时基准数（temp）为什么为 1？ 因为我们要求最小值，最后一层结点值初始化为 1 时可得到最小值 且 temp 不仅是用来初始化最后一层节点的值，也用来更新每一层的最大值 最后一层的最大值恰好等于初始值 问题三：本题要点是什么？ vector 数组记录每一层 + temp 更新 + 哈夫曼树 完整代码 123456789101112131415161718192021222324252627282930313233343536C++#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAX 55using namespace std;vector&lt;long long&gt;deep[MAX];//向量数组int main(){ int n, x; while (cin &gt;&gt; n) { for (int i = 0; i &lt; n; i++) deep[i].clear();//清空每一个vector int maxd = 0; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x; deep[x].push_back(0);//几个0就代表几个元素 maxd= max(maxd, x);//求最大深度 } long long temp = 1;//基准数，初始化为1 for (int i = maxd; i &gt; 0; i--) { for (int j = 0; j &lt; deep[i].size(); j++) if (!deep[i][j]) deep[i][j] = temp; sort(deep[i].begin(),deep[i].end()); for (int j = 0; j &lt; deep[i].size(); j += 2) deep[i - 1].push_back(deep[i][j] + deep[i][j + 1]); temp = *(deep[i].end() - 1);//第i层的最大值 } cout &lt;&lt; *deep[0].begin() &lt;&lt; endl; } return 0;}","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Inverting Huffman/","date":"09-16","excerpt":"","tags":[{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Jungle Roads","text":"题目来源 Jungle Roads 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677C++#include&lt;cstring&gt;#include&lt;iostream&gt;#define MAX 30using namespace std;int map[MAX][MAX];int n, book[MAX], dis[MAX];void init(){ memset(map, 0x3f, sizeof(map)); for (int i = 0; i &lt; MAX; i++ ) { book[i] = 0; dis[i] = 0x3f3f3f3f; }}int prim(int s){ int sum = 0; book[s] = 1; for (int i = 1; i &lt;= n; i++)//记录相邻点的距离 dis[i] = map[s][i]; int m = n-1; while (m--) { int min = 0x3f3f3f3f, t; for (int i = 1; i &lt;= n; i++) { if (book[i] == 0 &amp;&amp; dis[i] &lt; min) { min = dis[i]; t = i; } } sum += dis[t]; book[t] = 1; for (int i = 1; i &lt;= n; i++) { if (book[i] ==0 &amp;&amp; dis[i] &gt; map[t][i]) dis[i] = map[t][i]; } } return sum;}int main(){ while (cin &gt;&gt; n &amp;&amp; n) { init();//初始化 int m = n - 1; while (m--)//读入 { char ch; cin &gt;&gt; ch; int a = ch - 'A' + 1; int b; cin &gt;&gt; b; if (b != 0) { while (b--) { int c; cin &gt;&gt; ch&gt;&gt;c; map[a][ch - 'A' + 1] = c; map[ch - 'A' + 1][a] = c; } } } cout&lt;&lt;prim(1)&lt;&lt;endl;//prim算法 } return 0;}/* 一、初始化 二、数据读入 三、prim算法*/ 题目解析 END","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Jungle Roads/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"MST","slug":"MST","permalink":"https://帆帆.icu/tags/MST/"},{"name":"Prim","slug":"Prim","permalink":"https://帆帆.icu/tags/Prim/"}]},{"title":"LCA","text":"LCA简介 LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点 u 和 v 最近的公共祖先。 ——— 来自百度百科 暴力穷举 一、建图（father 数组） 二、标记法 1、u 结点的前辈全部标记后，v 结点再向上一层一层 find 直到寻找到被标记的结点，该节点即为 LCA 2、DFS 找出结点深度，u v 跳到同一层，再同步向上跳，当跳到同一个节点时，该结点即为 LCA 例题： Nearest Common Ancestors(待修正) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#define MAX 10010using namespace std;int father[MAX], book[MAX];void init(int n){ for(int i=1;i&lt;=n;i++) father[i] = i;}int LCA(int u, int v){ if (u == v) //同一结点的情况 return u; book[u] = 1; //防止漏掉u恰好是v父亲的情况 while (u != father[u]) { u = father[u]; book[u] = 1; } while (v != father[v]) { v = father[v]; if (book[v] == 1) return v; } return v;}int main(){ int t; cin &gt;&gt; t; while (t--) { int m; cin &gt;&gt; m; init(m); m--; while(m--) { int a, b; cin &gt;&gt; a &gt;&gt; b; father[b] = a; } int p, q; cin &gt;&gt; p &gt;&gt; q; cout &lt;&lt; LCA(p, q)&lt;&lt;endl; } return 0;} 例题：How far away ？ 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int MAX = 40005;int n, m, k, F[MAX][20];int head[MAX], dist[MAX], d[MAX], cnt;struct Edge{ int t, c, next;}e[MAX&lt;&lt;2];int LCA(int u, int v){ }int main(){ int t, n, f; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; f; n--; while (n--) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; } while (f--) { int p, q; cin &gt;&gt; p &gt;&gt; q; cout &lt;&lt; LCA(p, q) &lt;&lt; endl; } } return 0;}","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/LCA/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"LCA","slug":"LCA","permalink":"https://帆帆.icu/tags/LCA/"}]},{"title":"图的遍历","text":"题目来源 图的遍历 题目解析 问题一：选择什么建图方式？ 优先考虑链式前向星或邻接表，因为我们要遍历整个图，所以通常情况下从 a 节点出发遍历能到达的节点，而上述两种建图方法恰好保留某点所有邻接点的值。 问题二：单纯的 DFS 可以吗？ 这个当然可以，但是比较费时，可能会时间超限。 问题三：有什么巧妙地做法？ 倒叙构建该有向图，然后从编号最大点开始 DFS，其所能到达的点能到达的最大点就是该编号，用一个 maxn 数组记录该值。 完整代码 1234567891011121314151617181920212223242526272829303132333435363738C++#include&lt;iostream&gt;#define MAX 100005using namespace std;struct Edge{ int to, next;}edge[MAX];int n, m, cnt, head[MAX], maxn[MAX];void add(int u, int v){ edge[++cnt].to = v;//从1开始时就不用初始化为-1了 edge[cnt].next = head[u]; head[u] = cnt; }void dfs(int v,int u){ if (maxn[u]) return; maxn[u] = v; for (int i = head[u]; i; i = edge[i].next) dfs(v, edge[i].to);}int main(){ cin &gt;&gt; n &gt;&gt; m; while (m--) { int u, v; cin &gt;&gt; u &gt;&gt; v; add(v, u); } for (int i = n; i &gt; 0; i--) dfs(i, i); for (int i = 1; i &lt;=n; i++) cout &lt;&lt; maxn[i]&lt;&lt;' '; return 0;}","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/T_图的遍历/","date":"09-16","excerpt":"","tags":[{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"新二叉树","text":"题目来源 P1305 新二叉树 题目解析 问题一：数组存储 or 链式存储 ？ 如果采用链式存储的话每次读数据的时都要寻找当前读入的数据的根节点的位置，并不高效！ 所以我们采用数组存储 问题二：如何用数组存储？ 题目给出的数据是父亲和两个孩子 所以我们可以记录根结点、然后用 L 数组记录左孩子、R 数组记录右孩子 问题三：数据输入时出现断层会有影响吗？ 不会，因为给出的数据一定会构成二叉树，某一次数据的断层并不影响最终的整体连接效果。 完整代码 1234567891011121314151617181920212223242526272829C#include&lt;stdio.h&gt;#define MAX 100int l[MAX], r[MAX], root;void pre_ergodic(int t){ if (t != '*' - 'a') { printf(\"%c\", t + 'a'); pre_ergodic(l[t]); pre_ergodic(r[t]); }}int main(){ int n; scanf(\"%d\", &amp;n); getchar(); for (int i = 0; i &lt; n; i++) { char ch[4]; scanf(\"%s\",&amp;ch); if (i==0) root = ch[0] - 'a'; l[ch[0] - 'a'] = ch[1] - 'a'; r[ch[0] - 'a'] = ch[2] - 'a'; } pre_ergodic(root); return 0;}","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/X_新二叉树/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"BT","slug":"BT","permalink":"https://帆帆.icu/tags/BT/"}]},{"title":"最小生成树","text":"题目来源 最小生成树 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273C#define MAX 5010#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int n, m;int map[MAX][MAX];int book[MAX], dis[MAX];void init(){ memset(map, 0x3f, sizeof(map)); for (int i = 1; i&lt;=n; i++) { book[i] = 0; dis[i] = 0x3f3f3f3f; }}int prim(int s){ int sum = 0; book[s] = 1; for (int i = 1; i &lt;= n; i++) dis[i] = map[s][i]; int m = n - 1; while (m--) { int min = 0x3f3f3f3f, t; for (int i = 1; i &lt;= n; i++) { if (min &gt; dis[i] &amp;&amp; book[i] == 0) { min = dis[i]; t = i; } } sum += dis[t]; book[t] = 1; for (int i = 1; i &lt;= n; i++) { if (dis[i] &gt; map[t][i] &amp;&amp; book[i] == 0) dis[i] = map[t][i]; } } return sum;}int main(){ init();//初始化 cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (map[a][b]&gt;c) { map[a][b] = c; map[b][a] = c; } } int p=prim(1); int flag = 0; for (int i = 1; i &lt;= n; i++) { if (book[i] == 0) flag = 1; } if (flag) cout &lt;&lt; \"orz\"; else cout &lt;&lt; p; return 0;} 题目解析 一、初始化 二、读入数据 三、Prim 算法 END","path":"2021/09/16/S_算法与数据结构/S_算法/T_图论/Z_最小生成树/","date":"09-16","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"MST","slug":"MST","permalink":"https://帆帆.icu/tags/MST/"},{"name":"Prim","slug":"Prim","permalink":"https://帆帆.icu/tags/Prim/"}]},{"title":"SnakeEating","text":"贪吃蛇 运行条件 需要安装 EasyX 方式一：EasyX 方式二：见运行附件 VC++6.0 运行需要设置多线程 方法：Project-&gt;Settings-&gt;C/C+±&gt;Code Generation-&gt;Use run-time libray-&gt;Debug Multithread，或 Multithread，或 Debug Multithread DLL， 或 Multithread DLL 都可以 VS 2019 运行需要使用多字节字符集 方法：项目 -&gt; 属性 -&gt; 高级 -&gt; 字符集 -&gt; 使用多字节字符集 Music 和 Picture 文件需要放在对应目录下 运行附件（百度云） 提取码：lsd7 运行附件（阿里云） 提取码：7lpl 更新说明 引入多线程 加入感谢名单 BGM—GET 微调 吃 food 时增加分数显示 开始时自动切换为英文输入法问题 修复 game over 后需要按两次 enter 键 引导画面文字播报与 BGM 踩点，缩短时间 修复进入游戏后连敲三下 Enter 的闪退问题 完整代码 (VC++6.0) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557C#include&lt;math.h&gt;#include&lt;time.h&gt;#include&lt;conio.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;process.h&gt;#include&lt;windows.h&gt;#include&lt;graphics.h&gt;#include &lt;mmsystem.h&gt;#pragma comment(lib, \"winmm.lib\")#define lx 640#define ly 480#define Sup 7//换肤模式突变点#define MAX 500int key,thread,flag, mark, p, ans, i = 1, threadend = 1;; char s[1000]; double speed = 80;enum DIR//4个方向,enum为枚举类型{ PAUS, UP, DOWN, LEFT, RIGHT,};struct Food{ int x; int y; int r;//半径 bool flag; DWORD color;}food;struct Snake{ int size; int speed; int dir; DWORD color1; DWORD color2; POINT coor[MAX];}snake;void BGM_ALL(); //全局BGM unsigned __stdcall BGM_GET(void* pArguments); //吃食物BGM void BGM_FAIL(); //失败BGM void Duce(); //引导菜单 void Startmenu(); //开始菜单 void Overmenu(); //结束菜单 void Snakeinit(); //蛇初始化 void Foodinit(); //食物初始化 void Init(); //初始化 void Drawframe(); //画边框 void Skinsystem(int i); //皮肤系统 void Drawsnake(); //普通切换皮肤模式 void SupDrawsnake(); //快速切换皮肤模式 void Drawfood(); //画食物 void Draw(); //绘图 void Firstcontrol(); //按键交互 void Keycontrol(); //首次控制 void Snakemove(); //蛇移动 void Eatfood(); //吃食物void Generatefood(); //生成食物int Snakebump(); //蛇撞墙 int Eatself(); //咬自己 void Print(); //结束输出 void Reset(); //重置 void Thank(); //内测感谢名录 void Shift(); //按下Shift键void main(){ //多线程开始 HANDLE hThread; unsigned threadID; hThread = (HANDLE)_beginthreadex(NULL, 0, &amp;BGM_GET, NULL, 0, &amp;threadID); BGM_ALL(); Init(); Startmenu(); if (!key)//第一次开始按下shift键 { Shift(); key = 1; } while (1) { Sleep(long(speed)); Draw(); if (flag == 0) { Firstcontrol(); flag = 1; } Snakemove(); if (Eatself() || Snakebump()) { mciSendString(\"close BGM1\", 0, 0, 0); BGM_FAIL(); break; } Eatfood(); } Overmenu(); switch (_getch()) { case 13: { i = 1; speed = 80; flag = mark = ans = 0; Reset(); threadend = 0; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); threadend = 1; main(); } break; case 27: Thank(); closegraph(); Print(); break; } //多线程结束 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread);}void BGM_ALL(){ mciSendString(\"open ./Music/Scheming_Weasel.mp3 alias BGM1\", 0, 0, 0); mciSendString(\"play BGM1 repeat\", 0, 0, 0);}unsigned __stdcall BGM_GET(void* pArguments){ while (1) { if (thread) { mciSendString(\"open ./Music/Get.wav alias BGM2\", 0, 0, 0); mciSendString(\"play BGM2 wait\", 0, 0, 0); mciSendString(\"close BGM2 \", 0, 0, 0); thread = 0; } if (!threadend) break; } return 0;}void BGM_FAIL(){ mciSendString(\"open ./Music/Gameover.wav alias BGM3\", 0, 0, 0); mciSendString(\"play BGM3 wait\", 0, 0, 0); mciSendString(\"close BGM3 \", 0, 0, 0);}void Duce(){ if (p == 0) { p = 1; Sleep(300); IMAGE one;//定义一个图片名. loadimage(&amp;one, \"Picture\\\\01.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;one);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE two;//定义一个图片名. loadimage(&amp;two, \"Picture\\\\02.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;two);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE three; loadimage(&amp;three, \"Picture\\\\03.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;three);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1400); IMAGE four; loadimage(&amp;four, \"Picture\\\\04.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;four);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE five; loadimage(&amp;five, \"Picture\\\\05.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;five);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1400); cleardevice(); }}void Startmenu(){ Duce(); while (_kbhit()) getchar(); IMAGE welcome; loadimage(&amp;welcome, \"Picture\\\\00.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;welcome);//绘制图像到屏幕，图片左上角坐标为(0,0) while (1) { if (_getch() == 13) break; }}void Snakeinit(){ srand(GetTickCount()); snake.color1 = RGB(0, 235, 229); snake.size = 4; snake.speed = 10; snake.dir = PAUS; int randomx = rand() % (lx - 100) + 50; int randomy = rand() % (ly - 100) + 50; for (int i = 0; i &lt;= snake.size - 1; i++) { snake.coor[i].x = (randomx / 10) * 10 - 10 * i; //（除10乘10类方格化处理） snake.coor[i].y = (randomy / 10) * 10; }}void Foodinit(){ int j; food.flag = 0; while (!food.flag) { Generatefood(); for (j = 0; j &lt; snake.size; j++) if (fabs(snake.coor[j].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[j].y - food.y) &lt;= food.r) Generatefood(); food.flag = true; }}void Init(){ initgraph(lx, ly);//初始化窗口，大小640*480,/*SHOWCONSOLE*/ Snakeinit();//蛇初始化 Foodinit();//食物初始化}void Drawframe(){ setlinestyle(PS_SOLID, 20); setlinecolor(RGB(93, 107, 153)); rectangle(0, 0, 640, 480);}void Skinsystem(int q){ int i; switch (q) { case 1://YES //蛇头 setfillcolor(RGB(93, 107, 153)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(150, 157, 177)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 2://YES //蛇头 setfillcolor(RGB(186, 63, 110)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(248, 237, 203)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 3://YES setfillcolor(RGB(127, 205, 238)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 4://YES //蛇头 setfillcolor(RGB(221, 192, 179)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 5://YES setfillcolor(RGB(113, 111, 114)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; //蛇头 case 6://YES setfillcolor(RGB(206, 124, 128)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(170, 175, 231)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 7://YES setfillcolor(RGB(223, 165, 161)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(123, 130, 184)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; }}void SupDrawsnake(){ if (i &lt;= 7) { Skinsystem(i); i++; } else { Skinsystem(1); i = 1; }}void Drawsnake(){ if (i &lt;= 7) Skinsystem(i); else { Skinsystem(1); i = 1; }}void Drawfood(){ srand(GetTickCount()); if (food.flag) { setfillcolor(RGB(rand() % 256, rand() % 256, rand() % 256)); solidcircle(food.x, food.y, food.r); }}void Draw(){ cleardevice(); BeginBatchDraw();//双缓冲绘图 setbkcolor(RGB(204, 213, 240));//背景色 cleardevice();//清空绘图设备 Drawframe();//画边框 //画蛇(两种模式) if (ans % Sup == 0 &amp;&amp; ans &gt;= 1) SupDrawsnake(); else Drawsnake(); Drawfood();//画食物 EndBatchDraw();//双缓冲绘图结束}void Firstcontrol(){ switch (_getch()) { case 'W': case'w': case 72: if (snake.dir != DOWN) snake.dir = UP; break; case 'S': case 's': case 80: if (snake.dir != UP) snake.dir = DOWN; break; case 'A': case 'a': case 75: if (snake.dir != RIGHT) snake.dir = LEFT; break; case 'D': case 'd': case 77: if (snake.dir != LEFT) snake.dir = RIGHT; break; case 13: Firstcontrol(); break; }}void Keycontrol()//按键控制{ if (_kbhit()) { char key = _getch(); //72,80,75,77 switch (key) { case 'W'://上 case'w': case 72: if (snake.dir != DOWN) snake.dir = UP; break; case 'S'://下 case 's': case 80: if (snake.dir != UP) snake.dir = DOWN; break; case 'A'://左 case 'a': case 75: if (snake.dir != RIGHT) snake.dir = LEFT; break; case 'D'://右 case 'd': case 77: if (snake.dir != LEFT) snake.dir = RIGHT; break; case 13: getchar(); break; } }}void Snakemove(){ int i; for (i = snake.size - 1; i &gt; 0; i--) snake.coor[i] = snake.coor[i - 1]; Keycontrol(); switch (snake.dir) { case UP: snake.coor[0].y -= snake.speed; break; case DOWN: snake.coor[0].y += snake.speed; break; case LEFT: snake.coor[0].x -= snake.speed; break; case RIGHT: snake.coor[0].x += snake.speed; break; case PAUS: getchar(); break; }}void Eatfood(){ if (food.flag &amp;&amp; fabs(snake.coor[0].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[0].y - food.y) &lt;= food.r) { thread = 1;//多线程开始执行 i++; ans++; snake.color1 = food.color; if (speed &gt; 60) speed -= 0.05; food.flag = false; mark += food.r; snake.size += food.r*2/3; //显示分数 settextstyle(26, 0, \"微软雅黑\"); settextcolor(COLORREF RGB(0, 0, 0)); sprintf(s, \"%d\", mark); outtextxy(food.x, food.y, s); } int j; while (!food.flag) { Generatefood(); for (j = 0; j &lt; snake.size; j++) if (fabs(snake.coor[j].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[j].y - food.y) &lt;= food.r) Generatefood(); food.flag = true; }}void Generatefood(){ srand(GetTickCount()); food.x = 10 + (rand() % 60 + 1) * 10; food.y = 10 + (rand() % 44 + 1) * 10; food.color = RGB(rand() % 256, rand() % 256, rand() % 256); food.r = rand() % 6 + 5; return;}int Eatself(){ int j; for (j = 1; j &lt; snake.size; j++) if (snake.coor[j].x == snake.coor[0].x &amp;&amp; snake.coor[j].y == snake.coor[0].y) return 1; return 0;}int Snakebump(){ int k = 10; if (snake.coor[0].x &lt;= k || snake.coor[0].x &gt;= lx - k || snake.coor[0].y &lt;= k || snake.coor[0].y &gt;= ly - k) return 1; return 0;}void Overmenu(){ cleardevice(); IMAGE Game_over;//定义一个图片名. loadimage(&amp;Game_over, \"Picture\\\\game_over.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;Game_over);//绘制图像到屏幕，图片左上角坐标为(0,0) while (1) { if (_getch() == '\\x0d')//回车 break; } cleardevice(); //统计信息 settextstyle(30, 0, \"楷体\"); settextcolor(COLORREF RGB(0, 0, 0)); outtextxy(220, 100, \"GAME OVER\"); sprintf(s, \"%d\", mark); outtextxy(220, 150, \"你的分数为\"); outtextxy(380, 150, s); outtextxy(220, 200, \"按Enter重新游戏 \"); outtextxy(220, 250, \"按Esc退出游戏 \");}void Thank(){ IMAGE thank;//定义一个图片名. loadimage(&amp;thank, \"Picture\\\\06.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;thank);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(4000);}void Print(){ printf(\"\\n\"); printf(\"\\n\"); printf(\"感谢您的陪伴！\\n\"); printf(\"您的分数是: %d 分\\n\", mark); printf(\"\\n\"); printf(\"游戏开发者:\\n\"); printf(\"\\n\"); printf(\"桃花涣小鱼干\\n\"); printf(\"\\n\"); getchar(); getchar();}void Reset(){ int i; for (i = 0; i &lt;= snake.size; i++) snake.coor[i].x = snake.coor[i].y = 0;}void Shift(){ keybd_event(0x10, 0, 0, 0); keybd_event(0x10, 0, KEYEVENTF_KEYUP, 0);} 完整代码 (VS 2019) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557C#include&lt;math.h&gt;#include&lt;time.h&gt;#include&lt;conio.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;process.h&gt;#include&lt;windows.h&gt;#include&lt;graphics.h&gt;#include &lt;mmsystem.h&gt;#pragma comment(lib, \"winmm.lib\")#define lx 640#define ly 480#define Sup 7//换肤模式突变点#define MAX 500int key,thread,flag, mark, p, ans, i = 1, threadend = 1;; char s[1000]; double speed = 80;enum DIR//4个方向,enum为枚举类型{ PAUS, UP, DOWN, LEFT, RIGHT,};struct Food{ int x; int y; int r;//半径 bool flag; DWORD color;}food;struct Snake{ int size; int speed; int dir; DWORD color1; DWORD color2; POINT coor[MAX];}snake;void BGM_ALL(); //全局BGM unsigned __stdcall BGM_GET(void* pArguments); //吃食物BGM void BGM_FAIL(); //失败BGM void Duce(); //引导菜单 void Startmenu(); //开始菜单 void Overmenu(); //结束菜单 void Snakeinit(); //蛇初始化 void Foodinit(); //食物初始化 void Init(); //初始化 void Drawframe(); //画边框 void Skinsystem(int i); //皮肤系统 void Drawsnake(); //普通切换皮肤模式 void SupDrawsnake(); //快速切换皮肤模式 void Drawfood(); //画食物 void Draw(); //绘图 void Firstcontrol(); //按键交互 void Keycontrol(); //首次控制 void Snakemove(); //蛇移动 void Eatfood(); //吃食物void Generatefood(); //生成食物int Snakebump(); //蛇撞墙 int Eatself(); //咬自己 void Print(); //结束输出 void Reset(); //重置 void Thank(); //内测感谢名录 void Shift(); //按下Shift键void main(){ //多线程开始 HANDLE hThread; unsigned threadID; hThread = (HANDLE)_beginthreadex(NULL, 0, &amp;BGM_GET, NULL, 0, &amp;threadID); BGM_ALL(); Init(); Startmenu(); if (!key)//第一次开始按下shift键 { Shift(); key = 1; } while (1) { Sleep(speed); Draw(); if (flag == 0) { Firstcontrol(); flag = 1; } Snakemove(); if (Eatself() || Snakebump()) { mciSendString(\"close BGM1\", 0, 0, 0); BGM_FAIL(); break; } Eatfood(); } Overmenu(); switch (_getch()) { case 13: { i = 1; speed = 80; flag = mark = ans = 0; Reset(); threadend = 0; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); threadend = 1; main(); } break; case 27: Thank(); closegraph(); Print(); break; } //多线程结束 WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread);}void BGM_ALL(){ mciSendString(\"open ./Music/Scheming_Weasel.mp3 alias BGM1\", 0, 0, 0); mciSendString(\"play BGM1 repeat\", 0, 0, 0);}unsigned __stdcall BGM_GET(void* pArguments){ while (1) { if (thread) { mciSendString(\"open ./Music/Get.wav alias BGM2\", 0, 0, 0); mciSendString(\"play BGM2 wait\", 0, 0, 0); mciSendString(\"close BGM2 \", 0, 0, 0); thread = 0; } if (!threadend) break; } return 0;}void BGM_FAIL(){ mciSendString(\"open ./Music/Gameover.wav alias BGM3\", 0, 0, 0); mciSendString(\"play BGM3 wait\", 0, 0, 0); mciSendString(\"close BGM3 \", 0, 0, 0);}void Duce(){ if (p == 0) { p = 1; Sleep(300); IMAGE one;//定义一个图片名. loadimage(&amp;one, \"Picture\\\\01.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;one);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE two;//定义一个图片名. loadimage(&amp;two, \"Picture\\\\02.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;two);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE three; loadimage(&amp;three, \"Picture\\\\03.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;three);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1400); IMAGE four; loadimage(&amp;four, \"Picture\\\\04.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;four);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1500); IMAGE five; loadimage(&amp;five, \"Picture\\\\05.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;five);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(1400); cleardevice(); }}void Startmenu(){ //Duce(); while (_kbhit()) getchar(); IMAGE welcome; loadimage(&amp;welcome, \"Picture\\\\00.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;welcome);//绘制图像到屏幕，图片左上角坐标为(0,0) while (1) { if (_getch() == 13) break; }}void Snakeinit(){ srand(GetTickCount()); snake.color1 = RGB(0, 235, 229); snake.size = 4; snake.speed = 10; snake.dir = PAUS; int randomx = rand() % (lx - 100) + 50; int randomy = rand() % (ly - 100) + 50; for (int i = 0; i &lt;= snake.size - 1; i++) { snake.coor[i].x = (randomx / 10) * 10 - 10 * i; //（除10乘10类方格化处理） snake.coor[i].y = (randomy / 10) * 10; }}void Foodinit(){ int j; food.flag = 0; while (!food.flag) { Generatefood(); for (j = 0; j &lt; snake.size; j++) if (fabs(snake.coor[j].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[j].y - food.y) &lt;= food.r) Generatefood(); food.flag = true; }}void Init(){ initgraph(lx, ly);//初始化窗口，大小640*480,/*SHOWCONSOLE*/ Snakeinit();//蛇初始化 Foodinit();//食物初始化}void Drawframe(){ setlinestyle(PS_SOLID, 20); setlinecolor(RGB(93, 107, 153)); rectangle(0, 0, 640, 480);}void Skinsystem(int q){ int i; switch (q) { case 1://YES //蛇头 setfillcolor(RGB(93, 107, 153)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(150, 157, 177)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 2://YES //蛇头 setfillcolor(RGB(186, 63, 110)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(248, 237, 203)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 3://YES setfillcolor(RGB(127, 205, 238)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 4://YES //蛇头 setfillcolor(RGB(221, 192, 179)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 5://YES setfillcolor(RGB(113, 111, 114)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); setfillcolor(RGB(244, 241, 236)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; //蛇头 case 6://YES setfillcolor(RGB(206, 124, 128)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(170, 175, 231)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; case 7://YES setfillcolor(RGB(223, 165, 161)); solidcircle(snake.coor[0].x, snake.coor[0].y, 6); //蛇身 setfillcolor(RGB(123, 130, 184)); for (i = 1; i &lt;= snake.size - 1; i++) solidcircle(snake.coor[i].x, snake.coor[i].y, 5); break; }}void SupDrawsnake(){ if (i &lt;= 7) { Skinsystem(i); i++; } else { Skinsystem(1); i = 1; }}void Drawsnake(){ if (i &lt;= 7) Skinsystem(i); else { Skinsystem(1); i = 1; }}void Drawfood(){ srand(GetTickCount()); if (food.flag) { setfillcolor(RGB(rand() % 256, rand() % 256, rand() % 256)); solidcircle(food.x, food.y, food.r); }}void Draw(){ cleardevice(); BeginBatchDraw();//双缓冲绘图 setbkcolor(RGB(204, 213, 240));//背景色 cleardevice();//清空绘图设备 Drawframe();//画边框 //画蛇(两种模式) if (ans % Sup == 0 &amp;&amp; ans &gt;= 1) SupDrawsnake(); else Drawsnake(); Drawfood();//画食物 EndBatchDraw();//双缓冲绘图结束}void Firstcontrol(){ switch (_getch()) { case 'W': case'w': case 72: if (snake.dir != DOWN) snake.dir = UP; break; case 'S': case 's': case 80: if (snake.dir != UP) snake.dir = DOWN; break; case 'A': case 'a': case 75: if (snake.dir != RIGHT) snake.dir = LEFT; break; case 'D': case 'd': case 77: if (snake.dir != LEFT) snake.dir = RIGHT; break; case 13: Firstcontrol(); break; }}void Keycontrol()//按键控制{ if (_kbhit()) { char key = _getch(); //72,80,75,77 switch (key) { case 'W'://上 case'w': case 72: if (snake.dir != DOWN) snake.dir = UP; break; case 'S'://下 case 's': case 80: if (snake.dir != UP) snake.dir = DOWN; break; case 'A'://左 case 'a': case 75: if (snake.dir != RIGHT) snake.dir = LEFT; break; case 'D'://右 case 'd': case 77: if (snake.dir != LEFT) snake.dir = RIGHT; break; case 13: getchar(); break; } }}void Snakemove(){ int i; for (i = snake.size - 1; i &gt; 0; i--) snake.coor[i] = snake.coor[i - 1]; Keycontrol(); switch (snake.dir) { case UP: snake.coor[0].y -= snake.speed; break; case DOWN: snake.coor[0].y += snake.speed; break; case LEFT: snake.coor[0].x -= snake.speed; break; case RIGHT: snake.coor[0].x += snake.speed; break; case PAUS: getchar(); break; }}void Eatfood(){ if (food.flag &amp;&amp; fabs(snake.coor[0].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[0].y - food.y) &lt;= food.r) { thread = 1;//多线程开始执行 i++; ans++; snake.color1 = food.color; if (speed &gt; 60) speed -= 0.05; food.flag = false; mark += food.r*2/3; snake.size += food.r*2/3; //显示分数 settextstyle(25, 0, \"微软雅黑\"); settextcolor(COLORREF RGB(0, 0, 0)); sprintf_s(s, \"%d\", mark); outtextxy(food.x, food.y, s); } int j; while (!food.flag) { Generatefood(); for (j = 0; j &lt; snake.size; j++) if (fabs(snake.coor[j].x - food.x) &lt;= food.r &amp;&amp; fabs(snake.coor[j].y - food.y) &lt;= food.r) Generatefood(); food.flag = true; }}void Generatefood(){ srand(GetTickCount()); food.x = 10 + (rand() % 60 + 1) * 10; food.y = 10 + (rand() % 44 + 1) * 10; food.color = RGB(rand() % 256, rand() % 256, rand() % 256); food.r = rand() % 6 + 5; return;}int Eatself(){ int j; for (j = 1; j &lt; snake.size; j++) if (snake.coor[j].x == snake.coor[0].x &amp;&amp; snake.coor[j].y == snake.coor[0].y) return 1; return 0;}int Snakebump(){ int k = 10; if (snake.coor[0].x &lt;= k || snake.coor[0].x &gt;= lx - k || snake.coor[0].y &lt;= k || snake.coor[0].y &gt;= ly - k) return 1; return 0;}void Overmenu(){ cleardevice(); IMAGE Game_over;//定义一个图片名. loadimage(&amp;Game_over, \"Picture\\\\game_over.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;Game_over);//绘制图像到屏幕，图片左上角坐标为(0,0) while (1) { if (_getch() == '\\x0d')//回车 break; } cleardevice(); //统计信息 settextstyle(30, 0, \"楷体\"); settextcolor(COLORREF RGB(0, 0, 0)); outtextxy(220, 100, \"GAME OVER\"); sprintf_s(s, \"%d\", mark); outtextxy(220, 150, \"你的分数为\"); outtextxy(380, 150, s); outtextxy(220, 200, \"按Enter重新游戏 \"); outtextxy(220, 250, \"按Esc退出游戏 \");}void Thank(){ IMAGE thank;//定义一个图片名. loadimage(&amp;thank, \"Picture\\\\06.png\", lx, ly, 1);//从图片文件获取图像 putimage(0, 0, &amp;thank);//绘制图像到屏幕，图片左上角坐标为(0,0) Sleep(4000);}void Print(){ printf(\"\\n\"); printf(\"\\n\"); printf(\"感谢您的陪伴！\\n\"); printf(\"您的分数是: %d 分\\n\", mark); printf(\"\\n\"); printf(\"游戏开发者:\\n\"); printf(\"\\n\"); printf(\"桃花涣小鱼干\\n\"); printf(\"\\n\"); getchar(); getchar();}void Reset(){ int i; for (i = 0; i &lt;= snake.size; i++) snake.coor[i].x = snake.coor[i].y = 0;}void Shift(){ keybd_event(0x10, 0, 0, 0); keybd_event(0x10, 0, KEYEVENTF_KEYUP, 0);} 感谢名录 Do_r Jake Mine Paraboy Tremor. Yeyu 沫殇心 感谢陪伴！ END","path":"2021/09/16/S_实践项目/SnakeEating/","date":"09-16","excerpt":"","tags":[{"name":"C语言","slug":"C语言","permalink":"https://帆帆.icu/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Easyx","slug":"Easyx","permalink":"https://帆帆.icu/tags/Easyx/"},{"name":"多线程","slug":"多线程","permalink":"https://帆帆.icu/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"C++","text":"输入输出 Hello World 12345678#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main(){ cout &lt;&lt; \"Hello World\" &lt;&lt; endl; //endl结束输入并回车 cout &lt;&lt; endl; //一个 &lt;&lt; 对应一个输出内容 return 0;} IO(整数) 123456789#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main(){ int a,b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a &lt;&lt;' '&lt;&lt; b; return 0;} IO(字符) 123456789#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main(){ char a,b; cin &gt;&gt; a &gt;&gt; b; //输入时加不加空格都可以(空格不会读入) cout &lt;&lt; a &lt;&lt;' '&lt;&lt; b; return 0;} IO(字符串) 12345678910#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main(){ string ch1,ch2; cin &gt;&gt; ch1 &gt;&gt; ch2; cout &lt;&lt; ch1 &lt;&lt;' '&lt;&lt; ch2; return 0;}//cin遇到空格、Tab、回车时均会停止读取 IO(混合型) 12345678910#include&lt;iostream&gt; //i:输入o:输出stream:流using namespace std; //使用标准命名空间int main(){ string ch; double m; cin &gt;&gt; ch &gt;&gt; m; cout &lt;&lt; ch &lt;&lt; ' ' &lt;&lt; m &lt;&lt; endl; return 0;} 精度控制 12345678910#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main(){ double PI=3.1415926535897; cout &lt;&lt; PI &lt;&lt; endl; //cout默认输出6位(包含整数位) cout &lt;&lt; setprecision(10) &lt;&lt; PI; //设置精度为 10(输出10位) return 0;} 输出当前精度 12345678910111213//cout.precision()当前精度大小#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main(){ double PI=3.1415926535897; cout &lt;&lt; PI &lt;&lt; endl; //cout默认输出6位(包含整数位) cout &lt;&lt; cout.precision()&lt;&lt;endl; //精度为 6 cout &lt;&lt; setprecision(10) &lt;&lt; PI&lt;&lt;endl; //设置精度为 10(输出10位) cout &lt;&lt; cout.precision(); //精度为 10 return 0;} 设置小数点后精度(定点输出) 1234567891011121314//cout.precision()当前精度大小#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main(){ double PI = 3.1415926535897; cout &lt;&lt; fixed; //定点输出(即小数点前固定不变) cout &lt;&lt; PI &lt;&lt; endl; //cout默认输出6位 cout &lt;&lt; cout.precision() &lt;&lt; endl; //精度为 6 cout &lt;&lt; setprecision(10) &lt;&lt; PI &lt;&lt; endl; //设置精度为 10 cout &lt;&lt; cout.precision(); //精度为 10 return 0;} 设置域宽 123456789101112131415//cout.width()当前域宽的大小//setfill()设置填充值，作用效果=1//setw()设置域宽(默认为0、右对齐,作用效果=1)#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main(){ double PI=3.14; cout &lt;&lt; cout.width()&lt;&lt;endl; //输出当前域宽 cout &lt;&lt; PI&lt;&lt;endl; //输出PI cout &lt;&lt; setw(6)&lt;&lt;PI &lt;&lt; endl; //设置域宽为6并输出 cout &lt;&lt; setfill('*') &lt;&lt; setw(6)&lt;&lt; PI &lt;&lt; endl; //设置填充值和域宽并输出 return 0;} 左对齐 123456789101112131415//cout &lt;&lt; left//对其以后的cout统一左对齐输出#include&lt;iostream&gt; //i:输入o:输出stream:流#include&lt;iomanip&gt; //格式控制！！！using namespace std; //使用标准命名空间int main(){ double PI = 3.14; cout &lt;&lt; cout.width() &lt;&lt; endl; //输出当前域宽 cout &lt;&lt; PI &lt;&lt; endl; //输出PI cout &lt;&lt; left; //设置左对齐 cout &lt;&lt; setw(6) &lt;&lt; PI &lt;&lt; endl; //设置域宽为6并输出 cout &lt;&lt; setfill('*') &lt;&lt; setw(6) &lt;&lt; PI &lt;&lt; endl; //设置填充值和域宽并输出 return 0;} 大佬的博客 CSDN 函数高级 默认参数 错误示范 1234void fun(int a, int b=12, int c){ cout &lt;&lt; a + b + c &lt;&lt; endl;} Note：b有了默认参数以后，后面的也必须有默认参数 123456789101112#include&lt;iostream&gt;using namespace std;void fun(int a = 10, int b=90, int c=78);int main(){ fun(1, 2, 3); return 0;}void fun(int a, int b, int c){ cout &lt;&lt; a + b + c &lt;&lt; endl;} Note：声明和实现只能有一个带默认参数 函数重载 01.函数名相同 02.同一作用域 03.函数参数类型、个数或顺序不同 Note：函数返回值不可作为函数重载的条件 对象特征 类对象作为类成员 内部其他类先有，自身再有，析构相反 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class A{public: int aa; A(int ta) :aa(ta) {}};class B{public: int bb; A a; //A a=n(隐式类型转换，基本类型—&gt;定义类) B(int m, int n) :bb(m), a(n){}};void test(){ B b(1,2);}int main(){ test(); return 0;} 静态成员 变量 静态变量：储存于全局数据区域的局部变量，效果和全局变量有一拼 01.默认赋值 12345678910111213#include&lt;iostream&gt;using namespace std;void f(){ static int a ; cout &lt;&lt; a &lt;&lt; endl;}int main(){ f(); return 0;}//输出结果：0（static变量编译器默认赋值为0） 12345678#include &lt;stdio.h&gt;int main(){ static char str[10]; printf(\"string: (begin)%s(end)\\n\", str); return 0;}//输出结果：string: (begin)(end) 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void f(){ static int a=1 ; cout &lt;&lt; a &lt;&lt; endl; a++;}int main(){ f(); f(); return 0;}//输出结果//1//2（第二次static int a = 1 失去作用，始终只有一个a） 可以看出来这个a是在两个f（）中共同使用，不会因为重新声明而覆盖掉，也不会在第一次f（）函数结束时释放掉，static 变量适用于多模块编程，可以将static型变量理解为声明在局部区域的全局变量，但其全局性也只对该局部区域开放。例如上述例子中a对两个f（）函数的区域都开放，若不是同一个局部区域，则无效，例子如下： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;void f(){ static int a = 1; cout &lt;&lt; a &lt;&lt; endl; a++;}void p(){ static int a = 4; cout &lt;&lt; a &lt;&lt; endl; a++;}int main(){ f(); p(); return 0;}//输出结果//1//4//f()中的a的局部全局性在f（）内部//p()中的a的局部全局性在p（）内部//上述两个a具有不同的局部全局性 和全局变量比起来，static可以控制变量的可见范围（隐藏），即局部全局性 一、 static全局变量与普通的全局变量有什么区别 ? 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。 这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 static全局变量只初使化一次，防止在其他文件单元中被引用; 二、static局部变量和普通局部变量有什么区别 ？ 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 static局部变量只被初始化一次，下一次依据上一次结果值； 三、static函数与普通函数有什么区别？ static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件. static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。 四、static的三条重要作用，首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。 02.类内静态变量 类内声明、类外初始化 123456class A{public: static int a;};int A::a = 100;//类型、作用域、名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;class Commodity{public: Commodity(string n=\"xxx\",int q=0,double p=0) { num = n; quantity = q; price = p; } ~Commodity() {}; void total() { double discount = 1; if (quantity &gt; 10) discount = 0.98; n += quantity; sum += price * quantity * discount * this-&gt;discount; } static double average() { return sum / n; } static void display() { cout &lt;&lt; \"总个数：\" &lt;&lt; n &lt;&lt; endl &lt;&lt; \"总售价：\" &lt;&lt; sum &lt;&lt; endl &lt;&lt; \"平均售价：\" &lt;&lt; average(); }private: string num; //编号 int quantity; //数量 double price; //单价 static double sum; //总售价 static double discount; //折扣 static int n; //总销售量};double Commodity::sum = 0;double Commodity::discount = 0.85;int Commodity::n = 0;int main(){ Commodity commo[3] = { Commodity(\"101\",5,23.5),Commodity(\"102\",12,24.56),Commodity(\"103\",100,21.5) }; for (int i = 0; i &lt;= 2; i++) commo[i].total(); Commodity::display(); return 0;} Note：简单而言就是三个售货员共用同一组sum、discount、n 函数 友元 01.友元使原本不可访问的成员能够访问，破坏了数据的隐藏性 全局函数 复制加分号，放到最上方，加 friend 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;class A{ friend void get(A&amp; a);public: A(string n) { name = n; }private: string name;};void get(A&amp; a){ cout &lt;&lt; a.name;}void test(){ A a(\"张三\"); get(a);}int main(){ test(); return 0;} 友元类 同上 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;class A{ friend class B;public: A(string n) { name = n; }private: string name;};class B{public: void func(A&amp; a) { cout &lt;&lt; a.name; }};void test(){ A a(\"张三\"); B b; b.func(a);}int main(){ test(); return 0;} 成员函数（待） 运算符重载 01.实现自定义数据类型的运算 02.不是所有的运算符都可以重载 03.'&gt;&gt;‘和’&lt;&lt;'只能被友元函数重载（猜测：因为要连续输出） 成员函数重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//头文件#include&lt;vector&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;class Student{public: //初始化 Student(string n=\"x\", double s=0) { name = n; score = s; } //重载 &gt; bool operator&gt;(Student&amp; t) { return this-&gt;score &gt; t.score ? true : false; } //重载 = void operator=(Student&amp; t) { this-&gt;name = t.name; this-&gt;score = t.score; } //showStudent void showStudent() { cout &lt;&lt; name &lt;&lt; ' ' &lt;&lt; score &lt;&lt; endl; }private: string name; double score;};void sortStudent(vector&lt;Student&gt;&amp; t){ Student tt; for(int i=t.size()-1;i&gt;=0;i--) for (int j = 0; j &lt; i; j++) { if (t[j] &gt; t[j + 1]) { tt = t[j]; t[j] = t[j + 1]; t[j + 1] = tt; } }}void show(vector&lt;Student&gt;&amp; t){ for (int i = 0; i &lt; t.size(); i++) t[i].showStudent();} 1234567891011121314151617181920//源文件#include\"Student.h\"int main(){ vector&lt;Student&gt; a; cout &lt;&lt; \"请输入 Name AND Score、输入0 0则退出输入\\n\"; while (1) { string name; double score; cin &gt;&gt; name &gt;&gt; score; if (name == \"0\" &amp;&amp; score == 0) break; Student t(name, score); a.push_back(t); } sortStudent(a); show(a); return 0;} 友元函数重载（待） 继承 构造和析构顺序 先构造后析构（先进后出） 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class A{public: A() { cout &lt;&lt; \"A\" &lt;&lt; endl; } ~A() { cout &lt;&lt; \"A析构\" &lt;&lt; endl; };};class B:public A{public: B() { cout &lt;&lt; \"B\" &lt;&lt; endl; } ~B() { cout &lt;&lt; \"B析构\" &lt;&lt; endl; };};class C:public B{public: C() { cout &lt;&lt; \"C\" &lt;&lt; endl; } ~C() { cout &lt;&lt; \"C析构\" &lt;&lt; endl; };};void test(){ C c;}int main(){ test(); return 0;}//结果如下//A//B//C//C析构//B析构//A析构 6派生类构造函数 01.如果被派生的类无构造函数，那系统自动分配默认构造函数,子类的构造时不用再去赋值基类，系统分配默认构造函数自动为其赋值 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class A{ int x; int y;public: };class B :public A{ int z;public: B(int c) :z(c) {} void show() { cout &lt;&lt;z; }};void test(){ B b(3); b.show();}int main(){ test(); return 0;} 02.主类拥有构造函数时，系统不在分配默认构造函数，子类的构造函数必须使用基类的构造函数为主类赋值，否者报错！！！ 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class A{ int x; int y;public: A(int n, int m) :x(n), y(m) {}};class B :public A{ int z;public: B(int a,int b,int c) :A(a,b),z(c) {}//a,b虽继承，但B不能访问a,b，所以使用基类构造函数对a,b初始化 void show() { cout &lt;&lt;z; }};void test(){ B b(1,2,3); b.show();}int main(){ test(); return 0;} Sum：基类的公有成员成为派生类的公有成员，基类的私有部分也成为派生类的一部分，但只能通过基类的公有和保护方法访问。 派生类需要自己的构造函数，派生类不能访问基类的私有数据，所以派生类构造函数要调用基类构造函数来初始化基类的私有数据。基类对象应在程序进入派生类构造函数前被创建，用初始化列表实现。 同名成员处理 成员属性 01.自己的直接用 02.基类的加作用域 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;class A{public: int a; A() { a = 100; } };class B:public A{public: int a; B() { a = 200; }};void test(){ B b; cout &lt;&lt; b.a&lt;&lt;endl; cout &lt;&lt; b.A::a &lt;&lt; endl;}int main(){ test(); return 0;} 成员函数 01.自己的直接用 02.基类的加作用域 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;class A{public: int a; void fun() { cout &lt;&lt; \"A-fun()\" &lt;&lt; endl; } void fun(int t) { cout &lt;&lt; t &lt;&lt; endl; }};class B:public A{public: int b; void fun() { cout &lt;&lt; \"B-fun()\" &lt;&lt; endl; }};void test(){ B b; b.fun(); b.A::fun(); b.A::fun(100);}int main(){ test(); return 0;} 同名静态成员处理 静态成员属性 自己的直接用，父类的加作用域 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;class A{public: static int a;};int A::a = 100;class B:public A{public: static int a;};int B::a = 200;void test(){ //通过对象访问 B b; cout &lt;&lt; b.a &lt;&lt; endl; cout &lt;&lt; b.A::a &lt;&lt; endl; //通过类名来访问 cout &lt;&lt; B::a&lt;&lt;endl; cout &lt;&lt; B::A::a &lt;&lt; endl;}int main(){ test(); return 0;} 静态成员函数 自己的直接用，父类的加作用域 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;class A{public: static void func() { cout &lt;&lt; \"A-func()\" &lt;&lt; endl; }};class B:public A{public: static void func() { cout &lt;&lt; \"B-func()\" &lt;&lt; endl; }};void test(){ //通过对象访问 B b; b.func(); b.A::func(); //通过类名访问 B::func(); B::A::func();}int main(){ test(); return 0;} 多继承语法 加对应作用域即可 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;class A{public: int t; A() { t = 1; }};class B{public: int t; B() { t = 2; }};class C:public A,public B{public: int t; C() { t = 3; }};void test(){ C c; cout &lt;&lt; c.t &lt;&lt; endl; cout &lt;&lt; c.B::t &lt;&lt; endl; cout &lt;&lt; c.A::t &lt;&lt; endl;}int main(){ test(); return 0;} 菱形继承 问题：多份继承，资源浪费,实例如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;//动物class Animal{public: int age;};//羊class Sheep:public Animal{public: };//驼class Tuo :public Animal{public: };//羊驼class SheepTuo :public Sheep, public Tuo{};void test(){ SheepTuo sp; //继承两个age,资源浪费 sp.Sheep::age = 1; sp.Tuo::age = 2;}int main(){ test(); return 0;} 解决方案：使用虚继承，基类变成虚基类，多继承时自动合并，相当于直接从基类继承。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;//动物class Animal{public: int age;};//羊class Sheep:virtual public Animal{public: };//驼class Tuo :virtual public Animal{public: };//羊驼class SheepTuo :public Sheep, public Tuo{};void test(){ SheepTuo sp; sp.age = 18; //直接访问 sp.Sheep::age = 1; //通过内部virtual base pointer找到从Animal中继承的age sp.Tuo::age = 2; //通过内部virtual base pointer找到从Animal中继承的age}int main(){ test(); return 0;} 多态 基本概念 条件： 01.有继承关系 02.子类重写（除了{}内其他完全相同）父类虚函数，重写时virtual可不写 使用方法： 父类指针或引用执行子类对象，例子如下 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;class Animal{public: void virtual func() { cout &lt;&lt; \"动物在说话\" &lt;&lt; endl; }};class Cat:public Animal{public: void func() { cout &lt;&lt; \"猫在说话\" &lt;&lt; endl; }};class Dog :public Animal{public: void func() { cout &lt;&lt; \"狗在说话\" &lt;&lt; endl; }};void doSpeak(Animal&amp; a){ a.func();}void test(){ Dog a; doSpeak(a);}int main(){ test(); return 0;} 底层原理 虚函数定义后实际上保留的是一个指向函数的指针，子类继承后如果重写父类虚函数，那么原来的指针会被子类的指针替换掉。在调用时父类指针或引用的地址由重写的虚函数来确认，不同的继承类虚函数，运行不同的重写函数，可以拥有多种运行状态，即：多态性、简单理解可以认为是基类虚函数可以被子类虚函数覆盖掉。 计算器类 普通写法 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;class Calculator{public: int getResult(char oper) { if (oper == '+') return a + b; if (oper == '-') return a - b; if (oper == '*') return a * b; } int a; int b;};void test(){ Calculator c; c.a = 1; c.b = 2; cout &lt;&lt; c.getResult('*') &lt;&lt; endl;}int main(){ test(); return 0;} 多态写法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;class AbstractCalculator{public: virtual int getResult() { return 0; } int a; int b;};class Add :public AbstractCalculator{public: int getResult() { return a+b; }};class Sub :public AbstractCalculator{public: int getResult() { return a - b; }};class MUL :public AbstractCalculator{public: int getResult() { return a * b; }};class CU :public AbstractCalculator{public: int getResult() { return a / b; }};void test(){ AbstractCalculator* ac = new Add; ac-&gt;a = 1; ac-&gt;b = 2; cout &lt;&lt; ac-&gt;getResult() &lt;&lt; endl; delete ac; ac = new Sub; ac-&gt;a = 1; ac-&gt;b = 2; cout &lt;&lt; ac-&gt;getResult() &lt;&lt; endl; delete ac; ac = new MUL; ac-&gt;a = 1; ac-&gt;b = 2; cout &lt;&lt; ac-&gt;getResult() &lt;&lt; endl; delete ac; ac = new CU; ac-&gt;a = 1; ac-&gt;b = 2; cout &lt;&lt; ac-&gt;getResult() &lt;&lt; endl; delete ac;}int main(){ test(); return 0;} 纯虚函数和抽象类 来源：父类的虚函数的实现是无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数。 一个拥有纯虚函数的类也称为抽象类。 语法：纯虚函数的基础上加一个=0 特点：无法实体化对象，子类必须重写基类的纯虚函数，否者也是抽象类。 1234567891011121314151617181920//无法实例化#include&lt;iostream&gt;using namespace std;class Base{public: //纯虚函数 virtual void func() = 0;};void test(){ Base b; new Base; //报错}int main(){ test(); return 0;} 123456789101112131415161718192021222324//子类未重写也无法实例化#include&lt;iostream&gt;using namespace std;class Base{public: //纯虚函数 virtual void func() = 0;};class Son:public Base{public:};void test(){ Son s;//报错}int main(){ test(); return 0;} 12345678910111213141516171819202122232425262728//正确写法#include&lt;iostream&gt;using namespace std;class Base{public: //纯虚函数 virtual void func() = 0;};class Son:public Base{public: void func() { cout &lt;&lt; \"hahaha\"; };//';'和上面的';'一致};void test(){ Base *b = new Son; b-&gt;func();}int main(){ test(); return 0;} 56-59 文件操作 头文件：fstream 文件分类：文本文件（ASCII）、二进制文件（01） 打开方式： ios::in(文件读入、读) ios::out(输出到文件、写) ios::app(追加方式写文件Append) 12345678910111213141516171819202122232425262728293031#include&lt;fstream&gt;#include&lt;iostream&gt;using namespace std;void test(){ //写 ofstream ofs; ofs.open(\"text.txt\", ios::out);//会覆盖 ofs &lt;&lt; \"张三\" &lt;&lt; endl; ofs.close(); ofs.open(\"text.txt\", ios::app);//不会覆盖(追加) ofs &lt;&lt; \"张三\" &lt;&lt; endl; ofs.close(); //读 ifstream ifs; ifs.open(\"text.txt\", ios::in); string s; ifs &gt;&gt; s; cout &lt;&lt; s; ifs.close();}int main(){ test(); return 0;} 模板 Note：模板只是一个框架，且不是万能的 函数模板 基本用法 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt; //template &lt;class T&gt;也可以void mySwap(T&amp; a, T&amp; b){ T temp = a; a = b; b = temp;}int main(){ int a = 10, b = 20; mySwap(a, b);//自动类型推导 cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; double c = 1.1, d = 2.2; mySwap&lt;double&gt;(c, d);//显示指定类型 cout &lt;&lt; c &lt;&lt; \" \" &lt;&lt; d &lt;&lt; endl; string e, f; e = \"哈哈\"; f = \"嘿嘿\"; mySwap(e, f); cout &lt;&lt; e &lt;&lt; \" \" &lt;&lt; f &lt;&lt; endl; return 0;} 注意事项 1234567891011121314void mySwap(T&amp; a, T&amp; b){ T temp = a; a = b; b = temp;}int main(){ int a = 10, b = 20; char c='c'; mySwap(a, c);//自动类型推导 cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; c &lt;&lt; endl;}//类型不一致导致错误 1234567891011#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt;void fun(){ cout &lt;&lt; \"fun被调用\";}int main(){ fun&lt;int&gt;();//未用到T时必须指明类型(也可用来强制类型转化)} 一个模板对应一个函数！！！！ 排序函数模板 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b){ T temp = a; a = b; b = temp;}template &lt;typename T&gt;void mySort(T a[],int len){ for (int i = 1; i &lt; len; i++) { int k = i; for (int j = i + 1; j &lt; len; j++) { if (a[j] &lt; a[k]) mySwap(a[j], a[k]); } }}template&lt;typename T&gt;void myPrint(T a[], int len){ for (int i = 0; i &lt; len; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl;}int main(){ int a[] = { 1,4,3,7,6 }; mySort(a, sizeof(a) / sizeof(int)); myPrint(a, sizeof(a) / sizeof(int)); char b[] = \"ecdaf\"; mySort(b, sizeof(b)-1); myPrint(b, sizeof(b)-1);} 加&lt;&gt;调用模板函数，否则默认调用普通函数 123456789101112131415161718#include&lt;iostream&gt;using namespace std;void fun(){ cout &lt;&lt; \"普通函数\" &lt;&lt; endl;}template&lt;class T&gt;void fun(){ cout &lt;&lt; \"模板函数\" &lt;&lt; endl;}int main(){ fun(); //普通函数 //fun&lt;&gt;(); //报错 fun&lt;int&gt;(); //模板函数 return 0;} 模板函数也可以重载 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;void fun(int a,int b){ cout &lt;&lt; \"普通函数\" &lt;&lt; endl;}template&lt;typename T&gt;void fun(T a,T b){ cout &lt;&lt; \"模板函数\" &lt;&lt; endl;}template&lt;typename T&gt;void fun(T a,T b,T c ){ cout &lt;&lt; \"重载的模板函数\" &lt;&lt; endl;}int main(){ int a = 10, b = 20, c = 30; fun(a,b); //普通函数 fun&lt;&gt;(a,b); //模板函数 fun(a, b, c); //重载的模板函数 return 0;} 优先不强转调用模板函数，例子如下： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;void fun(int a,int b){ cout &lt;&lt; \"普通函数\" &lt;&lt; endl;}template&lt;typename T&gt;void fun(T a,T b){ cout &lt;&lt; \"模板函数\" &lt;&lt; endl;}int main(){ char a = 'a'; char b = 'b'; fun(a,b); //调用模板函数 return 0;} 模板的具体化（实现更多功能） 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;class Person{public: Person(string na,int nu) { this-&gt;name = na; this-&gt;number = nu; } string name; int number;};template &lt;class T&gt;bool equal(T a, T b){ return a == b;}bool equal(Person a, Person b)//模板具体化，实现Person的比较{ if (a.name == b.name &amp;&amp; a.number == b.number) return true; else return false;}int main(){ Person a(\"张三\", 111); Person b(\"张三\", 111); if (equal(a, b)) cout &lt;&lt; \"a==b\"; else cout &lt;&lt; \"a!=b\"; return 0;} 类模板 语法 12345template &lt;class T&gt;class Person{ //////} 简例： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;template &lt;class typeName,class typeAge&gt;class Person{public: Person(typeName name, typeAge age) { this-&gt;name = name; this-&gt;age = age; } void show() { cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; age &lt;&lt; endl; }private: typeName name; typeAge age;};int main(){ Person &lt;string, int&gt;a(\"张三\", 111); a.show(); return 0;} Note：和函数模板相比较，类模板无自动类型推导，例子如下： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;template &lt;class typeName,class typeAge&gt;class Person{public: Person(typeName name, typeAge age) { this-&gt;name = name; this-&gt;age = age; } void show() { cout &lt;&lt; name &lt;&lt; endl &lt;&lt; age &lt;&lt; endl; }private: typeName name; typeAge age;};int main(){ Person a(\"张三\", 111); a.show(); return 0;}//错误信息：缺少Person模板参数信息 类模板可以设置默认参数，如下 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;template &lt;class typeName=string,class typeAge=int&gt;class Person{public: Person(typeName name, typeAge age) { this-&gt;name = name; this-&gt;age = age; } void show() { cout &lt;&lt; name &lt;&lt; endl &lt;&lt; age &lt;&lt; endl; }private: typeName name; typeAge age;};int main(){ Person &lt;&gt;a(\"张三\", 111); a.show(); return 0;} 176-184 异常处理 C++异常处理由检查try，抛出throw和捕捉catch三部分组成 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;void func(){ int a = 1; try { throw a; } catch (double) { cout &lt;&lt; \"哈哈哈\"; }}int main(){ try { func(); } catch(...) { cout &lt;&lt; \"hahah\"; }} STL vector 简介 vector：向量 一个低维空间的向量可以在无数个高维空间上进行表示，所以一个 vector 的大小是可拓展的 vector 可以看成一个单端数组，左闭右开。 写法：vector&lt;数据类型&gt; 变量名 1vector&lt;int&gt; a;//定义一个放int的向量a vector 与普通数组区别 在于数组是静态空间，而 vector 可以动态扩展，且动态扩展并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间！ CSDN_Voctor voctor 优先队列 一、头文件：queue 二、写法：priority_queue &lt;数据类型，容器类型，排序方式&gt; 例子（1） 123C++#include&lt;queue&gt;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;Q; priority_queue: 优先队列 数据类型:int 型 容器类型:vector 比较方式:greater (更大、升序排列、从 top 到 basic 越来越大) vector 容器基本内涵 vector 数据结构和数组非常相似，也称为单端数组 vector 与普通数组区别 在于数组是静态空间，而 vector 可以动态扩展 且动态扩展并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间！ 后两个 &gt;&gt; 之间一定要有空格，因为 “&gt;&gt;” 是位移运算！！！ 相关链接：[bitMap - 位运算](https://帆帆.icu/2021/07/27/1.算法与数据结构/01.算法/05.图论算法/Bit Map/) 例子（2） 12345678910111213141516171819202122232425262728C++#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;Q;int ans;int main(){ int n, x; cin &gt;&gt; n; while (n--) { cin &gt;&gt; x; Q.push(x); } while (Q.size()!= 1) { int a, b; a = Q.top(); Q.pop(); b = Q.top(); Q.pop(); Q.push(a + b); ans += a + b; } cout &lt;&lt; ans; return 0;} sort函数 头文件：algorithm 写法如下： 12#include&lt;algorithm&gt;sort(起始地址,结束地址,排序方式); 排序int型 12345678910111213#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){ int a[10]={9,6,3,8,5,2,7,4,1,0}; for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+10);//无第三个参数时默认从小到大排序 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;} 123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;bool complare(int a,int b)//排序规则{ return a&gt;b;}int main(){ int a[10]={9,6,3,8,5,2,7,4,1,0}; for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; //从大到小排序 sort(a,a+10,complare);//在这里就不需要对complare函数传入参数了，这是规则 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;} 排序结构体 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct Student{ string name; double score;};bool complare(Student t1,Student t2){ return t1.score &lt; t2.score;}int main(){ Student s[] = { {\"zhan\",89 }, {\"dwad\",92} }; sort(s, s + 2, complare); for (int i = 0; i &lt;= 1; i++) { cout &lt;&lt; s[i].name &lt;&lt; \" \" &lt;&lt; s[i].score &lt;&lt; endl; } return 0;} Note: 在定义排序规则的函数里面，返回的是&lt;就是从小往大排，反之亦然，事实上还可以使用运算符重载的方法来排序结构体，后文将会提到。 细节补充 &amp;的用法 逻辑运算符号：与 略 取地址符 略 位运算 见c语言文章或bitmap算法 引用(换名字) eg1： 123456789#include&lt;iostream&gt;using namespace std;int main(){ int a = 10; int &amp;b = a; cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; return 0;} eg2（函数传入参数时起别名）: 123456789101112131415#include&lt;iostream&gt;using namespace std;void solve(int&amp; a, int&amp; b){ int temp; temp = a; a = b; b = temp;}int main(){ int a = 10; int b = 20; solve(a, b); cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b; return 0;} eg3（常量引用）： 123456789#include&lt;iostream&gt;using namespace std;int main(){ const int &amp;a = 89; //等同于 int temp=89;int &amp;a=temp; cout &lt;&lt; a; return 0;} 宏 C语言中，有两种宏，宏其实是一个代码片段，在用到宏时，会被替换掉。 替换变量 eg： 1#define MAX 100//简单替换 如果宏的代码依然是宏的话，那么会一直往下替换 替换函数 宏还可以来替换函数（可传入参数） eg:(宏定义取大函数) 12345678#define MAX(a,b) ((a)&gt;(b)?(a):(b))#include&lt;iostream&gt;using namespace std;int main(){ int a = 1, b = 99999; cout &lt;&lt; MAX(a, b);} eg:(宏定义for循环) // 宽字符 123456789101112131415161718#include&lt;locale&gt;#include&lt;iostream&gt;using namespace std;int main(){ setlocale(LC_ALL, \"chs\"); //设置中文 wchar_t s[] = L\"好是一个好人\"; unsigned short c = s[0]; //双字节对等，unsigned!!! int j = 0; for (int i = 19968; i &lt;= 40869; i++) { j++; cout &lt;&lt; i &lt;&lt; \" \"; wprintf(L\"%lc\\n\", i); } cout &lt;&lt; j &lt;&lt; endl;} cerr和clog Cerr和Clog 浅拷贝的问题 堆区的内存重复释放！！！","path":"2021/09/16/B_编程语言/C++/","date":"09-16","excerpt":"","tags":[{"name":"C++","slug":"C","permalink":"https://帆帆.icu/tags/C/"}]}],"categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"https://帆帆.icu/tags/DP/"},{"name":"Math","slug":"Math","permalink":"https://帆帆.icu/tags/Math/"},{"name":"线性DP","slug":"线性DP","permalink":"https://帆帆.icu/tags/%E7%BA%BF%E6%80%A7DP/"},{"name":"网络","slug":"网络","permalink":"https://帆帆.icu/tags/%E7%BD%91%E7%BB%9C/"},{"name":"前缀和","slug":"前缀和","permalink":"https://帆帆.icu/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"QT","slug":"QT","permalink":"https://帆帆.icu/tags/QT/"},{"name":"枚举","slug":"枚举","permalink":"https://帆帆.icu/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"哈希","slug":"哈希","permalink":"https://帆帆.icu/tags/%E5%93%88%E5%B8%8C/"},{"name":"二分","slug":"二分","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E5%88%86/"},{"name":"SQL","slug":"SQL","permalink":"https://帆帆.icu/tags/SQL/"},{"name":"位运算","slug":"位运算","permalink":"https://帆帆.icu/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"DFS","slug":"DFS","permalink":"https://帆帆.icu/tags/DFS/"},{"name":"模拟","slug":"模拟","permalink":"https://帆帆.icu/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"递归","slug":"递归","permalink":"https://帆帆.icu/tags/%E9%80%92%E5%BD%92/"},{"name":"递推","slug":"递推","permalink":"https://帆帆.icu/tags/%E9%80%92%E6%8E%A8/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://帆帆.icu/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"打表","slug":"打表","permalink":"https://帆帆.icu/tags/%E6%89%93%E8%A1%A8/"},{"name":"算法","slug":"算法","permalink":"https://帆帆.icu/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://帆帆.icu/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"SP","slug":"SP","permalink":"https://帆帆.icu/tags/SP/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://帆帆.icu/tags/Dijkstra/"},{"name":"概率论","slug":"概率论","permalink":"https://帆帆.icu/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"汇编","slug":"汇编","permalink":"https://帆帆.icu/tags/%E6%B1%87%E7%BC%96/"},{"name":"排序","slug":"排序","permalink":"https://帆帆.icu/tags/%E6%8E%92%E5%BA%8F/"},{"name":"归并","slug":"归并","permalink":"https://帆帆.icu/tags/%E5%BD%92%E5%B9%B6/"},{"name":"learn","slug":"learn","permalink":"https://帆帆.icu/tags/learn/"},{"name":"贝叶斯","slug":"贝叶斯","permalink":"https://帆帆.icu/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/"},{"name":"插入","slug":"插入","permalink":"https://帆帆.icu/tags/%E6%8F%92%E5%85%A5/"},{"name":"快速","slug":"快速","permalink":"https://帆帆.icu/tags/%E5%BF%AB%E9%80%9F/"},{"name":"希尔","slug":"希尔","permalink":"https://帆帆.icu/tags/%E5%B8%8C%E5%B0%94/"},{"name":"选择","slug":"选择","permalink":"https://帆帆.icu/tags/%E9%80%89%E6%8B%A9/"},{"name":"心理学","slug":"心理学","permalink":"https://帆帆.icu/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","permalink":"https://帆帆.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","permalink":"https://帆帆.icu/tags/%E5%9B%BE/"},{"name":"搜索🔍","slug":"搜索🔍","permalink":"https://帆帆.icu/tags/%E6%90%9C%E7%B4%A2%F0%9F%94%8D/"},{"name":"BFS","slug":"BFS","permalink":"https://帆帆.icu/tags/BFS/"},{"name":"C语言","slug":"C语言","permalink":"https://帆帆.icu/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"Python","permalink":"https://帆帆.icu/tags/Python/"},{"name":"二进制","slug":"二进制","permalink":"https://帆帆.icu/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"机器编码","slug":"机器编码","permalink":"https://帆帆.icu/tags/%E6%9C%BA%E5%99%A8%E7%BC%96%E7%A0%81/"},{"name":"APP","slug":"APP","permalink":"https://帆帆.icu/tags/APP/"},{"name":"导数","slug":"导数","permalink":"https://帆帆.icu/tags/%E5%AF%BC%E6%95%B0/"},{"name":"链表","slug":"链表","permalink":"https://帆帆.icu/tags/%E9%93%BE%E8%A1%A8/"},{"name":"文件","slug":"文件","permalink":"https://帆帆.icu/tags/%E6%96%87%E4%BB%B6/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://帆帆.icu/tags/MarkDown/"},{"name":"睡眠","slug":"睡眠","permalink":"https://帆帆.icu/tags/%E7%9D%A1%E7%9C%A0/"},{"name":"消费主义","slug":"消费主义","permalink":"https://帆帆.icu/tags/%E6%B6%88%E8%B4%B9%E4%B8%BB%E4%B9%89/"},{"name":"句","slug":"句","permalink":"https://帆帆.icu/tags/%E5%8F%A5/"},{"name":"小说","slug":"小说","permalink":"https://帆帆.icu/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"树","slug":"树","permalink":"https://帆帆.icu/tags/%E6%A0%91/"},{"name":"HT","slug":"HT","permalink":"https://帆帆.icu/tags/HT/"},{"name":"冒泡","slug":"冒泡","permalink":"https://帆帆.icu/tags/%E5%86%92%E6%B3%A1/"},{"name":"并查集","slug":"并查集","permalink":"https://帆帆.icu/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"RMQ","slug":"RMQ","permalink":"https://帆帆.icu/tags/RMQ/"},{"name":"位图","slug":"位图","permalink":"https://帆帆.icu/tags/%E4%BD%8D%E5%9B%BE/"},{"name":"BT","slug":"BT","permalink":"https://帆帆.icu/tags/BT/"},{"name":"String","slug":"String","permalink":"https://帆帆.icu/tags/String/"},{"name":"MST","slug":"MST","permalink":"https://帆帆.icu/tags/MST/"},{"name":"Prim","slug":"Prim","permalink":"https://帆帆.icu/tags/Prim/"},{"name":"LCA","slug":"LCA","permalink":"https://帆帆.icu/tags/LCA/"},{"name":"Easyx","slug":"Easyx","permalink":"https://帆帆.icu/tags/Easyx/"},{"name":"多线程","slug":"多线程","permalink":"https://帆帆.icu/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://帆帆.icu/tags/C/"}]}